<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ChatSpheres - Join Your Sphere</title>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="styles/tailwind.generated.css">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    * {
      font-family: 'Nunito', sans-serif;
    }
    
    .video-placeholder {
      background: linear-gradient(135deg, #22223B 0%, #2a2a4a 100%);
    }
    
    /* Fix screen share orientation and display */
    #screen-share-video,
    #spectator-screen-share {
      transform: scaleX(1) !important; /* Ensure no horizontal flip */
      object-fit: contain !important; /* Show full screen content */
      background-color: #000 !important; /* Black background for letterboxing */
    }
    
    /* Mirror local camera by default */
    #local-video {
      transform: scaleX(-1); /* Mirror local camera */
    }
    
    /* Remove mirror when screen sharing (local user sees their own screen normally) */
    #local-video.screen-sharing {
      transform: none !important;
    }
    
    /* Override any transform on screen share videos to prevent flipping */
    video[id*="screen"] {
      transform: none !important;
    }
    
    /* Ensure remote screen shares are never flipped */
    #screen-share-video,
    #spectator-screen-share {
      transform: none !important;
    }
    
    /* Full screen expansion styles */
    .video-fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9999 !important;
      background: #000 !important;
    }
    
    .video-fullscreen video {
      width: 100% !important;
      height: 100% !important;
      object-fit: contain !important;
    }
    
    /* Fullscreen button styles */
    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      padding: 8px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
      transition: background 0.2s;
    }
    
    .fullscreen-btn:hover {
      background: rgba(0, 0, 0, 0.9);
    }
    
    .chatspheres-pattern {
      position: relative;
      overflow: hidden;
    }
    
    .chatspheres-pattern::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 30% 70%, rgba(230, 57, 70, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 70% 30%, rgba(255, 209, 102, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .vesica-accent {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.1;
      pointer-events: none;
    }
    
    .timer-glow {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .new-spark-btn {
      background: #FFD166;
      color: #22223B;
      transition: all 0.2s ease;
    }
    
    .new-spark-btn:hover {
      background: #e63946;
      color: white;
      transform: scale(1.05);
    }
    
    .topic-badge {
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%);
      color: white;
    }

    /* Waiting overlay styles */
    #waiting-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      border: 3px solid #fff;
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(230, 57, 70, 0.15);
      padding: 1.5rem 2rem;
      z-index: 9999;
      text-align: center;
      width: 320px;
    }

    #waiting-overlay .waiting-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #e63946;
      margin-bottom: 0.5rem;
    }

    #waiting-overlay .waiting-subtitle {
      font-size: 0.95rem;
      color: #22223B;
      margin-bottom: 1rem;
    }

    #waiting-overlay .status-badge {
      background: #FFD166;
      color: #22223B;
      padding: 0.5rem 1rem;
      border-radius: 100px;
      font-weight: 700;
      font-size: 0.85rem;
    }

    .loading-dots::after {
      content: '';
      animation: loading-dots 1.5s infinite;
      margin-left: 0.25rem;
    }

    @keyframes loading-dots {
      0% { content: ''; }
      25% { content: '.'; }
      50% { content: '..'; }
      75% { content: '...'; }
      100% { content: ''; }
    }

    .control-btn {
      transition: all 0.2s ease;
    }

    .control-btn.active {
      background: #e63946 !important;
      color: white !important;
    }

    /* Live Chat Styles */
    .live-chat {
      max-height: 400px;
      overflow-y: auto;
    }

    .live-chat::-webkit-scrollbar {
      width: 4px;
    }

    .live-chat::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 2px;
    }

    .live-chat::-webkit-scrollbar-thumb {
      background: #FFD166;
      border-radius: 2px;
    }

    .live-chat::-webkit-scrollbar-thumb:hover {
      background: #e63946;
    }

    .chat-message {
      animation: slideInRight 0.3s ease-out;
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .spectator-badge {
      background: linear-gradient(135deg, #FFB6B9 0%, #FCE2E5 100%);
      color: #22223B;
    }

    .participant-badge {
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%);
      color: white;
    }

    /* Recording Indicator */
    .recording-indicator {
      animation: recordingPulse 1s infinite;
    }

    @keyframes recordingPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .recording-upload-status {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .recording-upload-bar {
      margin-top: 4px;
      width: 100%;
      height: 3px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 9999px;
      overflow: hidden;
    }

    .recording-upload-bar-fill {
      height: 100%;
      width: 0%;
      background: #FFD166;
      transition: width 0.2s ease;
    }

    /* Modal Styles */
    .modal-overlay {
      background: rgba(34, 34, 59, 0.8);
      backdrop-filter: blur(4px);
    }

    /* Spectator Immersive View Styles */
    .spectator-expanded {
      grid-template-columns: 5fr 1fr !important; /* Expand video area, shrink chat */
    }
    
    .spectator-video-expanded {
      transform: scale(1.02);
      transition: all 0.3s ease;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      border: 3px solid #e63946;
    }
    
    .expand-button {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(230, 57, 70, 0.9);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
      transition: all 0.2s;
      font-size: 12px;
      font-weight: bold;
      backdrop-filter: blur(4px);
    }
    
    .expand-button:hover {
      background: rgba(230, 57, 70, 1);
      transform: scale(1.05);
    }
    
    .expand-button.expanded {
      background: rgba(255, 209, 102, 0.9);
      color: #22223B;
    }
    
    .expand-button.expanded:hover {
      background: rgba(255, 209, 102, 1);
    }
    
    /* Immersive overlay for full focus */
    .immersive-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: none;
      padding: 20px;
    }
    
    .immersive-content {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: 4fr 1fr;
      gap: 20px;
      max-width: none;
    }
    
    .immersive-video {
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }
    
    .immersive-chat {
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    @media (max-width: 768px) {
      #waiting-overlay {
        width: 200px;
        top: 8px;
        left: 8px;
        right: auto;
        padding: 0.75rem 1rem;
      }
      
      .live-chat {
        max-height: 300px;
      }
    }

    /* CRITICAL: Force overlay visibility when cameras are off */
    .spectator-overlay-force-visible {
      display: flex !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      z-index: 9999 !important;
    }
  </style>
</head>
<body class="bg-bg-light dark:bg-charcoal min-h-screen font-nunito">

<!-- Recording Consent Modal -->
<div id="recording-consent-modal" class="hidden fixed inset-0 z-50 modal-overlay flex items-center justify-center p-4">
  <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-md w-full shadow-2xl border border-gray-200 dark:border-gray-700">
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center">
        <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M7 4V2a1 1 0 011-1h4a1 1 0 011 1v2h3a1 1 0 110 2h-1v9a2 2 0 01-2 2H7a2 2 0 01-2-2V6H4a1 1 0 110-2h3zM9 6v8a1 1 0 102 0V6a1 1 0 10-2 0z" clip-rule="evenodd"/>
        </svg>
      </div>
      <h3 class="text-xl font-bold text-charcoal dark:text-white mb-2">üé• Start Recording?</h3>
      <p class="text-gray-600 dark:text-gray-300 text-sm">This will record video, audio, screen shares, and chat messages for all participants.</p>
    </div>
    
    <div class="space-y-4 mb-6">
      <div>
        <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">Privacy Setting</label>
        <select id="recording-privacy" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
          <option value="private">üîí Private (only participants can view)</option>
          <option value="public">üåê Public (anyone with link can view)</option>
        </select>
      </div>
      
      <div>
        <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">Auto-delete</label>
        <select id="recording-auto-delete" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
          <option value="never">Never delete</option>
          <option value="7">Delete after 7 days</option>
          <option value="30">Delete after 30 days</option>
          <option value="90">Delete after 90 days</option>
        </select>
      </div>
    </div>
    
    <div class="flex space-x-3">
      <button onclick="cancelRecording()" class="flex-1 px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg font-semibold">Cancel</button>
      <button onclick="confirmRecording()" class="flex-1 px-4 py-2 bg-main-red text-white hover:bg-red-600 rounded-lg font-semibold">Start Recording</button>
    </div>
  </div>
</div>

<!-- Waiting Overlay -->
<div id="waiting-overlay">
  <div class="mb-4">
    <svg viewBox="0 0 64 64" width="64" height="64" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="6"/>
      <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="6"/>
      <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
      <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
    </svg>
  </div>
  <div class="text-2xl mb-2">üê±‚ú®</div>
  <div class="waiting-title">preparing your sphere</div>
  <div class="waiting-subtitle" id="waiting-mode">joining room...</div>
  <div class="status-badge">
    Connecting<span class="loading-dots"></span>
  </div>
  
  <div style="margin-top: 1rem; font-size: 0.85rem; color: #222;">
    <strong>Topic:</strong> <span id="topic-text">Loading...</span><br>
    <strong>Description:</strong> <span id="topic-description">Please wait...</span>
  </div>
</div>

<!-- Main Video Chat Interface -->
<div id="video-interface" class="hidden">
  <!-- Header -->
  <header class="bg-white dark:bg-charcoal shadow-sm border-b border-gray-200 dark:border-gray-700 px-4 py-3">
    <div class="max-w-7xl mx-auto flex items-center justify-between">
      <!-- Logo -->
      <div class="flex items-center space-x-3">
        <svg viewBox="0 0 64 64" width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="6"/>
          <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="6"/>
          <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
          <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
        </svg>
        <h1 class="text-xl font-bold text-charcoal dark:text-white">chatspheres</h1>
        
        <!-- User Role Badge -->
        <div id="user-role-badge" class="hidden px-3 py-1 rounded-full text-xs font-bold">
          <span id="role-text">participant</span>
        </div>
        
        <!-- Live Indicator -->
        <div id="live-indicator" class="hidden flex items-center space-x-2 bg-main-red text-white px-3 py-1 rounded-full text-xs font-bold">
          <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
          <span>LIVE</span>
          <span id="viewer-count">0</span>
          <span>üëÅÔ∏è</span>
        </div>
        
          <!-- Recording Indicator -->
          <div id="recording-status" class="hidden bg-red-600 text-white px-3 py-2 rounded-2xl text-xs font-bold space-y-1">
            <div class="flex items-center space-x-2">
              <div class="recording-dot w-2 h-2 bg-white rounded-full"></div>
              <span id="recording-mode-label">REC</span>
              <span id="recording-upload-status" class="recording-upload-status hidden">
                <span id="recording-upload-label">uploading</span>
                <span id="recording-upload-percent">0%</span>
              </span>
            </div>
            <div id="recording-upload-bar" class="recording-upload-bar hidden">
              <div id="recording-upload-bar-fill" class="recording-upload-bar-fill"></div>
            </div>
          </div>
      </div>
      
      <!-- Timer -->
        <div class="flex items-center space-x-3">
        <div class="timer-glow bg-main-red text-white px-4 py-2 rounded-full font-bold text-lg">
          <span id="timer-header">60:00</span>
        </div>
          <div class="hidden sm:flex flex-col leading-tight">
            <span class="text-sm text-gray-600 dark:text-gray-300">time remaining</span>
            <span class="text-xs text-gray-500 dark:text-gray-400">minutes used: <span id="minutes-used-header">0</span></span>
          </div>
      </div>
    </div>
  </header>

  <div class="max-w-7xl mx-auto px-4 py-6">
    <!-- Topic Section -->
    <div class="mb-6 text-center">
      <div class="topic-badge inline-block px-6 py-3 rounded-full font-bold text-lg mb-3">
        üåü <span id="topic-display">Loading Topic...</span>
      </div>
      <p class="text-charcoal dark:text-gray-300 text-base max-w-2xl mx-auto" id="topic-desc-display">
        Loading description...
      </p>
    </div>

    <!-- Main Content Grid - Both modes now have chat -->
    <div id="participant-layout" class="grid lg:grid-cols-4 gap-6">
      <!-- Video Section -->
      <div class="lg:col-span-3 space-y-4">
        <!-- Remote Video -->
        <div class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video chatspheres-pattern">
          <video id="remote-video" class="w-full h-full object-cover hidden" autoplay playsinline></video>
          <video id="screen-share-video" class="w-full h-full object-cover hidden" autoplay playsinline></video>
          
          <!-- Fullscreen Button -->
          <button class="fullscreen-btn" onclick="toggleFullscreen('remote-video')" title="Expand video">
            <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
              <path d="M3 3a1 1 0 000 2h2.586L2.293 8.293a1 1 0 101.414 1.414L7 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1H3zM17 3a1 1 0 100 2h-2.586l3.293 3.293a1 1 0 01-1.414 1.414L13 6.414V9a1 1 0 11-2 0V4a1 1 0 011-1h5z"/>
            </svg>
          </button>
          
          <div id="remote-placeholder" class="absolute inset-0 flex items-center justify-center video-placeholder">
            <svg class="vesica-accent" viewBox="0 0 64 64" width="120" height="120" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="3"/>
              <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="3"/>
              <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="2" fill="none"/>
              <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="2" fill="none"/>
            </svg>
            
            <div class="text-center text-white relative z-10">
              <div class="w-16 h-16 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg">
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              </div>
              <p class="font-bold text-lg text-white">Waiting for your chat partner...</p>
              <p class="text-sm text-gold mt-1">üê± They might be as curious as a cat about this topic!</p>
            </div>
          </div>

          <!-- Participant Info -->
          <div id="remote-info" class="absolute top-4 left-4 bg-main-red text-white px-4 py-2 rounded-full text-sm font-semibold shadow-lg">
            <span id="remote-name">Guest</span>
          </div>
        </div>

        <!-- Local Video (hidden for spectators) -->
        <div id="local-video-container" class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video sm:aspect-[4/3] lg:aspect-video chatspheres-pattern">
          <video id="local-video" class="w-full h-full object-cover scale-x-[-1]" autoplay playsinline muted></video>
          
          <div id="local-placeholder" class="absolute inset-0 flex items-center justify-center video-placeholder">
            <svg class="vesica-accent" viewBox="0 0 64 64" width="80" height="80" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="2"/>
              <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="2"/>
              <circle cx="24" cy="32" r="18" stroke="#FFD166" stroke-width="2" fill="none"/>
              <circle cx="40" cy="32" r="18" stroke="#FFD166" stroke-width="2" fill="none"/>
            </svg>
            
            <div class="text-center text-white relative z-10">
              <div class="w-12 h-12 mx-auto mb-3 bg-gold rounded-full flex items-center justify-center shadow-lg">
                <svg class="w-6 h-6 text-charcoal" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              </div>
              <p class="font-bold text-gold">You</p>
            </div>
          </div>

          <!-- Enhanced Controls (hidden for spectators) -->
          <div id="participant-controls" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2">
            <button id="mic-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-main-red text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="camera-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-main-red text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"/>
              </svg>
            </button>
            <button id="screen-share-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-gold text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zm2 3a1 1 0 000 2h.01a1 1 0 100-2H5zm3 0a1 1 0 000 2h.01a1 1 0 100-2H8zm3 0a1 1 0 000 2h.01a1 1 0 100-2H11z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="record-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-red-600 text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="settings-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-gold text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="leave-btn" class="control-btn bg-main-red hover:bg-red-600 text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 1.414L9.586 11l-2.293 2.293a1 1 0 001.414 1.414L10 12.414l1.293 1.293a1 1 0 001.414-1.414L11.414 11l2.293-2.293z" clip-rule="evenodd"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Device Settings Panel -->
        <div id="settings-panel" class="hidden bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <h3 class="text-lg font-bold text-charcoal dark:text-white mb-4">üéõÔ∏è Device Settings</h3>
          
          <div class="grid md:grid-cols-2 gap-4">
            <div>
              <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">üìπ Camera</label>
              <select id="camera-selector" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
                <option disabled selected>Select camera...</option>
              </select>
            </div>
            
            <div>
              <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">üé§ Microphone</label>
              <select id="mic-selector" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
                <option disabled selected>Select microphone...</option>
              </select>
            </div>
          </div>
          
          <div class="mt-4 text-center">
            <button id="close-settings" class="new-spark-btn px-6 py-2 rounded-full font-bold text-sm">Close Settings</button>
          </div>
        </div>
      </div>

      <!-- Live Chat and Sparks Sidebar -->
      <div class="lg:col-span-1 space-y-6">
        <!-- Live Chat (also for participants) -->
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col">
          <!-- Chat Header -->
          <div class="p-4 border-b border-gray-200 dark:border-gray-600">
            <div class="flex items-center justify-between">
              <h3 class="font-bold text-charcoal dark:text-white">üí¨ Live Chat</h3>
              <div class="text-xs text-gray-500 dark:text-gray-400">
                <span id="participant-chat-viewer-count">0</span> viewers
              </div>
            </div>
          </div>

          <!-- Chat Messages -->
          <div id="participant-chat-messages" class="flex-1 overflow-y-auto p-4 space-y-3 live-chat" style="height: 250px;">
            <!-- Welcome message -->
            <div class="text-center text-xs text-gray-500 dark:text-gray-400 py-2">
              Welcome to the chat! üëã
            </div>
          </div>

          <!-- Chat Input -->
          <div class="p-4 border-t border-gray-200 dark:border-gray-600">
            <div class="flex space-x-2">
              <input 
                type="text" 
                id="participant-chat-input"
                placeholder="Type a message..."
                maxlength="200"
                class="flex-1 px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                id="participant-send-chat"
                onclick="sendParticipantChatMessage()"
                class="bg-main-red hover:bg-red-600 text-white p-2 rounded-lg transition-colors"
              >
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"/>
                </svg>
              </button>
            </div>
            <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
              <span id="participant-char-count">0</span>/200 characters
            </div>
          </div>
        </div>

        <!-- Conversation Sparks -->
        <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <!-- Header -->
          <div class="flex items-center justify-between mb-6">
            <h3 class="text-lg font-bold text-charcoal dark:text-white flex items-center">
              ‚ú® conversation sparks
            </h3>
            <button 
              id="newSparkBtn" 
              class="new-spark-btn px-4 py-2 rounded-full font-bold text-sm"
              onclick="generateNewSparks()"
            >
              üîÑ new spark
            </button>
          </div>

          <!-- Single Conversation Spark -->
          <div id="sparksContainer">
            <div class="relative">
              <!-- Main Spark Display -->
              <div id="currentSpark" class="bg-gradient-to-br from-light-rose to-rose p-6 rounded-2xl shadow-lg border-2 border-transparent hover:border-main-red transition-all cursor-pointer" onclick="selectCurrentSpark()">
                <div class="flex items-start justify-between mb-3">
                  <div class="bg-main-red text-white px-3 py-1 rounded-full text-xs font-bold">
                    SPARK #<span id="sparkNumber">1</span>
                  </div>
                  <div class="text-main-red">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                    </svg>
                  </div>
                </div>
                <blockquote class="text-charcoal font-bold text-base leading-relaxed italic">
                  "<span id="sparkText">If you could have a conversation with your future self from 10 years from now, what would you want to ask them about the choices you're making today?</span>"
                </blockquote>
                <div class="mt-4 text-center">
                  <span class="text-xs text-charcoal font-semibold opacity-70">üëÜ Click to highlight for both users</span>
                </div>
              </div>

              <!-- Navigation Controls -->
              <div class="flex justify-between items-center mt-4">
                <button 
                  id="prevSparkBtn"
                  onclick="navigateSpark('prev')" 
                  class="flex items-center space-x-2 bg-gold hover:bg-main-red text-charcoal hover:text-white px-4 py-2 rounded-full font-bold text-sm transition-all"
                >
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"/>
                  </svg>
                  <span>Previous</span>
                </button>
                
                <div class="flex space-x-2">
                  <span id="sparkDot1" class="w-2 h-2 bg-main-red rounded-full transition-all"></span>
                  <span id="sparkDot2" class="w-2 h-2 bg-gray-300 rounded-full transition-all"></span>
                  <span id="sparkDot3" class="w-2 h-2 bg-gray-300 rounded-full transition-all"></span>
                </div>
                
                <button 
                  id="nextSparkBtn"
                  onclick="navigateSpark('next')" 
                  class="flex items-center space-x-2 bg-gold hover:bg-main-red text-charcoal hover:text-white px-4 py-2 rounded-full font-bold text-sm transition-all"
                >
                  <span>Next</span>
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <!-- User Prompts Section -->
          <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-600">
            <h4 class="text-sm font-bold text-charcoal dark:text-white mb-3">Custom Spark Request</h4>
            <div class="space-y-3">
              <input 
                type="text" 
                id="userPrompt"
                placeholder="e.g., 'questions about career changes'"
                class="w-full px-4 py-3 text-base border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                onclick="generateCustomSparks()" 
                class="w-full new-spark-btn py-3 rounded-xl font-bold text-sm"
              >
                ‚ö° Generate Custom Sparks
              </button>
            </div>
          </div>

          <!-- Fun Facts -->
          <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-600">
            <div class="text-center text-xs text-gray-500 dark:text-gray-400">
              <p>üí° Like a Pok√©mon evolving through battles,</p>
              <p>great conversations evolve through curiosity!</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Spectator Layout -->
    <div id="spectator-layout" class="hidden grid lg:grid-cols-4 gap-6">
      <!-- Main Video (3/4 width) -->
      <div class="lg:col-span-3 space-y-4">
        <!-- Simple 2-Participant View for Spectators -->
        <div class="space-y-4">
          <!-- Main Conversation Area - Both Participants -->
          <div class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video chatspheres-pattern">
            <!-- Screen Share Video (takes full space when active) -->
            <video id="spectator-screen-share" class="w-full h-full object-cover hidden" autoplay playsinline></video>
            
            <!-- Two-Participant Layout -->
            <div id="spectator-participants-container" class="w-full h-full grid grid-cols-2 gap-1">
              <!-- Participant 1 -->
              <div class="relative bg-charcoal">
                <video id="spectator-participant-1" class="w-full h-full object-cover hidden" autoplay playsinline></video>
                <div id="spectator-placeholder-1" class="absolute inset-0 flex items-center justify-center video-placeholder">
                  <div class="text-center text-white">
                    <div class="w-12 h-12 mx-auto mb-2 bg-main-red rounded-full flex items-center justify-center">
                      <span class="text-white font-bold">1</span>
                    </div>
                    <p class="text-sm">Waiting for participant...</p>
                  </div>
                </div>
                <div id="spectator-name-1" class="absolute bottom-2 left-2 bg-main-red text-white px-2 py-1 rounded text-sm font-semibold hidden">
                  Participant 1
                </div>
              </div>
              
              <!-- Participant 2 -->
              <div class="relative bg-charcoal">
                <video id="spectator-participant-2" class="w-full h-full object-cover hidden" autoplay playsinline></video>
                <div id="spectator-placeholder-2" class="absolute inset-0 flex items-center justify-center video-placeholder">
                  <div class="text-center text-white">
                    <div class="w-12 h-12 mx-auto mb-2 bg-gold rounded-full flex items-center justify-center">
                      <span class="text-charcoal font-bold">2</span>
                    </div>
                    <p class="text-sm">Waiting for participant...</p>
                  </div>
                </div>
                <div id="spectator-name-2" class="absolute bottom-2 left-2 bg-gold text-charcoal px-2 py-1 rounded text-sm font-semibold hidden">
                  Participant 2
                </div>
              </div>
            </div>
            
            <!-- Expand Button for Participants View -->
            <button id="expand-participants-btn" class="expand-button" onclick="toggleSpectatorExpansion('participants')" style="display: none;">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
              </svg>
              EXPAND
            </button>

            <!-- Expand Button for Screen Share -->
            <button id="expand-screenshare-btn" class="expand-button" onclick="toggleSpectatorExpansion('screenshare')" style="display: none;">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 15a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1v-2z"/>
              </svg>
              EXPAND
            </button>
            
            <!-- Click to Enable Overlay -->
            <div id="spectator-click-overlay" class="absolute inset-0 flex items-center justify-center video-placeholder cursor-pointer transition-all hover:bg-opacity-80 spectator-overlay-force-visible" onclick="enableSpectatorVideo()" style="z-index: 9999 !important; display: flex !important; opacity: 1 !important; visibility: visible !important; pointer-events: auto !important;"
              <div class="text-center text-white">
                <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
                  <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
                  </svg>
                </div>
                <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
                <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
                <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
                  üëÜ Click Here to Enable Video
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Spectator Notice -->
        <div class="bg-gradient-to-r from-light-rose to-rose rounded-xl p-4 border border-rose">
          <div class="flex items-center space-x-3">
            <div class="text-2xl">üëÄ</div>
            <div>
              <h3 class="font-bold text-charcoal mb-1">You're watching as a spectator</h3>
              <p class="text-sm text-charcoal opacity-80">Enjoy the conversation and share your thoughts in the live chat!</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Live Chat (1/4 width) -->
      <div class="lg:col-span-1">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-700 h-full flex flex-col">
          <!-- Chat Header -->
          <div class="p-4 border-b border-gray-200 dark:border-gray-600">
            <div class="flex items-center justify-between">
              <h3 class="font-bold text-charcoal dark:text-white">üí¨ Live Chat</h3>
              <div class="text-xs text-gray-500 dark:text-gray-400">
                <span id="chat-viewer-count">0</span> viewers
              </div>
            </div>
          </div>

          <!-- Chat Messages -->
          <div id="live-chat-messages" class="flex-1 overflow-y-auto p-4 space-y-3 live-chat">
            <!-- Welcome message -->
            <div class="text-center text-xs text-gray-500 dark:text-gray-400 py-2">
              Welcome to the chat! üëã
            </div>
          </div>

          <!-- Chat Input -->
          <div class="p-4 border-t border-gray-200 dark:border-gray-600">
            <div class="flex space-x-2">
              <input 
                type="text" 
                id="chat-input"
                placeholder="Type a message..."
                maxlength="200"
                class="flex-1 px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                id="send-chat"
                onclick="sendChatMessage()"
                class="bg-main-red hover:bg-red-600 text-white p-2 rounded-lg transition-colors"
              >
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"/>
                </svg>
              </button>
            </div>
            <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
              <span id="char-count">0</span>/200 characters
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Sticky Timer -->
<div id="stickyTimer" class="fixed top-4 right-4 z-50 transition-all duration-300 opacity-0 transform translate-y-[-20px]">
  <div class="timer-glow bg-main-red text-white px-3 py-2 rounded-full font-bold text-sm shadow-lg">
    <div class="flex flex-col items-center leading-tight">
      <span id="timer">60:00</span>
      <span class="text-[11px] text-white text-opacity-80 mt-1">used <span id="minutes-used-sticky">0</span> min</span>
    </div>
  </div>
</div>

<!-- Toast -->
<div id="toast" class="fixed bottom-4 right-4 bg-main-red text-white px-6 py-3 rounded-xl shadow-lg transform translate-y-full transition-transform hidden z-40">
  <p id="toastMessage"></p>
</div>

<script src="https://unpkg.com/@daily-co/daily-js"></script>
<script>
  // Firebase config - Main database
  const firebaseConfig = {
    apiKey: "AIzaSyBno0Zb0MD91F2PzTlSFYnvBQNf8Nv_-wQ",
    authDomain: "chatspheresfirebasedb.firebaseapp.com",
    databaseURL: "https://chatspheresfirebasedb-default-rtdb.firebaseio.com",
    projectId: "chatspheresfirebasedb",
    storageBucket: "chatspheresfirebasedb.firebasestorage.app",
    messagingSenderId: "224075573732",
    appId: "1:224075573732:web:47e014622bd263fb2abff1",
    measurementId: "G-PJ2X2LSEF9"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  function cleanupLegacyFirebaseApps() {
    if (!firebase || !firebase.apps) {
      return;
    }
    firebase.apps.forEach((app) => {
      const appName = app?.name || '';
      if (appName && appName !== '[DEFAULT]' && appName.toLowerCase().includes('prompts')) {
        try {
          app.delete().then(() => {
            console.log(`üßπ Removed legacy Firebase app: ${appName}`);
          }).catch((error) => {
            console.warn(`‚ö†Ô∏è Unable to delete legacy Firebase app ${appName}:`, error);
          });
        } catch (error) {
          console.warn(`‚ö†Ô∏è Error while removing legacy Firebase app ${appName}:`, error);
        }
      }
    });
  }
  cleanupLegacyFirebaseApps();

  firebase.database().ref('.info/serverTimeOffset').on('value', (snapshot) => {
    const offset = snapshot.val();
    serverTimeOffset = typeof offset === 'number' ? offset : 0;
  });

  // Prompts Realtime Database (REST access only)
  const PROMPTS_DATABASE_URL = 'https://chatspheresfirebasepromptsai-default-rtdb.firebaseio.com';
  const promptsDatabaseBaseUrl = (PROMPTS_DATABASE_URL || '').replace(/\/$/, '');

    // Supabase client setup for session tracking
    const SUPABASE_URL = 'https://farihwlzjieqmgvhagxt.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhcmlod2x6amllcW1ndmhhZ3h0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM4OTYyNzEsImV4cCI6MjA2OTQ3MjI3MX0.rlZiUqfFfJSGrS5dVcm-s96L4v7Fb4cgvLUnJeOtYEE';

    let supabaseClient = null;

    if (window.supabase && window.supabase.createClient) {
      try {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false }
        });
        console.log('‚úÖ Supabase client initialized successfully');
      } catch (error) {
        console.error('‚ùå Failed to initialize Supabase:', error);
      }
    } else {
      console.error('‚ùå Supabase library not loaded from CDN');
    }

  // Global variables
  let call = null;
  let localVideo = null;
  let remoteVideo = null;
  let screenShareVideo = null;
  let isCameraOn = true;
  let isMicOn = false;
  let isScreenSharing = false;
  let timeRemaining = 60 * 60; // 1 hour
  let timerInterval = null;

  // User mode and recording
  let isSpectator = false;
  let isRecording = false;
  let recordingId = null;
  let recordingUploadState = {
    isUploading: false,
    progress: 0,
    pendingPayloadString: null,
    pendingEndpoint: null,
    dbPath: null,
    hideTimeout: null
  };
  let userName = '';
  let userId = '';
  let conversationRoomId = null;
  let conversationSphereId = null;
  let conversationSlug = null;
  let firebaseRoomId = '';
  let conversationSessionId = null;
  let conversationPartnerId = null;
  let ensureSessionPromise = null;
  let conversationSessionStartedAt = null;
  let serverTimeOffset = 0;
  let timerRef = null;
  let timerSyncInitialized = false;
  let timerExpiredHandled = false;
  let timerState = {
    durationSeconds: 60 * 60,
    startedAt: null,
    expiresAt: null,
    createdBy: null
  };
  const conversationSessionEndState = {
    inFlight: false,
    ended: false
  };

  // Chat system
  let chatRef = null;
  let viewerCountRef = null;

  // Sparks data
  let currentSparks = [
    "If you could have a conversation with your future self from 10 years from now, what would you want to ask them about the choices you're making today?",
    "What's something you believed strongly about life when you were younger that you've completely changed your mind about now?",
    "If you had to choose one value to guide every major decision for the rest of your life, what would it be and why?"
  ];
  let currentSparkIndex = 0;
  let sparkIsSelected = false;

    const roomUrl = new URLSearchParams(window.location.search).get('room');
    const spectatorMode = new URLSearchParams(window.location.search).get('mode') === 'spectator';

    function extractRoomIdentifier(url) {
      if (!url) return null;

      try {
        var parsed = new URL(url);
        var pathname = parsed.pathname || '';
        var segments = pathname.split('/').filter(function(segment) {
          return segment && segment.trim().length > 0;
        });

        if (segments.length > 0) {
          return segments[segments.length - 1];
        }

        return pathname || url;
      } catch (error) {
        var sanitized = url.split('?')[0].split('#')[0];
        var fallbackSegments = sanitized.split('/').filter(function(segment) {
          return segment && segment.trim().length > 0;
        });

        if (fallbackSegments.length > 0) {
          return fallbackSegments[fallbackSegments.length - 1];
        }

        return sanitized || url;
      }
    }

  function isValidUuid(value) {
    return typeof value === 'string' && /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(value);
  }

  function getParticipantUserData(participant) {
    if (!participant) return null;
    // Daily can expose userData in different casings depending on SDK version
    return participant.userData || participant.user_data || null;
  }

  function getParticipantRole(participant) {
    const userData = getParticipantUserData(participant);
    if (userData && typeof userData.role === 'string') {
      return userData.role;
    }
    const fallbackName = participant?.user_name || '';
    return fallbackName.includes('Viewer_') ? 'spectator' : 'participant';
  }

  function getParticipantUserId(participant) {
    const userData = getParticipantUserData(participant);
    const candidateId = userData?.userId || userData?.user_id;
    return isValidUuid(candidateId) ? candidateId : null;
  }

  function getServerNow() {
    return Date.now() + serverTimeOffset;
  }

  function getRealtimeDatabaseRestUrl(baseUrl, path) {
    if (!baseUrl) {
      throw new Error('Realtime Database base URL is not configured');
    }
    const normalizedBase = baseUrl.replace(/\/$/, '');
    const normalizedPath = String(path || '').replace(/^\//, '');
    return `${normalizedBase}/${normalizedPath}.json`;
  }

  function buildRealtimeQueryUrl(baseUrl, path, params = {}) {
    const url = new URL(getRealtimeDatabaseRestUrl(baseUrl, path));
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    });
    return url.toString();
  }

  async function ensureConversationSessionStarted(contextLabel = 'default') {
    if (isSpectator) {
      console.log(`‚ÑπÔ∏è [${contextLabel}] Spectator detected - skipping session creation`);
      return null;
    }

    if (!supabaseClient) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase client unavailable - session lifecycle disabled`);
      return null;
    }

    if (!window.currentUserData?.isAuthenticated || !isValidUuid(userId)) {
      console.log(`‚ÑπÔ∏è [${contextLabel}] Anonymous or invalid user - skipping Supabase session tracking`);
      return null;
    }

    if (!conversationRoomId) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] No conversation room identifier - cannot start session`);
      return null;
    }

    if (conversationSessionId) {
      return conversationSessionId;
    }

    if (ensureSessionPromise) {
      return ensureSessionPromise;
    }

    ensureSessionPromise = (async () => {
      try {
        console.log(`ü™Ñ [${contextLabel}] Ensuring active conversation session for user ${userId}`);

        const { data: existingSession, error: existingError } = await supabaseClient
          .from('conversation_sessions')
          .select('id, started_at, sphere_id, partner_user_id')
          .eq('user_id', userId)
          .eq('room_id', conversationRoomId)
          .is('ended_at', null)
          .order('joined_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (existingError && existingError.code !== 'PGRST116') {
          throw existingError;
        }

        if (existingSession?.id) {
          conversationSessionId = existingSession.id;
          conversationSessionStartedAt = existingSession.started_at || conversationSessionStartedAt;
          if (!conversationSphereId && existingSession.sphere_id) {
            conversationSphereId = existingSession.sphere_id;
          }
          if (existingSession.partner_user_id && isValidUuid(existingSession.partner_user_id)) {
            conversationPartnerId = existingSession.partner_user_id;
          }
          console.log(`‚úÖ [${contextLabel}] Reusing active conversation session ${conversationSessionId}`);
          return conversationSessionId;
        }

        const payload = {
          p_room_id: conversationRoomId || roomUrl,
          p_user_id: userId,
          p_sphere_id: isValidUuid(conversationSphereId) ? conversationSphereId : null,
          p_partner_user_id: isValidUuid(conversationPartnerId) ? conversationPartnerId : null
        };

        const { data: sessionIdFromRpc, error: rpcError } = await supabaseClient.rpc('start_conversation_session', payload);

        if (rpcError) {
          throw rpcError;
        }

        if (sessionIdFromRpc) {
          conversationSessionId = typeof sessionIdFromRpc === 'string'
            ? sessionIdFromRpc
            : sessionIdFromRpc.id || null;
          conversationSessionStartedAt = new Date().toISOString();
          console.log(`‚úÖ [${contextLabel}] Started new conversation session ${conversationSessionId}`);
        } else {
          console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase RPC returned without session id`);
        }

        return conversationSessionId;
      } catch (error) {
        console.error(`‚ùå [${contextLabel}] Failed to ensure conversation session:`, error);
        return null;
      } finally {
        ensureSessionPromise = null;
      }
    })();

    return ensureSessionPromise;
  }

  async function updatePartnerUserId(partnerId, contextLabel = 'partner-link') {
    if (!isValidUuid(partnerId)) {
      return;
    }

    if (isSpectator) {
      return;
    }

    if (!supabaseClient) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase client unavailable - cannot link partner`);
      return;
    }

    await ensureConversationSessionStarted(contextLabel);

    if (!conversationSessionId) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Unable to link partner - session id missing`);
      return;
    }

    if (conversationPartnerId === partnerId) {
      return;
    }

    try {
      const { error } = await supabaseClient
        .from('conversation_sessions')
        .update({ partner_user_id: partnerId })
        .eq('id', conversationSessionId);

      if (error) {
        throw error;
      }

      conversationPartnerId = partnerId;
      console.log(`ü§ù [${contextLabel}] Linked partner ${partnerId} to session ${conversationSessionId}`);
    } catch (error) {
      console.error(`‚ùå [${contextLabel}] Failed to update partner user id:`, error);
    }
  }

  async function endConversationSession(reason) {
    if (isSpectator) {
      console.log('üëÄ Spectator - skipping session end (no charges)');
      conversationSessionEndState.ended = true;
      return;
    }

    if (conversationSessionEndState.ended || conversationSessionEndState.inFlight) {
      console.log('‚ö†Ô∏è Session already ended or ending in progress');
      return;
    }

    if (!supabaseClient) {
      console.error('‚ùå CRITICAL: Supabase client not initialized - minutes will NOT be charged!');
      conversationSessionEndState.ended = true;
      return;
    }

    if (!window.currentUserData?.isAuthenticated || !isValidUuid(userId)) {
      console.log('‚ÑπÔ∏è Skipping Supabase session end for anonymous or invalid user');
      conversationSessionEndState.ended = true;
      return;
    }

    const primaryRoomIdentifier = conversationRoomId;
    const base64RoomUrl = (() => {
      if (!roomUrl) return null;
      try {
        return btoa(roomUrl);
      } catch (encodeError) {
        console.debug('‚ÑπÔ∏è Unable to base64 encode room URL for session end candidates (non-blocking).', encodeError);
        return null;
      }
    })();

    console.log(`üíæ Ending conversation session - Reason: ${reason || 'unspecified'}`);
    console.log(`üë§ User ID: ${userId}`);
    console.log(`üè† Primary Room Identifier: ${primaryRoomIdentifier || 'none'}`);

    conversationSessionEndState.inFlight = true;

    try {
      let resolvedSessionId = conversationSessionId;
      if (!resolvedSessionId) {
        resolvedSessionId = await ensureConversationSessionStarted('end-session');
      }

      const candidateRoomIds = new Set(
        [primaryRoomIdentifier, roomUrl, firebaseRoomId, conversationSlug, base64RoomUrl]
          .filter((value) => typeof value === 'string' && value.length > 0)
      );

      const candidateSphereIds = new Set(
        [conversationSphereId].filter((value) => typeof value === 'string' && value.length > 0)
      );

      if (primaryRoomIdentifier && primaryRoomIdentifier.startsWith('sphere-')) {
        candidateSphereIds.add(primaryRoomIdentifier.replace(/^sphere-/, ''));
      }
      if (conversationSlug && conversationSlug.startsWith('sphere-')) {
        candidateSphereIds.add(conversationSlug.replace(/^sphere-/, ''));
      }

      let recentSessions = [];

      if (!resolvedSessionId) {
        const { data: sessionsData, error: sessionsError } = await supabaseClient
          .from('conversation_sessions')
          .select('id, room_id, sphere_id, status, ended_at, started_at')
          .eq('user_id', userId)
          .order('joined_at', { ascending: false })
          .limit(10);

        if (sessionsError) {
          console.error('‚ùå Supabase error retrieving sessions during cleanup:', sessionsError);
        } else if (Array.isArray(sessionsData)) {
          recentSessions = sessionsData;
          sessionsData.forEach((session) => {
            if (session?.room_id) {
              candidateRoomIds.add(session.room_id);
            }
            if (session?.sphere_id) {
              candidateSphereIds.add(session.sphere_id);
            }
          });

          const matchingSession = sessionsData.find((session) => {
            if (session?.ended_at || session?.status !== 'active') return false;
            const roomMatch = session?.room_id && candidateRoomIds.has(session.room_id);
            const sphereMatch = session?.sphere_id && candidateSphereIds.has(session.sphere_id);
            return roomMatch || sphereMatch;
          });

          if (matchingSession) {
            resolvedSessionId = matchingSession.id;
            conversationSessionId = matchingSession.id;
            conversationSessionStartedAt = matchingSession.started_at || conversationSessionStartedAt;
            console.log(`üîó Matched active session ${resolvedSessionId} using candidate identifiers`);
          }
        }
      } else {
        const { data: sessionRow, error: sessionRowError } = await supabaseClient
          .from('conversation_sessions')
          .select('room_id, sphere_id, started_at')
          .eq('id', resolvedSessionId)
          .maybeSingle();

        if (!sessionRowError && sessionRow) {
          if (sessionRow.room_id) {
            candidateRoomIds.add(sessionRow.room_id);
          }
          if (sessionRow.sphere_id) {
            candidateSphereIds.add(sessionRow.sphere_id);
          }
          if (sessionRow.started_at) {
            conversationSessionStartedAt = sessionRow.started_at;
          }
        }
      }

      console.log('üßÆ Candidate room identifiers:', Array.from(candidateRoomIds));
      console.log('üßÆ Candidate sphere identifiers:', Array.from(candidateSphereIds));

      if (resolvedSessionId) {
        const { data: rpcResult, error: rpcError } = await supabaseClient.rpc('end_conversation_session', {
          p_session_id: resolvedSessionId
        });

        if (rpcError) {
          const message = rpcError?.message || rpcError?.details || '';
          if (message.includes('status = \'active\'')) {
            console.warn('‚ö†Ô∏è Supabase indicates the session is already closed:', rpcError);
            conversationSessionEndState.ended = true;
            return;
          }
          throw rpcError;
        }

        console.log('‚úÖ SUCCESS: Session ended via RPC', rpcResult);
        console.log('üí∞ Minutes will be charged via database trigger');
        conversationSessionEndState.ended = true;
        return;
      }

      console.warn('‚ö†Ô∏è No active session id found (identifier mismatch or already completed).', {
        triedRoomIdentifiers: Array.from(candidateRoomIds),
        triedSphereIdentifiers: Array.from(candidateSphereIds),
        recentSessions
      });
      conversationSessionEndState.ended = true;
    } catch (err) {
      console.error('‚ùå FAILED to end conversation session:', err);
    } finally {
      conversationSessionEndState.inFlight = false;
    }
  }

    // CRITICAL: Comprehensive cleanup to ensure sessions always end
    let cleanupExecuted = false;

    async function executeComprehensiveCleanup(reason) {
      if (cleanupExecuted) {
        console.log('‚ö†Ô∏è Cleanup already executed, skipping');
        return;
      }
      
      cleanupExecuted = true;
      console.log(`üßπ Executing comprehensive cleanup - Reason: ${reason}`);
      
      // End conversation session (most important!)
      await endConversationSession(reason);
      
      // Clean up Firebase presence
      if (firebaseRoomId && userId) {
        try {
          await db.ref(`presence/${firebaseRoomId}/${userId}`).remove();
          console.log('‚úÖ Firebase presence cleaned up');
        } catch (error) {
          console.error('‚ùå Error cleaning Firebase presence:', error);
        }
      }
      
      // Leave Daily.co call
      if (call) {
        try {
          await call.leave();
          console.log('‚úÖ Daily.co call left');
        } catch (error) {
          console.error('‚ùå Error leaving Daily call:', error);
        }
      }
      
      console.log('‚úÖ Comprehensive cleanup complete');

      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }

      if (timerRef) {
        timerRef.off();
        timerRef = null;
      }
      timerSyncInitialized = false;
      timerExpiredHandled = false;
      timerState = {
        durationSeconds: 60 * 60,
        startedAt: null,
        expiresAt: null,
        createdBy: null
      };
    }

    // CRITICAL: Ensure cleanup on page unload
    window.addEventListener('beforeunload', (event) => {
      console.log('üö™ Page unloading - executing cleanup');

      if (!cleanupExecuted && !isSpectator && supabaseClient && isValidUuid(userId)) {
        if (conversationSessionId) {
          const rpcUrl = `${SUPABASE_URL}/rest/v1/rpc/end_conversation_session`;
          const rpcPayload = JSON.stringify({ p_session_id: conversationSessionId });

          try {
            const sent = navigator.sendBeacon(
              `${rpcUrl}?apikey=${encodeURIComponent(SUPABASE_ANON_KEY)}`,
              new Blob([rpcPayload], { type: 'application/json' })
            );
            if (sent) {
              console.log('‚úÖ Session end sent via sendBeacon (RPC)');
            } else {
              console.warn('‚ö†Ô∏è sendBeacon (RPC) did not confirm delivery');
            }
          } catch (error) {
            console.error('‚ùå sendBeacon (RPC) failed:', error);
          }

          fetch(rpcUrl, {
            method: 'POST',
            keepalive: true,
            headers: {
              'Content-Type': 'application/json',
              Accept: 'application/json',
              apikey: SUPABASE_ANON_KEY,
              Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
              Prefer: 'return=representation'
            },
            body: rpcPayload
          }).then(() => {
            console.log('‚úÖ Session end sent via fetch keepalive (RPC)');
          }).catch((error) => {
            console.error('‚ùå Fetch keepalive (RPC) failed:', error);
          });
        } else if (conversationRoomId) {
          console.warn('‚ö†Ô∏è No session id available during unload - fallback identifier cleanup may be incomplete');
        }
      }

      if (firebaseRoomId && userId) {
        db.ref(`presence/${firebaseRoomId}/${userId}`).remove().catch((error) => {
          console.error('‚ùå Error cleaning Firebase presence during unload:', error);
        });
      }

      if (recordingUploadState.pendingPayloadString && recordingUploadState.pendingEndpoint) {
        try {
          fetch(recordingUploadState.pendingEndpoint, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: recordingUploadState.pendingPayloadString,
            keepalive: true
          }).then(() => {
            console.log('‚úÖ Recording metadata persisted during unload');
          }).catch((error) => {
            console.error('‚ùå Recording metadata keepalive failed:', error);
          });
        } catch (error) {
          console.error('‚ùå Unable to persist recording metadata during unload:', error);
        }
      }
    });

    window.addEventListener('pagehide', () => {
      executeComprehensiveCleanup('pagehide');
    });

// Check if valid room URL
  if (!roomUrl) {
    document.body.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;background:linear-gradient(135deg,#F8F9FA 0%,#FCE2E5 100%);padding:2rem;font-family:'Nunito',sans-serif;">
        <div style="background:white;padding:2rem;border-radius:24px;box-shadow:0 8px 32px rgba(230,57,70,0.15);border:3px solid #FFB6B9;text-align:center;max-width:400px;">
          <div style="margin-bottom:1rem;">
            <svg viewBox="0 0 64 64" width="64" height="64" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="6"/>
              <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="6"/>
              <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
              <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
            </svg>
          </div>
          <div style="font-size:2rem;margin:1rem 0;">üòø</div>
          <h1 style="color:#e63946;font-weight:700;margin-bottom:0.5rem;font-size:1.3rem;">no sphere url provided</h1>
          <p style="color:#22223B;">please create a sphere first to start chatting</p>
        </div>
      </div>
    `;
    } else {
      conversationRoomId = extractRoomIdentifier(roomUrl);
      if (conversationRoomId) {
        console.log('üÜî Conversation session room identifier resolved:', conversationRoomId);
      } else {
        console.warn('‚ö†Ô∏è Unable to derive conversation room identifier from room URL.', { roomUrl: roomUrl });
      }

      // Get user data from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const usernameFromURL = urlParams.get('username');
      const userIdFromURL = urlParams.get('userId'); 
      const avatarFromURL = urlParams.get('avatar');
      const displayNameFromURL = urlParams.get('displayName');
      const sphereIdFromURL = urlParams.get('sphereId') || urlParams.get('sphere_id');
      const slugFromURL = urlParams.get('sphereSlug') || urlParams.get('slug');

      conversationSlug = slugFromURL || null;
      conversationSphereId = sphereIdFromURL || (conversationRoomId && conversationRoomId.startsWith('sphere-')
        ? conversationRoomId.replace(/^sphere-/, '')
        : null);

    // Set user mode
    isSpectator = spectatorMode;
    
    // Use real user data or fallback to generated names
    userName = usernameFromURL || (isSpectator ? `Viewer_${Math.random().toString(36).slice(2, 8)}` : `User_${Math.random().toString(36).slice(2, 8)}`);
    userId = userIdFromURL || `${isSpectator ? 'spectator' : 'participant'}_${Math.random().toString(36).slice(2)}_${Date.now()}`;
    
    // Store additional user data for UI display
    window.currentUserData = {
      username: usernameFromURL || userName,
      displayName: displayNameFromURL || usernameFromURL || userName,
      avatar: avatarFromURL || '',
      userId: userId,
      isAuthenticated: !!(usernameFromURL && userIdFromURL)
    };
    
    console.log(`üé≠ User Mode: ${isSpectator ? 'Spectator' : 'Participant'}`);
    console.log(`üë§ User Name: ${userName}`);
    console.log(`‚ú® Display Name: ${window.currentUserData.displayName}`);
    console.log(`üñºÔ∏è Avatar: ${window.currentUserData.avatar ? 'Yes' : 'None'}`);
    console.log(`üîê Authenticated: ${window.currentUserData.isAuthenticated ? 'Yes' : 'Guest'}`);
    
    // Update waiting overlay with personalized info
    if (isSpectator) {
      document.getElementById('waiting-mode').textContent = 'joining as spectator...';
    } else {
      // Show personalized welcome for authenticated users
      if (window.currentUserData.isAuthenticated) {
        document.getElementById('waiting-mode').textContent = `welcome ${window.currentUserData.displayName}!`;
      }
    }
    
    initializeVideoChat();
  }

  // Load room info
  async function loadRoomInfo() {
    const urlParam = decodeURIComponent(roomUrl);
    console.log("üîç Looking for room URL:", urlParam);

    try {
      const apiUrl = `https://x8ki-letl-twmt.n7.xano.io/api:6PAcsVDu/get-room-info?room_url=${encodeURIComponent(urlParam)}`;
      console.log("üåê API URL:", apiUrl);
      
      let response = await fetch(apiUrl);
      
      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log("üì¶ API Response:", data);
      
      if (data.topic) {
        const topic = data.topic.charAt(0).toUpperCase() + data.topic.slice(1);
        const description = data.description || `Discover and discuss fascinating aspects of ${data.topic.toLowerCase()}!`;
        
        console.log("‚úÖ Found topic:", topic);
        console.log("‚úÖ Found description:", description);
        console.log("üéØ Room type:", data.room_type);
        
        updateTopicDisplay(topic, description);
        return;
      } else {
        console.log("‚ùå API response missing topic:", data);
      }
      
    } catch (error) {
      console.error("‚ùå API Error:", error);
      console.log("üîÑ Using fallback topic because room not found or API error");
    }
    
    console.log("üîÑ Using fallback topic");
    updateTopicDisplay("General Chat", "Connect and have meaningful conversations!");
  }

  function updateTopicDisplay(topic, description) {
    const elements = [
      'topic-text', 'topic-description', 
      'topic-display', 'topic-desc-display'
    ];
    
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        if (id.includes('description') || id.includes('desc')) {
          element.innerText = description;
        } else {
          element.innerText = topic;
        }
      }
    });
    
    console.log("‚úÖ Updated topic:", topic);
    console.log("‚úÖ Updated description:", description);
  }

  async function initializeVideoChat() {
    await loadRoomInfo();
    
    // Set up Firebase for chat and presence
    firebaseRoomId = btoa(roomUrl);
    const roomId = firebaseRoomId;
    chatRef = db.ref(`chats/${roomId}`);
    viewerCountRef = db.ref(`viewers/${roomId}`);
    
    // Set up user role display
    setupUserRoleDisplay();
    
    // Set up layout based on user type
    if (isSpectator) {
      setupSpectatorMode();
    } else {
      setupParticipantMode();
    }

    try {
      await initializeTimerSync();
    } catch (error) {
      console.error('‚ùå Failed to initialize timer synchronization:', error);
    }
    
    // Create Daily call object
    call = Daily.createCallObject({
      audioSource: !isSpectator,  // Spectators don't need audio
      videoSource: !isSpectator   // Spectators don't need video
    });
    
    // Set up event listeners
    call.on('joined-meeting', handleJoinedMeeting);
    call.on('participant-joined', handleParticipantJoined);
    call.on('participant-left', handleParticipantLeft);
    call.on('participant-updated', handleParticipantUpdated);
      call.on('track-started', handleTrackStarted);
      call.on('track-stopped', handleTrackStopped);
      call.on('app-message', handleAppMessage);
      call.on('error', handleError);
      call.on('camera-error', handleCameraError);
      call.on('recording-started', handleRecordingStarted);
      call.on('recording-stopped', handleRecordingStopped);
      call.on('recording-upload-progress', handleRecordingUploadProgress);
      call.on('recording-upload-completed', handleRecordingUploadCompleted);
      call.on('recording-error', handleRecordingError);
      call.on('left-meeting', handleLeftMeeting);

    try {
      // Join the call
      await call.join({ 
        url: roomUrl,
        userName: userName,
        userData: {
          role: isSpectator ? 'spectator' : 'participant',
          userId: window.currentUserData?.isAuthenticated && isValidUuid(userId) ? userId : null,
          displayName: window.currentUserData?.displayName || userName,
          avatar: window.currentUserData?.avatar || null,
          sphereId: isValidUuid(conversationSphereId) ? conversationSphereId : null,
          slug: conversationSlug || null,
          roomId: conversationRoomId || null
        }
      });
      
      // Set up Firebase presence
      await setupPresence(roomId);
      
      // Set up chat listeners
      setupChatListeners();

    } catch (error) {
      console.error('Failed to join call:', error);
      showToast('Failed to join the video call. Please try refreshing the page.');
    }
  }

  function setupUserRoleDisplay() {
    const roleBadge = document.getElementById('user-role-badge');
    const roleText = document.getElementById('role-text');
    
    if (isSpectator) {
      roleBadge.classList.add('spectator-badge');
      roleText.textContent = 'spectator';
    } else {
      roleBadge.classList.add('participant-badge');
      roleText.textContent = 'participant';
    }
    
    roleBadge.classList.remove('hidden');
  }

  function setupSpectatorMode() {
    // Hide participant layout, show spectator layout
    document.getElementById('participant-layout').style.display = 'none';
    document.getElementById('spectator-layout').classList.remove('hidden');
    
    // Set up live indicator
    document.getElementById('live-indicator').classList.remove('hidden');
    
    console.log('üëÄ Spectator mode enabled');
  }

  function setupParticipantMode() {
    // Keep participant layout visible
    console.log('üé§ Participant mode enabled');
  }

  async function setupPresence(roomId) {
    const presenceRef = db.ref(`presence/${roomId}/${userId}`);
    
    // Set user online
    await presenceRef.set({
      name: userName,
      type: isSpectator ? 'spectator' : 'participant',
      joinedAt: firebase.database.ServerValue.TIMESTAMP
    });
    
    // Listen for viewer count changes
    const allPresenceRef = db.ref(`presence/${roomId}`);
    allPresenceRef.on('value', (snapshot) => {
      const users = snapshot.val() || {};
      const spectators = Object.values(users).filter(user => user.type === 'spectator');
      const participants = Object.values(users).filter(user => user.type === 'participant');
      
      updateViewerCount(spectators.length);
      
      console.log(`üë• Room stats: ${participants.length} participants, ${spectators.length} spectators`);
    });
    
    // Clean up presence on disconnect
    presenceRef.onDisconnect().remove();
  }

  async function initializeTimerSync() {
    if (timerSyncInitialized || !firebaseRoomId) {
      return;
    }

    timerSyncInitialized = true;
    timerRef = db.ref(`timers/${firebaseRoomId}`);

    timerRef.on('value', (snapshot) => {
      const value = snapshot.val();
      if (value && typeof value.startedAt === 'number' && typeof value.durationSeconds === 'number') {
        timerState.startedAt = value.startedAt;
        timerState.durationSeconds = value.durationSeconds;
        timerState.expiresAt = value.startedAt + value.durationSeconds * 1000;
        timerState.createdBy = value.createdBy || null;
        timerExpiredHandled = timerState.expiresAt <= getServerNow();
      } else {
        timerState.startedAt = null;
        timerState.expiresAt = null;
        timerState.createdBy = null;
      }
      updateTimer();
    });

    if (!isSpectator) {
      const serverNow = getServerNow();
      await new Promise((resolve) => {
        timerRef.transaction((current) => {
          if (current && typeof current.startedAt === 'number' && typeof current.durationSeconds === 'number') {
            const expiresAt = current.startedAt + current.durationSeconds * 1000;
            if (expiresAt > serverNow + 1000) {
              return current;
            }
          }
          console.log('‚è±Ô∏è Starting new shared timer for this room');
          return {
            startedAt: firebase.database.ServerValue.TIMESTAMP,
            durationSeconds: 60 * 60,
            createdBy: userId,
            createdAt: firebase.database.ServerValue.TIMESTAMP
          };
        }, (error, committed, snapshot) => {
          if (error) {
            console.error('‚ùå Timer synchronization error:', error);
          } else if (committed) {
            console.log('‚úÖ Timer synchronized for room');
          } else {
            console.log('‚ÑπÔ∏è Timer already active, using existing value');
          }
          resolve();
        });
      });
    }
  }

  function updateViewerCount(count) {
    const viewerCountElements = [
      document.getElementById('viewer-count'),
      document.getElementById('chat-viewer-count'),
      document.getElementById('participant-chat-viewer-count')
    ];
    
    viewerCountElements.forEach(el => {
      if (el) el.textContent = count;
    });
    
    // Update participant view when spectators are present
    if (!isSpectator) {
      updateParticipantViewForSpectators(count);
    }
  }

  function updateParticipantViewForSpectators(spectatorCount) {
    const remotePlaceholder = document.getElementById('remote-placeholder');
    const remoteVideo = document.getElementById('remote-video');
    
    // Only update if no remote video is showing (no other participants)
    if (remotePlaceholder && remoteVideo && remoteVideo.style.display !== 'block') {
      // Check if there are any other participants (not spectators)
      const participants = call ? call.participants() : {};
      const otherParticipants = Object.values(participants).filter(p => !p.local);
      
      // Only show spectator message if there are NO other participants
      if (otherParticipants.length === 0) {
        const placeholder = remotePlaceholder.querySelector('.text-center.text-white.relative.z-10');
        
        if (placeholder) {
          const icon = placeholder.querySelector('.w-16.h-16');
          const title = placeholder.querySelector('.font-bold.text-lg.text-white');
          const subtitle = placeholder.querySelector('.text-sm.text-gold.mt-1');
          
          if (spectatorCount > 0) {
            // Show that spectators are watching
            if (icon) {
              icon.innerHTML = `
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                  <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                </svg>
              `;
            }
            
            if (title) {
              title.textContent = spectatorCount === 1 
                ? `${spectatorCount} viewer is watching!` 
                : `${spectatorCount} viewers are watching!`;
            }
            
            if (subtitle) {
              subtitle.innerHTML = `üé≠ They're here for the conversation! <br>üé§ Waiting for another participant to join...`;
            }
          } else {
            // Reset to original state when no spectators
            if (icon) {
              icon.innerHTML = `
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              `;
            }
            
            if (title) {
              title.textContent = "Waiting for your chat partner...";
            }
            
            if (subtitle) {
              subtitle.innerHTML = "üê± They might be as curious as a cat about this topic!";
            }
          }
        }
      }
      // If there ARE other participants, don't change anything - let their video show
    }
  }

  function setupChatListeners() {
    // Listen for new chat messages
    chatRef.orderByChild('timestamp').limitToLast(50).on('child_added', (snapshot) => {
      const message = snapshot.val();
      if (message) {
        displayChatMessage(message);
      }
    });
    
    // Set up chat input for spectators
    const chatInput = document.getElementById('chat-input');
    const charCount = document.getElementById('char-count');
    
    if (chatInput && charCount) {
      chatInput.addEventListener('input', () => {
        charCount.textContent = chatInput.value.length;
      });
      
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendChatMessage();
        }
      });
    }

    // Set up chat input for participants
    const participantChatInput = document.getElementById('participant-chat-input');
    const participantCharCount = document.getElementById('participant-char-count');
    
    if (participantChatInput && participantCharCount) {
      participantChatInput.addEventListener('input', () => {
        participantCharCount.textContent = participantChatInput.value.length;
      });
      
      participantChatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendParticipantChatMessage();
        }
      });
    }
  }

  function displayChatMessage(message) {
    // Display in both spectator and participant chat areas
    const chatContainers = [
      document.getElementById('live-chat-messages'), // Spectator chat
      document.getElementById('participant-chat-messages') // Participant chat
    ].filter(container => container); // Remove null containers
    
    chatContainers.forEach(chatContainer => {
      const messageEl = document.createElement('div');
      messageEl.className = 'chat-message p-3 rounded-lg border';
      
      // Style based on user type
      if (message.userType === 'participant') {
        messageEl.classList.add('bg-light-rose', 'border-rose');
      } else {
        messageEl.classList.add('bg-gray-50', 'dark:bg-gray-700', 'border-gray-200', 'dark:border-gray-600');
      }
      
      const timestamp = new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      messageEl.innerHTML = `
        <div class="flex items-start space-x-2">
          <div class="flex-shrink-0">
            <div class="w-6 h-6 rounded-full ${message.userType === 'participant' ? 'bg-main-red' : 'bg-gold'} flex items-center justify-center text-white text-xs font-bold">
              ${message.userName.charAt(0).toUpperCase()}
            </div>
          </div>
          <div class="flex-1 min-w-0">
            <div class="flex items-center space-x-2 mb-1">
              <span class="font-semibold text-charcoal dark:text-white text-sm">${message.userName}</span>
              <span class="text-xs text-gray-500">${timestamp}</span>
              ${message.userType === 'participant' ? '<span class="text-xs bg-main-red text-white px-1 rounded">HOST</span>' : ''}
            </div>
            <p class="text-charcoal dark:text-white text-sm break-words">${message.text}</p>
          </div>
        </div>
      `;
      
      chatContainer.appendChild(messageEl);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    });
  }

  function sendChatMessage() {
    const chatInput = document.getElementById('chat-input');
    if (!chatInput || !chatRef) return;
    
    const text = chatInput.value.trim();
    if (!text) return;
    
    // Get current user display info for better chat experience
    const userDisplayInfo = getCurrentUserDisplayInfo();
    
    const message = {
      userId: userId,
      userName: userDisplayInfo.displayName, // Use display name instead of raw userName
      userType: isSpectator ? 'spectator' : 'participant',
      text: text,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    };
    
    chatRef.push(message);
    chatInput.value = '';
    document.getElementById('char-count').textContent = '0';
  }

  function sendParticipantChatMessage() {
    const chatInput = document.getElementById('participant-chat-input');
    if (!chatInput || !chatRef) return;
    
    const text = chatInput.value.trim();
    if (!text) return;
    
    // Get current user display info for better chat experience
    const userDisplayInfo = getCurrentUserDisplayInfo();
    
    const message = {
      userId: userId,
      userName: userDisplayInfo.displayName, // Use display name instead of raw userName
      userType: isSpectator ? 'spectator' : 'participant',
      text: text,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    };
    
    chatRef.push(message);
    chatInput.value = '';
    document.getElementById('participant-char-count').textContent = '0';
  }

  async function handleJoinedMeeting(event) {
    console.log('‚úÖ Joined meeting successfully');
    
    if (!isSpectator) {
      // Update mic/camera states for participants
      isMicOn = call.localAudio();
      isCameraOn = call.localVideo();
      
      const micBtn = document.getElementById('mic-btn');
      const cameraBtn = document.getElementById('camera-btn');
      
      if (isMicOn) {
        micBtn.classList.remove('active');
      } else {
        micBtn.classList.add('active');
      }
      
      if (isCameraOn) {
        cameraBtn.classList.remove('active');
      } else {
        cameraBtn.classList.add('active');
      }
      
      setupLocalVideo();
      
      if (isMicOn) {
        startAudioLevelMonitoring();
      }
      
      requestPermissionsAndSetupDevices();
      initializeSparks();

      try {
        await ensureConversationSessionStarted('joined-meeting');
      } catch (error) {
        console.error('‚ùå Failed to ensure Supabase session on join:', error);
      }
      
      // For participants, also set up existing participants after joining (for refresh case)
      setTimeout(setupExistingParticipantsForParticipant, 1000);
    } else {
      // For spectators, set up existing participants after joining - but wait longer for better user experience
      setTimeout(setupExistingParticipants, 3000);
    }
    
    // Hide waiting overlay and show video interface
    document.getElementById('waiting-overlay').style.display = 'none';
    document.getElementById('video-interface').classList.remove('hidden');
    
    startTimer();
    showToast(isSpectator ? 'üëÄ Welcome to the live chat!' : 'üéâ Welcome to your ChatSpheres room!');
  }

  function handleLeftMeeting() {
    console.log('üëã Local participant left the meeting');
    executeComprehensiveCleanup('left-meeting');
  }

  async function handleParticipantJoined(event) {
    const participantName = event.participant.user_name || 'Guest';
    const participantData = getParticipantUserData(event.participant);
    const participantDisplayName = participantData?.displayName || participantName;
    const participantRole = getParticipantRole(event.participant);
    const isSpectatorParticipant = participantRole === 'spectator';
    
    console.log('üëã Participant joined:', participantDisplayName, isSpectatorParticipant ? '(spectator)' : '(participant)');
    
    if (!isSpectator) {
      if (!isSpectatorParticipant) {
        const remoteUserId = getParticipantUserId(event.participant);
        if (remoteUserId) {
          try {
            await updatePartnerUserId(remoteUserId, 'participant-joined');
          } catch (error) {
            console.error('‚ùå Failed to link partner on join:', error);
          }
        }
        updateRemoteInfo(participantDisplayName);
        showToast(`üëã ${participantDisplayName} joined the call!`);
      } else {
        console.log('üîí Ignoring spectator join event to prevent participant disruption');
      }
    } else {
      updateSpectatorParticipants();
    }
  }

  function handleParticipantLeft(event) {
    const participantName = event.participant.user_name || 'Guest';
    const participantData = getParticipantUserData(event.participant);
    const participantDisplayName = participantData?.displayName || participantName;
    const participantRole = getParticipantRole(event.participant);
    const isSpectatorParticipant = participantRole === 'spectator';
    
    console.log('üëã Participant left:', participantDisplayName, isSpectatorParticipant ? '(spectator)' : '(participant)');
    
    if (!isSpectator) {
      if (!isSpectatorParticipant) {
        hideRemoteVideo();
        showToast(`üëã ${participantDisplayName} left the call`);
      } else {
        console.log('üîí Ignoring spectator leave event to prevent participant disruption');
      }
    } else {
      const participantId = event.participant.session_id;
      removeSpectatorParticipant(participantId);
      updateSpectatorParticipants();
      showToast(`üëã ${participantDisplayName} left the conversation`);
    }
  }

  function handleParticipantUpdated(event) {
    // Only log when there are meaningful changes, not constant updates
    const participantId = event.participant.session_id;
    const isLocalParticipant = event.participant.local;
    const participantRole = getParticipantRole(event.participant);
    
    // Skip logging and processing for local participant updates
    if (isLocalParticipant) return;

    if (participantRole === 'spectator') {
      console.log('üîí Ignoring spectator participant update to prevent disruption');
      return;
    }
    
    console.log(`üîÑ Remote participant updated: ${event.participant.user_name || participantId.slice(0,8)}`);
    
    const tracks = event.participant.tracks;
    
    // For non-local participants only
    if (tracks) {
      if (tracks.video && tracks.video.persistentTrack) {
        if (isSpectator) {
          setupSpectatorVideo(tracks.video.persistentTrack, participantId);
        } else {
          // For participants: NEVER overwrite existing video connections from spectator events
          const remoteVideo = document.getElementById('remote-video');
          const hasActiveRemoteVideo = remoteVideo && remoteVideo.srcObject && remoteVideo.style.display === 'block';
          
          // Only set up if we truly don't have a remote connection
          if (!hasActiveRemoteVideo) {
            console.log('‚úÖ Setting up remote video for participant');
            setupRemoteVideo(tracks.video.persistentTrack);
            updateRemoteInfo(event.participant.user_name || 'Guest');
          } else {
            console.log('üîí Remote video already active, ignoring update to prevent disruption');
          }
        }
      }
      if (tracks.screenVideo && tracks.screenVideo.persistentTrack) {
        if (isSpectator) {
          setupSpectatorScreenShare(tracks.screenVideo.persistentTrack);
        } else {
          setupScreenShareVideo(tracks.screenVideo.persistentTrack);
        }
      }
    }
  }

  function handleTrackStarted(event) {
    console.log('üé• Track started:', event);
    console.log('üé• Track details:', {
      kind: event.track.kind,
      label: event.track.label,
      participantLocal: event.participant.local,
      participantId: event.participant.session_id,
      isSpectator: isSpectator
    });

    if (!event.participant.local && getParticipantRole(event.participant) === 'spectator') {
      console.log('üîí Ignoring spectator track start to protect participant streams');
      return;
    }
    
    if (event.participant.local && !isSpectator) {
      if (event.track.kind === 'video') {
        setupLocalVideo(event.track);
      }
    } else {
      // Handle remote participant tracks
      const participantId = event.participant.session_id;
      
      if (event.track.kind === 'video') {
        if (event.track.label && (event.track.label.includes('screen') || event.track.label.includes('Screen') || event.track.label.includes('display') || event.track.label.includes('Display') || event.track.label.includes('web-contents-media-stream'))) {
          console.log('üì∫ Setting up screen share for participant:', participantId);
          if (isSpectator) {
            setupSpectatorScreenShare(event.track);
          } else {
            setupScreenShareVideo(event.track);
          }
        } else {
          console.log('üé• Setting up regular video for participant:', participantId);
          if (isSpectator) {
            setupSpectatorVideo(event.track, participantId);
          } else {
            // IMPROVED: Always set up remote video when camera turns back on
            console.log('üîÑ Setting up remote video (camera turned back on)');
            setupRemoteVideo(event.track);
            updateRemoteInfo(event.participant.user_name || 'Guest');
            
            // Hide the camera-off placeholder and show video
            const remoteVideo = document.getElementById('remote-video');
            const placeholder = document.getElementById('remote-placeholder');
            if (remoteVideo && placeholder) {
              remoteVideo.style.display = 'block';
              placeholder.style.display = 'none';
            }
          }
        }
      } else if (event.track.kind === 'audio') {
        setupRemoteAudio(event.track);
      }
    }
  }

  function handleTrackStopped(event) {
    console.log('üõë Track stopped:', event);
    console.log('üõë Track details:', {
      kind: event.track.kind,
      label: event.track.label,
      participantLocal: event.participant.local,
      participantName: event.participant.user_name,
      isSpectator: isSpectator
    });

    if (!event.participant.local && getParticipantRole(event.participant) === 'spectator') {
      console.log('üîí Ignoring spectator track stop to protect participant streams');
      return;
    }
    
    // Handle LOCAL participant tracks (when they stop their own camera/screen)
    if (event.participant.local && event.track.kind === 'video') {
      console.log('üîÑ Local participant stopped their own video track');
      
      // Check if it's the local user's screen share stopping
      const isLocalScreenShare = event.track.label && (
        event.track.label.includes('screen') || 
        event.track.label.includes('Screen') ||
        event.track.label.includes('display') ||
        event.track.label.includes('Display') ||
        event.track.label.includes('web-contents-media-stream')
      );
      
      if (isLocalScreenShare) {
        console.log('üì∫ Local screen share stopped');
        isScreenSharing = false;
        const screenShareBtn = document.getElementById('screen-share-btn');
        if (screenShareBtn) {
          screenShareBtn.classList.remove('active');
        }
        
        // CRITICAL: Restore local video display and remove screen-sharing class
        const localVideo = document.getElementById('local-video');
        const localPlaceholder = document.getElementById('local-placeholder');
        if (localVideo && localPlaceholder) {
          // Remove screen-sharing class to restore mirror effect
          localVideo.classList.remove('screen-sharing');
          console.log('üìπ Restored mirror transform for local video after screen share stopped');
          
          if (isCameraOn) {
            localVideo.style.display = 'block';
            localPlaceholder.style.display = 'none';
          } else {
            localVideo.style.display = 'none';
            localPlaceholder.style.display = 'flex';
          }
        }
      }
      return; // Don't process further for local tracks
    }
    
    // Handle REMOTE participant tracks only
    if (!event.participant.local && event.track.kind === 'video') {
      const participantId = event.participant.session_id;
      const participantName = event.participant.user_name || 'Participant';
      
      console.log(`üé• Remote video track stopped for: ${participantName} (${participantId})`);
      
      // IMPROVED: Better screen share detection
      const screenShareVideo = document.getElementById('screen-share-video');
      const spectatorScreenShare = document.getElementById('spectator-screen-share');
      
      const isCurrentlyScreenSharing = isSpectator ? 
        (spectatorScreenShare && !spectatorScreenShare.classList.contains('hidden')) :
        (screenShareVideo && screenShareVideo.style.display === 'block');
      
      // Enhanced screen share detection - check label OR if we're currently showing screen share
      const isScreenShareTrack = isCurrentlyScreenSharing || (event.track.label && (
        event.track.label.includes('screen') || 
        event.track.label.includes('Screen') ||
        event.track.label.includes('display') ||
        event.track.label.includes('Display') ||
        event.track.label.includes('web-contents-media-stream')
      ));
      
      if (isScreenShareTrack) {
        console.log('üì∫ Remote screen share track stopped - restoring camera feed');
        if (isSpectator) {
          hideSpectatorScreenShare();
        } else {
          hideScreenShareVideo();
          // CRITICAL: Restore the camera feed after screen share stops
          restoreParticipantCameraFeed();
        }
      } else {
        console.log(`üì∑ ${participantName} turned off their camera - showing placeholder`);
        
        if (!isSpectator) {
          // Show placeholder but keep participant info
          const remoteVideo = document.getElementById('remote-video');
          const placeholder = document.getElementById('remote-placeholder');
          if (remoteVideo && placeholder) {
            remoteVideo.style.display = 'none';
            placeholder.style.display = 'flex';
            // Update placeholder to show it's just camera off, not disconnected
            updateRemotePlaceholderForCameraOff(event.participant);
          }
        } else {
          // CRITICAL FIX: For spectators, show proper camera-off placeholder AND force overlay
          console.log(`üé≠ SPECTATOR: Showing camera-off placeholder for ${participantName}`);
          updateSpectatorPlaceholderForCameraOff(participantId, event.participant);
          
          // CRITICAL: Force overlay to show when camera turns off
          setTimeout(() => {
            forceSpectatorOverlayVisible('camera-off');
          }, 100);
        }
      }
    }
  }
  
  // CRITICAL: New function to force overlay visibility when cameras turn off
  function forceSpectatorOverlayVisible(reason = 'general') {
    if (!isSpectator) return;
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    if (!clickOverlay) return;
    
    console.log(`üé≠ FORCING OVERLAY VISIBLE - Reason: ${reason}`);
    
    // Force overlay to be visible with maximum priority
    clickOverlay.classList.add('spectator-overlay-force-visible');
    clickOverlay.style.setProperty('display', 'flex', 'important');
    clickOverlay.style.setProperty('opacity', '1', 'important');
    clickOverlay.style.setProperty('visibility', 'visible', 'important');
    clickOverlay.style.setProperty('pointer-events', 'auto', 'important');
    clickOverlay.style.setProperty('z-index', '9999', 'important');
    clickOverlay.classList.remove('hidden');
    
    // Update overlay content based on reason
    const overlayText = clickOverlay.querySelector('.text-center.text-white');
    if (overlayText) {
      const participantCount = (spectatorParticipant1 ? 1 : 0) + (spectatorParticipant2 ? 1 : 0);
      
      if (reason === 'camera-off' && participantCount > 0) {
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path d="M4 6a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM6 8a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1z"/>
              <path d="M2.5 8.5l2-2 2 2M15.5 11.5l-2 2-2-2"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üì∑ Camera Turned Off</p>
          <p class="text-lg text-gold mt-2">${participantCount} participant${participantCount > 1 ? 's' : ''} present, camera disabled</p>
          <div class="mt-6 px-8 py-4 bg-yellow-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK TO WATCH WHEN CAMERA TURNS ON
          </div>
        `;
      } else {
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
          <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
          <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
            üëÜ Click Here to Enable Video
          </div>
        `;
      }
    }
    
    console.log('‚úÖ OVERLAY NOW FORCIBLY VISIBLE FOR SPECTATOR');
  }
  
  // CRITICAL: Restore camera feed after screen share stops
  function restoreParticipantCameraFeed() {
    console.log('üîÑ Restoring participant camera feed after screen share');
    
    // Get the current participant's camera track
    const participants = call.participants();
    const remoteParticipants = Object.values(participants).filter(p => !p.local);
    
    remoteParticipants.forEach(participant => {
      if (participant.tracks && participant.tracks.video && participant.tracks.video.persistentTrack) {
        const cameraTrack = participant.tracks.video.persistentTrack;
        // Only restore if it's not a screen share track
        if (!cameraTrack.label.includes('screen') && !cameraTrack.label.includes('web-contents-media-stream')) {
          console.log('‚úÖ Restoring camera track for participant:', participant.user_name);
          setupRemoteVideo(cameraTrack);
        }
      }
    });
  }

  function handleAppMessage(event) {
    console.log('üì® App message received:', event);
    
    if (event.data.type === 'spark-selected') {
      currentSparkIndex = event.data.sparkIndex;
      sparkIsSelected = event.data.isSelected;
      updateSparkDisplay();
      if (sparkIsSelected) {
        const currentSparkEl = document.getElementById('currentSpark');
        currentSparkEl.classList.add('ring-4', 'ring-gold');
        currentSparkEl.style.background = 'linear-gradient(135deg, #FFD166 0%, #FFB6B9 100%)';
      }
    } else if (event.data.type === 'sparks-updated') {
      console.log("üì® Receiving updated sparks from other participant");
      currentSparks = event.data.sparks;
      currentSparkIndex = 0;
      updateSparkDisplay();
      showToast(`‚ú® Partner generated new sparks for "${event.data.topic}"!`);
    }
  }

  function handleError(event) {
    console.error('‚ùå Daily.co error:', event);
    showToast('Video call error: ' + event.errorMsg);
  }

  function handleCameraError(event) {
    console.error('üé•‚ùå Camera/Microphone error:', event);
    
    const { error } = event;
    
    switch (error.type) {
      case 'permissions':
        if (error.blockedMedia.includes('audio')) {
          console.error('üé§‚ùå Microphone permissions denied!');
          showToast('‚ùå Microphone access denied. Please allow microphone access and reload.');
        }
        if (error.blockedMedia.includes('video')) {
          console.error('üìπ‚ùå Camera permissions denied!');
          showToast('‚ùå Camera access denied. Please allow camera access and reload.');
        }
        break;
        
      case 'cam-in-use':
      case 'mic-in-use':
      case 'cam-mic-in-use':
        console.error('üîí Device in use by another application');
        showToast('‚ùå Camera or microphone is being used by another app. Please close other apps and try again.');
        break;
        
      case 'not-found':
        if (error.missingMedia.includes('audio')) {
          console.error('üé§‚ùå No microphone found!');
          showToast('‚ùå No microphone detected. Please check your device.');
        }
        if (error.missingMedia.includes('video')) {
          console.error('üìπ‚ùå No camera found!');
          showToast('‚ùå No camera detected. Please check your device.');
        }
        break;
        
      default:
        console.error('‚ùå Unknown camera error:', error);
        showToast('‚ùå Device error: ' + error.msg);
    }
  }

  function updateRecordingStatusIndicator(mode, progress = 0) {
    const statusEl = document.getElementById('recording-status');
    const uploadStatusEl = document.getElementById('recording-upload-status');
    const uploadPercentEl = document.getElementById('recording-upload-percent');
    const uploadBarEl = document.getElementById('recording-upload-bar');
    const uploadFillEl = document.getElementById('recording-upload-bar-fill');
    const modeLabelEl = document.getElementById('recording-mode-label');
    const recordingDotEl = statusEl ? statusEl.querySelector('.recording-dot') : null;

    if (!statusEl || !uploadStatusEl || !uploadPercentEl || !uploadBarEl || !uploadFillEl || !modeLabelEl || !recordingDotEl) {
      return;
    }

    if (mode === 'recording') {
      statusEl.classList.remove('hidden');
      statusEl.classList.add('recording-indicator');
      uploadStatusEl.classList.add('hidden');
      uploadBarEl.classList.add('hidden');
      uploadFillEl.style.width = '0%';
      uploadPercentEl.textContent = '0%';
      recordingDotEl.classList.remove('opacity-75');
    } else if (mode === 'uploading') {
      statusEl.classList.remove('hidden');
      statusEl.classList.remove('recording-indicator');
      uploadStatusEl.classList.remove('hidden');
      uploadBarEl.classList.remove('hidden');
      const boundedProgress = Math.max(0, Math.min(100, Math.round(progress || 0)));
      uploadPercentEl.textContent = `${boundedProgress}%`;
      uploadFillEl.style.width = `${boundedProgress}%`;
      recordingDotEl.classList.add('opacity-75');
    } else {
      statusEl.classList.add('hidden');
      statusEl.classList.remove('recording-indicator');
      uploadStatusEl.classList.add('hidden');
      uploadBarEl.classList.add('hidden');
      uploadFillEl.style.width = '0%';
      recordingDotEl.classList.remove('opacity-75');
    }
  }

  function resetRecordingUploadState() {
    recordingUploadState.isUploading = false;
    recordingUploadState.progress = 0;
    recordingUploadState.pendingPayloadString = null;
    recordingUploadState.pendingEndpoint = null;
    recordingUploadState.dbPath = null;
    if (recordingUploadState.hideTimeout) {
      clearTimeout(recordingUploadState.hideTimeout);
      recordingUploadState.hideTimeout = null;
    }
  }

  function finalizeRecordingUpload(source = 'unknown') {
    console.log(`‚úÖ Recording upload finalized via ${source}`);
    recordingUploadState.isUploading = false;
    recordingUploadState.progress = 100;
    if (recordingUploadState.hideTimeout) {
      clearTimeout(recordingUploadState.hideTimeout);
    }
    recordingUploadState.hideTimeout = setTimeout(() => {
      updateRecordingStatusIndicator('idle');
      resetRecordingUploadState();
    }, 1500);
  }

  async function markRecordingUploadCompleteInDatabase() {
    if (!recordingUploadState.dbPath) {
      return;
    }
    try {
      await db.ref(recordingUploadState.dbPath).update({
        status: 'uploaded',
        uploadProgress: 100,
        uploadCompletedAt: firebase.database.ServerValue.TIMESTAMP
      });
    } catch (error) {
      console.error('‚ùå Failed to mark recording as uploaded:', error);
    }
  }

  // Recording event handlers
  function handleRecordingStarted(event) {
    console.log('üé• Recording started:', event);
    isRecording = true;
    recordingId = event.recordingId;
    
    resetRecordingUploadState();
    updateRecordingStatusIndicator('recording');
    
    // Update record button
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.add('active');
    }
    
    showToast('üé¨ Recording started!');
  }

  async function handleRecordingStopped(event) {
    console.log('üõë Recording stopped:', event);
    isRecording = false;
    recordingId = event.recordingId || recordingId;
    
    recordingUploadState.isUploading = true;
    recordingUploadState.progress = 0;
    updateRecordingStatusIndicator('uploading', 0);
    if (roomUrl && recordingId && firebaseConfig?.databaseURL) {
      const prospectiveRoomId = btoa(roomUrl);
      const prospectivePath = `recordings/${prospectiveRoomId}/${recordingId}`;
      recordingUploadState.dbPath = prospectivePath;
      try {
        recordingUploadState.pendingEndpoint = getRealtimeDatabaseRestUrl(firebaseConfig.databaseURL, prospectivePath);
      } catch (endpointError) {
        console.warn('‚ö†Ô∏è Unable to precompute recording endpoint:', endpointError);
      }
    }
    
    // Update record button
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.remove('active');
    }
    
    // Save recording metadata to Firebase
    if (recordingId) {
      try {
        await saveRecordingMetadata(event);
        showToast('üé¨ Recording stopped. Uploading in background...');
      } catch (error) {
        console.error('‚ùå Failed to persist recording metadata:', error);
        showToast('‚ùå Failed to save recording data');
        updateRecordingStatusIndicator('idle');
        recordingUploadState.isUploading = false;
      }
    } else {
      console.warn('‚ö†Ô∏è Recording stopped without an ID. Skipping metadata save.');
      updateRecordingStatusIndicator('idle');
      recordingUploadState.isUploading = false;
    }
  }

  function handleRecordingUploadProgress(event) {
    const percentValue = typeof event?.percent === 'number'
      ? event.percent
      : (typeof event?.progress === 'number' ? event.progress : 0);
    const percent = Math.max(0, Math.min(100, Math.round(percentValue)));
    
    recordingUploadState.isUploading = true;
    recordingUploadState.progress = percent;
    updateRecordingStatusIndicator('uploading', percent);
    
    if (percent >= 100) {
      markRecordingUploadCompleteInDatabase();
      finalizeRecordingUpload('progress-event');
    }
  }

  async function handleRecordingUploadCompleted(event) {
    console.log('‚úÖ Recording upload completed:', event);
    await markRecordingUploadCompleteInDatabase();
    finalizeRecordingUpload('upload-completed-event');
    showToast('‚úÖ Recording uploaded!');
  }

  function handleRecordingError(event) {
    console.error('‚ùå Recording error:', event);
    showToast('‚ùå Recording error: ' + (event?.errorMsg || event?.message || 'unknown error'));
    updateRecordingStatusIndicator('idle');
    resetRecordingUploadState();
  }

  // Video setup functions
  function setupLocalVideo(track) {
    if (isSpectator) return; // Spectators don't have local video
    
    localVideo = document.getElementById('local-video');
    const placeholder = document.getElementById('local-placeholder');
    
    try {
      if (track && track instanceof MediaStreamTrack) {
        localVideo.srcObject = new MediaStream([track]);
      } else {
        const localParticipant = call.participants().local;
        if (localParticipant && localParticipant.tracks && localParticipant.tracks.video) {
          const videoTrack = localParticipant.tracks.video.track || localParticipant.tracks.video.persistentTrack;
          if (videoTrack && videoTrack instanceof MediaStreamTrack) {
            localVideo.srcObject = new MediaStream([videoTrack]);
          }
        }
      }
      
      if (isCameraOn && localVideo.srcObject) {
        localVideo.style.display = 'block';
        placeholder.style.display = 'none';
      } else {
        localVideo.style.display = 'none';
        placeholder.style.display = 'flex';
      }
    } catch (error) {
      console.error("‚ùå Error setting up local video:", error);
      localVideo.style.display = 'none';
      placeholder.style.display = 'flex';
    }
  }

  function setupRemoteVideo(track) {
    if (isSpectator) return; // Spectators use different video setup
    
    remoteVideo = document.getElementById('remote-video');
    const placeholder = document.getElementById('remote-placeholder');
    
    // CRITICAL: Check if we already have a stable video connection
    const hasStableConnection = remoteVideo.srcObject && 
                               remoteVideo.style.display === 'block' && 
                               !remoteVideo.paused && 
                               remoteVideo.readyState >= 2;
    
    if (hasStableConnection) {
      console.log('üîí BLOCKING video setup - stable connection already exists');
      return;
    }
    
    // Prevent overwriting existing video connections unless track is different
    if (remoteVideo.srcObject && remoteVideo.srcObject.getVideoTracks()[0] === track) {
      console.log('üé• Remote video already set up with this track, skipping duplicate');
      return;
    }
    
    remoteVideo.srcObject = new MediaStream([track]);
    remoteVideo.style.display = 'block';
    placeholder.style.display = 'none';
    
    console.log('‚úÖ Remote video set up for participant');
  }

  // Track which participant slots are used (only 2 participants max)
  let spectatorParticipant1 = null; // { participantId, participantName }
  let spectatorParticipant2 = null; // { participantId, participantName }

  function setupSpectatorVideo(track, participantId) {
    console.log('üé¨ Setting up spectator video for participant:', participantId);
    
    // Check if this participant already has a video set up to prevent duplicates
    if ((spectatorParticipant1 && spectatorParticipant1.participantId === participantId) ||
        (spectatorParticipant2 && spectatorParticipant2.participantId === participantId)) {
      const existingSlot = spectatorParticipant1?.participantId === participantId ? 1 : 2;
      const videoElement = document.getElementById(`spectator-participant-${existingSlot}`);
      const placeholder = document.getElementById(`spectator-placeholder-${existingSlot}`);
      
      // CRITICAL: Always update when camera turns back on (even if same track)
      console.log(`üîÑ Camera turned back on for participant ${participantId} in slot ${existingSlot}`);
      videoElement.srcObject = new MediaStream([track]);
      
      // CRITICAL: Hide placeholder and show video when camera turns back on
      placeholder.style.display = 'none';
      placeholder.classList.add('hidden');
      videoElement.classList.remove('hidden');
      videoElement.style.display = 'block';
      
      // Force video visibility styles
      videoElement.style.visibility = 'visible';
      videoElement.style.opacity = '1';
      
      console.log(`‚úÖ Spectator video restored for participant ${participantId} - camera back on`);
      
      // Try to play if user has interacted
      if (userHasInteracted) {
        videoElement.play().then(() => {
          console.log(`‚úÖ Participant ${participantId} video now playing after camera restoration`);
        }).catch(err => {
          console.log(`üé• Video will play after user interaction for participant ${participantId}`);
        });
      }
      
      // CRITICAL: Hide overlay when camera turns back on
      setTimeout(() => {
        checkAndHideClickOverlay();
      }, 100);
      
      return;
    }
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    // Assign participant to available slot (max 2 participants)
    let participantSlot = null;
    let participantName = getParticipantName(participantId);
    
    if (!spectatorParticipant1) {
      spectatorParticipant1 = { participantId, participantName };
      participantSlot = 1;
    } else if (!spectatorParticipant2) {
      spectatorParticipant2 = { participantId, participantName };
      participantSlot = 2;
    } else {
      console.log('‚ö†Ô∏è Already have 2 participants, ignoring additional participant:', participantId);
      return;
    }
    
    console.log(`üìç Assigned participant ${participantId} to slot ${participantSlot}`);
    
    // Get the video element and placeholder for this slot
    const videoElement = document.getElementById(`spectator-participant-${participantSlot}`);
    const placeholder = document.getElementById(`spectator-placeholder-${participantSlot}`);
    const nameElement = document.getElementById(`spectator-name-${participantSlot}`);
    
    if (!videoElement || !placeholder || !nameElement) {
      console.error(`‚ùå Spectator elements not found for slot ${participantSlot}`);
      return;
    }
    
    try {
      // Set up video stream
      videoElement.srcObject = new MediaStream([track]);
      
      // Update participant name
      nameElement.textContent = participantName;
      nameElement.classList.remove('hidden');
      
      // Force hide placeholder and show video element
      placeholder.style.display = 'none';
      placeholder.classList.add('hidden');
      videoElement.classList.remove('hidden');
      videoElement.style.display = 'block';
      
      console.log(`‚úÖ Spectator video set up for participant ${participantId} in slot ${participantSlot}`);
      
      // Force styles to ensure visibility
      videoElement.style.display = 'block';
      videoElement.style.visibility = 'visible';
      videoElement.style.opacity = '1';
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      
      // Force placeholder to hide
      placeholder.style.display = 'none';
      placeholder.classList.add('hidden');
      
      // Get comprehensive debugging info
      const debugInfo = {
        participantId: participantId,
        slot: participantSlot,
        videoElement: {
          hidden: videoElement.classList.contains('hidden'),
          display: videoElement.style.display,
          computedDisplay: window.getComputedStyle(videoElement).display,
          visibility: videoElement.style.visibility,
          opacity: videoElement.style.opacity,
          srcObject: !!videoElement.srcObject,
          videoWidth: videoElement.videoWidth,
          videoHeight: videoElement.videoHeight,
          readyState: videoElement.readyState,
          classList: videoElement.classList.toString(),
          bounds: videoElement.getBoundingClientRect(),
          hasVideoTracks: videoElement.srcObject ? videoElement.srcObject.getVideoTracks().length : 0
        },
        placeholder: {
          hidden: placeholder.classList.contains('hidden'),
          display: placeholder.style.display,
          computedDisplay: window.getComputedStyle(placeholder).display
        },
        parent: {
          classList: videoElement.parentElement.classList.toString(),
          display: videoElement.parentElement.style.display,
          computedDisplay: window.getComputedStyle(videoElement.parentElement).display,
          bounds: videoElement.parentElement.getBoundingClientRect()
        }
      };
      
      console.log(`üì∫ COMPREHENSIVE DEBUG - Slot ${participantSlot}:`, debugInfo);
      
      // Special debugging for slot 2
      if (participantSlot === 2) {
        console.log(`üî¥ SLOT 2 SPECIAL DEBUG:`);
        console.log(`üî¥ Video element:`, videoElement);
        console.log(`üî¥ Video bounds:`, videoElement.getBoundingClientRect());
        console.log(`üî¥ Video computed styles:`, {
          display: window.getComputedStyle(videoElement).display,
          visibility: window.getComputedStyle(videoElement).visibility,
          opacity: window.getComputedStyle(videoElement).opacity,
          position: window.getComputedStyle(videoElement).position,
          zIndex: window.getComputedStyle(videoElement).zIndex,
          transform: window.getComputedStyle(videoElement).transform
        });
        console.log(`üî¥ Parent element:`, videoElement.parentElement);
        console.log(`üî¥ Parent bounds:`, videoElement.parentElement.getBoundingClientRect());
        
        // Clear any debug styles
        videoElement.style.backgroundColor = '';
        videoElement.style.border = '';
        
        console.log(`üî¥ Applied debug styles to slot 2`);
      
      // Check click overlay state
      const clickOverlay = document.getElementById('spectator-click-overlay');
      console.log(`üî¥ Click overlay state:`, {
        exists: !!clickOverlay,
        display: clickOverlay ? clickOverlay.style.display : 'N/A',
        computedDisplay: clickOverlay ? window.getComputedStyle(clickOverlay).display : 'N/A',
        opacity: clickOverlay ? clickOverlay.style.opacity : 'N/A',
        classList: clickOverlay ? clickOverlay.classList.toString() : 'N/A'
      });
      }
      
      // Check if we should auto-hide the click overlay
      checkAndHideClickOverlay();
      
      // Update expand buttons availability
      updateSpectatorExpandButtons();
      
      // Ensure video plays - auto-play if user has already interacted
      if (userHasInteracted) {
        videoElement.play().then(() => {
          console.log(`‚úÖ Spectator video playing for participant ${participantId}`);
        }).catch(err => {
          console.log(`üé• Video will auto-play after interaction for participant ${participantId}`);
        });
      } else {
        console.log(`üé• Video ready to play after user interaction for participant ${participantId}`);
      }
      
    } catch (error) {
      console.error('‚ùå Error setting up spectator video:', error);
    }
  }

  // Global flag to track if user has interacted
  let userHasInteracted = false;
  
  // FIXED: Ensure click overlay shows/hides properly based on camera status
  function checkAndHideClickOverlay() {
    const clickOverlay = document.getElementById('spectator-click-overlay');
    if (!clickOverlay) {
      console.error('‚ùå Click overlay element not found!');
      return;
    }
    
    // Count participants with video streams
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    
    // CRITICAL: Check for active videos (cameras ON, not just participants present)
    const hasActiveVideo1 = video1 && video1.srcObject && !video1.classList.contains('hidden') && 
                           video1.style.display !== 'none' && 
                           (!placeholder1 || placeholder1.style.display === 'none');
    const hasActiveVideo2 = video2 && video2.srcObject && !video2.classList.contains('hidden') && 
                           video2.style.display !== 'none' && 
                           (!placeholder2 || placeholder2.style.display === 'none');
    
    console.log(`üé¨ OVERLAY CHECK - ActiveVideo1: ${hasActiveVideo1}, ActiveVideo2: ${hasActiveVideo2}, UserInteracted: ${userHasInteracted}`);
    
    // CRITICAL: Check if participants exist but cameras are off
    const hasParticipants = (spectatorParticipant1 !== null) || (spectatorParticipant2 !== null);
    const camerasOff = hasParticipants && !hasActiveVideo1 && !hasActiveVideo2;
    
    // ONLY hide overlay if user has clicked AND videos are actually playing with cameras on
    if (userHasInteracted && areVideosPlaying() && (hasActiveVideo1 || hasActiveVideo2)) {
      console.log('üé¨ Hiding overlay - user interacted and videos playing with cameras on');
      clickOverlay.classList.remove('spectator-overlay-force-visible');
      clickOverlay.style.display = 'none';
      clickOverlay.style.opacity = '0';
      clickOverlay.style.visibility = 'hidden';
      clickOverlay.style.pointerEvents = 'none';
      return;
    }
    
    // ALWAYS show the overlay if cameras are off OR user hasn't interacted
    console.log('üé¨ FORCING overlay to be visible');
    
    // FORCE the overlay to be visible
    clickOverlay.classList.add('spectator-overlay-force-visible');
    clickOverlay.style.setProperty('display', 'flex', 'important');
    clickOverlay.style.setProperty('opacity', '1', 'important');
    clickOverlay.style.setProperty('visibility', 'visible', 'important');
    clickOverlay.style.setProperty('pointer-events', 'auto', 'important');
    clickOverlay.style.setProperty('z-index', '9999', 'important');
    clickOverlay.classList.remove('hidden');
    
    // Update overlay content based on camera status
    const overlayText = clickOverlay.querySelector('.text-center.text-white');
    if (overlayText) {
      if (camerasOff) {
        // Participants exist but cameras are off
        const participantCount = (spectatorParticipant1 ? 1 : 0) + (spectatorParticipant2 ? 1 : 0);
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path d="M4 6a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM6 8a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1z"/>
              <path d="M2.5 8.5l2-2 2 2M15.5 11.5l-2 2-2-2"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üì∑ Cameras Are Off</p>
          <p class="text-lg text-gold mt-2">${participantCount} participant${participantCount > 1 ? 's' : ''} present, cameras disabled</p>
          <div class="mt-6 px-8 py-4 bg-yellow-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK TO WATCH WHEN CAMERAS TURN ON
          </div>
        `;
      } else if (hasActiveVideo1 || hasActiveVideo2) {
        // Cameras are on - ready to watch
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-green-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üé¨ Ready to Watch!</p>
          <p class="text-lg text-gold mt-2">${hasActiveVideo1 && hasActiveVideo2 ? '2 participants' : '1 participant'} ready for viewing</p>
          <div class="mt-6 px-8 py-4 bg-green-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK HERE TO START WATCHING
          </div>
        `;
      } else {
        // No participants yet
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
          <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
          <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
            üëÜ Click Here to Enable Video
          </div>
        `;
      }
    }
    
    console.log('‚úÖ Overlay is now properly configured');
  }
  
  // Check if videos are actually playing (cameras must be on, not just participants present)
  function areVideosPlaying() {
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    
    // SIMPLIFIED: Just check if videos have sources and placeholders are hidden (cameras on)
    // Don't check paused/readyState as these can be unreliable due to autoplay restrictions
    const video1Active = video1 && video1.srcObject && video1.style.display !== 'none' &&
                         (!placeholder1 || placeholder1.style.display === 'none' || placeholder1.classList.contains('hidden'));
    const video2Active = video2 && video2.srcObject && video2.style.display !== 'none' &&
                         (!placeholder2 || placeholder2.style.display === 'none' || placeholder2.classList.contains('hidden'));
    
    console.log(`üé• Video Status Check - Video1: ${video1Active}, Video2: ${video2Active}`);
    
    return video1Active || video2Active;
  }

  function getParticipantName(participantId) {
    const participants = call.participants();
    for (const [id, participant] of Object.entries(participants)) {
      if (id === participantId) {
        return participant.user_name || 'Participant';
      }
    }
    return 'Participant';
  }

  function removeSpectatorParticipant(participantId) {
    console.log('üóëÔ∏è Removing spectator participant:', participantId);
    
    let participantSlot = null;
    
    // Find which slot this participant was in
    if (spectatorParticipant1 && spectatorParticipant1.participantId === participantId) {
      spectatorParticipant1 = null;
      participantSlot = 1;
    } else if (spectatorParticipant2 && spectatorParticipant2.participantId === participantId) {
      spectatorParticipant2 = null;
      participantSlot = 2;
    } else {
      console.log('‚ö†Ô∏è Participant not found in any slot:', participantId);
      return;
    }
    
    console.log(`üìç Removing participant from slot ${participantSlot}`);
    
    // Get elements for this slot
    const videoElement = document.getElementById(`spectator-participant-${participantSlot}`);
    const placeholder = document.getElementById(`spectator-placeholder-${participantSlot}`);
    const nameElement = document.getElementById(`spectator-name-${participantSlot}`);
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    if (videoElement && placeholder && nameElement) {
      // Hide video and show placeholder
      videoElement.classList.add('hidden');
      videoElement.srcObject = null;
      placeholder.style.display = 'flex';
      nameElement.classList.add('hidden');
      
      console.log(`‚úÖ Cleaned up slot ${participantSlot}`);
    }
    
    // Show click overlay if no participants remain
    if (!spectatorParticipant1 && !spectatorParticipant2) {
      forceSpectatorOverlayVisible('no-participants');
      console.log('üì∫ All participants left, showing click overlay');
    }
  }

  function setupScreenShareVideo(track) {
    if (isSpectator) {
      setupSpectatorScreenShare(track);
      return;
    }
    
    screenShareVideo = document.getElementById('screen-share-video');
    const remoteVideo = document.getElementById('remote-video');
    
    screenShareVideo.srcObject = new MediaStream([track]);
    screenShareVideo.style.display = 'block';
    remoteVideo.style.display = 'none';
  }

  function setupSpectatorScreenShare(track) {
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const participantsContainer = document.getElementById('spectator-participants-container');
    
    if (!spectatorScreenShare || !participantsContainer) {
      console.error('‚ùå Screen share elements not found for spectator');
      return;
    }
    
    console.log('üì∫ Setting up spectator screen share');
    spectatorScreenShare.srcObject = new MediaStream([track]);
    spectatorScreenShare.classList.remove('hidden');
    participantsContainer.style.display = 'none';
    
    // Update expand buttons availability
    updateSpectatorExpandButtons();
    
    console.log('‚úÖ Spectator screen share started');
  }

  function setupRemoteAudio(track) {
    console.log("üîä Setting up remote audio track:", track);
    
    let remoteAudio = document.getElementById('remote-audio');
    if (!remoteAudio) {
      remoteAudio = document.createElement('audio');
      remoteAudio.id = 'remote-audio';
      remoteAudio.autoplay = true;
      remoteAudio.playsInline = true;
      document.body.appendChild(remoteAudio);
      console.log("üîä Created remote audio element");
    }
    
    remoteAudio.srcObject = new MediaStream([track]);
    console.log("üîä Remote audio track attached");
    
    remoteAudio.play().then(() => {
      console.log("‚úÖ Remote audio started playing");
    }).catch(err => {
      console.error("‚ùå Remote audio play failed:", err);
      showToast('üîä Click anywhere to enable audio');
    });
  }

  function hideRemoteVideo() {
    if (isSpectator) {
      hideSpectatorVideo();
      return;
    }
    
    const remoteVideo = document.getElementById('remote-video');
    const placeholder = document.getElementById('remote-placeholder');
    
    remoteVideo.style.display = 'none';
    placeholder.style.display = 'flex';
  }

  function hideSpectatorVideo() {
    // This function is called when screen sharing stops
    // For the new layout, we don't need to do anything here since
    // hideSpectatorScreenShare() handles the screen share cleanup
    console.log('üõë Spectator video track stopped - handled by screen share function');
  }

  function hideScreenShareVideo() {
    if (isSpectator) {
      hideSpectatorScreenShare();
      return;
    }
    
    const screenShareVideo = document.getElementById('screen-share-video');
    const remoteVideo = document.getElementById('remote-video');
    
    screenShareVideo.style.display = 'none';
    remoteVideo.style.display = 'block';
  }

  function hideSpectatorScreenShare() {
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const participantsContainer = document.getElementById('spectator-participants-container');
    
    if (!spectatorScreenShare || !participantsContainer) {
      console.error('‚ùå Screen share elements not found when hiding');
      return;
    }
    
    console.log('üì∫ Hiding spectator screen share');
    spectatorScreenShare.classList.add('hidden');
    spectatorScreenShare.srcObject = null;
    participantsContainer.style.display = 'grid';
    
    // Ensure participant videos are visible and playing
    restoreSpectatorParticipantVideos();
    
    console.log('‚úÖ Spectator screen share hidden, participants view restored');
  }

  function restoreSpectatorParticipantVideos() {
    console.log('üîÑ Restoring spectator participant videos after screen share');
    
    // Restore participant 1 video if it exists
    const video1 = document.getElementById('spectator-participant-1');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    if (video1 && video1.srcObject) {
      video1.classList.remove('hidden');
      placeholder1.style.display = 'none';
      video1.play().catch(err => console.log('Video 1 play after restore:', err));
      console.log('‚úÖ Restored participant 1 video');
    }
    
    // Restore participant 2 video if it exists
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    if (video2 && video2.srcObject) {
      video2.classList.remove('hidden');
      placeholder2.style.display = 'none';
      video2.play().catch(err => console.log('Video 2 play after restore:', err));
      console.log('‚úÖ Restored participant 2 video');
    }
    
    // Update overlay based on camera status
    checkAndHideClickOverlay();
  }

  function updateRemoteInfo(name) {
    const remoteNameEl = document.getElementById('remote-name');
    if (remoteNameEl) {
      // Use display name for better UI experience, fallback to username
      const displayName = extractUserDisplayName(name);
      remoteNameEl.textContent = displayName;
    }
  }

  // Helper function to extract and display user names in a UI-friendly way
  function extractUserDisplayName(userName) {
    // If no currentUserData or name is not provided, use name as-is
    if (!userName) return 'Guest';
    
    // For authenticated users, prefer display name over username
    // Check if this is our own name being displayed
    if (window.currentUserData && userName === window.currentUserData.username) {
      return window.currentUserData.displayName || userName;
    }
    
    // For other users, check if they have displayName in their username format
    // This assumes other users also have the same URL parameter structure
    // For now, just clean up the username for better display
    return userName.replace(/^(User_|Viewer_)/, '').replace(/[_-]/g, ' ') || userName;
  }

  // Helper function to get current user's display info
  function getCurrentUserDisplayInfo() {
    if (window.currentUserData && window.currentUserData.isAuthenticated) {
      return {
        displayName: window.currentUserData.displayName,
        username: window.currentUserData.username,
        avatar: window.currentUserData.avatar,
        isAuthenticated: true
      };
    }
    return {
      displayName: userName,
      username: userName,
      avatar: '',
      isAuthenticated: false
    };
  }

  // Update placeholder to show participant with camera off (not disconnected)
  function updateRemotePlaceholderForCameraOff(participant) {
    const placeholder = document.getElementById('remote-placeholder');
    if (!placeholder) return;
    
    const content = placeholder.querySelector('.text-center.text-white.relative.z-10');
    if (!content) return;
    
    const participantName = participant.user_name || 'Guest';
    const displayName = extractUserDisplayName(participantName);
    const firstLetter = displayName.charAt(0).toUpperCase();
    
    // Get avatar URL from participant data or URL parameters
    const avatarUrl = getParticipantAvatarUrl(participant);
    
    content.innerHTML = `
      <div class="w-24 h-24 mx-auto mb-4 bg-gray-600 rounded-full flex items-center justify-center shadow-lg overflow-hidden">
        ${avatarUrl ? 
          `<img src="${avatarUrl}" alt="${displayName}" class="w-full h-full object-cover">` :
          `<span class="text-white font-bold text-2xl">${firstLetter}</span>`
        }
      </div>
      <p class="font-bold text-lg text-white">${displayName}</p>
      <p class="text-sm text-gray-300 mt-1">üì∑ Camera is off</p>
    `;
  }

  // COMPLETELY NEW APPROACH: Replace video element with guaranteed-visible placeholder
  function updateSpectatorPlaceholderForCameraOff(participantId, participant) {
    console.log('üé≠ NEW APPROACH: Creating guaranteed placeholder for camera off:', participantId, participant.user_name);
    
    // Find which slot this participant is in
    let slot = null;
    if (spectatorParticipant1 && spectatorParticipant1.participantId === participantId) {
      slot = 1;
    } else if (spectatorParticipant2 && spectatorParticipant2.participantId === participantId) {
      slot = 2;
    }
    
    console.log(`üìç Found participant in slot: ${slot}`);
    
    if (!slot) {
      console.log('‚ö†Ô∏è No slot found for participant:', participantId);
      return;
    }
    
    const parentContainer = document.getElementById(`spectator-participant-${slot}`).parentElement;
    const nameElement = document.getElementById(`spectator-name-${slot}`);
    
    if (!parentContainer) {
      console.error(`‚ùå Parent container not found for slot ${slot}`);
      return;
    }
    
    const participantName = participant.user_name || 'Guest';
    const displayName = extractUserDisplayName(participantName);
    const firstLetter = displayName.charAt(0).toUpperCase();
    const avatarUrl = getParticipantAvatarUrl(participant);
    
    console.log(`üë§ Creating NEW placeholder element for: ${displayName} (${firstLetter})`);
    
    // STEP 1: Remove the old video and placeholder entirely
    const oldVideo = document.getElementById(`spectator-participant-${slot}`);
    const oldPlaceholder = document.getElementById(`spectator-placeholder-${slot}`);
    
    if (oldVideo) {
      oldVideo.remove();
      console.log(`üóëÔ∏è Removed old video element for slot ${slot}`);
    }
    
    if (oldPlaceholder) {
      oldPlaceholder.remove();
      console.log(`üóëÔ∏è Removed old placeholder element for slot ${slot}`);
    }
    
    // STEP 2: Create a completely new camera-off placeholder element
    const newPlaceholder = document.createElement('div');
    newPlaceholder.id = `spectator-placeholder-${slot}`;
    
    // CRITICAL: Remove ALL classes to prevent Tailwind conflicts
    newPlaceholder.className = '';
    
    // CRITICAL: Set cssText directly to override everything
    newPlaceholder.style.cssText = `
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%) !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      z-index: 1000 !important;
      border-radius: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      visibility: visible !important;
      opacity: 1 !important;
    `;
    
    // STEP 3: Add the placeholder content with inline styles for guaranteed visibility
    newPlaceholder.innerHTML = `
      <div style="
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        width: 100% !important;
        height: 100% !important;
        color: white !important;
      ">
        <div style="
          width: 100px !important;
          height: 100px !important;
          margin: 0 auto 16px !important;
          background: rgba(255, 255, 255, 0.2) !important;
          border-radius: 50% !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          overflow: hidden !important;
          border: 4px solid white !important;
          box-shadow: 0 4px 16px rgba(0,0,0,0.3) !important;
        ">
          ${avatarUrl ? 
            `<img src="${avatarUrl}" alt="${displayName}" style="
              width: 100% !important;
              height: 100% !important;
              object-fit: cover !important;
              display: block !important;
            " onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
             <span style="
               color: white !important;
               font-weight: bold !important;
               font-size: 36px !important;
               display: none !important;
               align-items: center !important;
               justify-content: center !important;
               width: 100% !important;
               height: 100% !important;
             ">${firstLetter}</span>` :
            `<span style="
              color: white !important;
              font-weight: bold !important;
              font-size: 36px !important;
              display: flex !important;
              align-items: center !important;
              justify-content: center !important;
              width: 100% !important;
              height: 100% !important;
            ">${firstLetter}</span>`
          }
        </div>
        <p style="
          font-size: 20px !important;
          font-weight: bold !important;
          color: white !important;
          margin: 0 0 8px 0 !important;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.5) !important;
        ">${displayName}</p>
        <p style="
          font-size: 14px !important;
          color: rgba(255,255,255,0.9) !important;
          margin: 0 !important;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.5) !important;
        ">üì∑ Camera is off</p>
      </div>
    `;
    
    // STEP 4: Create a new video placeholder for future use
    const newVideo = document.createElement('video');
    newVideo.id = `spectator-participant-${slot}`;
    newVideo.className = 'w-full h-full object-cover hidden';
    newVideo.autoplay = true;
    newVideo.playsInline = true;
    newVideo.style.cssText = 'display: none !important;';
    
    // STEP 5: Insert both elements into the parent container
    parentContainer.style.position = 'relative';
    parentContainer.appendChild(newVideo);
    parentContainer.appendChild(newPlaceholder);
    
    // STEP 6: Force immediate visibility with DOM manipulation
    // Use display: flex instead of display: none to ensure visibility
    newPlaceholder.style.setProperty('display', 'flex', 'important');
    newPlaceholder.classList.remove('hidden');
    
    // Ensure parent container is visible and has dimensions
    parentContainer.style.setProperty('display', 'block', 'important');
    parentContainer.style.setProperty('position', 'relative', 'important');
    
    // STEP 6: Update name element
    if (nameElement) {
      nameElement.textContent = displayName;
      nameElement.style.display = 'block';
      nameElement.classList.remove('hidden');
    }
    
    console.log(`‚úÖ GUARANTEED VISIBLE: Created new placeholder element for slot ${slot}`);
    console.log(`üéØ Avatar: ${avatarUrl ? 'Using avatar image' : 'Using initial letter: ' + firstLetter}`);
    console.log(`üì¶ Placeholder element:`, newPlaceholder);
    console.log(`üì¶ Placeholder bounding rect:`, newPlaceholder.getBoundingClientRect());
    
    // Force a repaint to ensure the element is visible
    setTimeout(() => {
      newPlaceholder.style.opacity = '1';
      console.log(`üîÑ Forced repaint for slot ${slot} placeholder`);
    }, 10);
  }

  // Get participant avatar URL from various sources
  function getParticipantAvatarUrl(participant) {
    // First check if this is our own participant data
    if (participant.user_name === window.currentUserData?.username) {
      return window.currentUserData.avatar;
    }
    
    // For now, we don't have avatar data from other participants
    // This could be enhanced in the future to pass avatar URLs through Daily.co metadata
    return '';
  }

  // Update local placeholder when you turn off your own camera
  function updateLocalPlaceholderForCameraOff() {
    const placeholder = document.getElementById('local-placeholder');
    if (!placeholder) return;
    
    const content = placeholder.querySelector('.text-center.text-white.relative.z-10');
    if (!content) return;
    
    const userDisplayInfo = getCurrentUserDisplayInfo();
    const displayName = userDisplayInfo.displayName;
    const firstLetter = displayName.charAt(0).toUpperCase();
    const avatarUrl = userDisplayInfo.avatar;
    
    content.innerHTML = `
      <div class="w-16 h-16 mx-auto mb-3 bg-gray-600 rounded-full flex items-center justify-center shadow-lg overflow-hidden">
        ${avatarUrl ? 
          `<img src="${avatarUrl}" alt="${displayName}" class="w-full h-full object-cover">` :
          `<span class="text-white font-bold text-xl">${firstLetter}</span>`
        }
      </div>
      <p class="font-bold text-gold">${displayName}</p>
      <p class="text-sm text-gray-300 mt-1">üì∑ Camera is off</p>
    `;
  }

  function updateSpectatorParticipants() {
    const container = document.getElementById('spectator-participants');
    if (!container) return;
    
    const participants = call.participants();
    const activeParticipants = Object.values(participants).filter(p => {
      if (p.local) return false;
      return getParticipantRole(p) !== 'spectator';
    });
    
    container.innerHTML = '';
    
    activeParticipants.forEach((participant, index) => {
      const badge = document.createElement('div');
      badge.className = 'bg-main-red text-white px-3 py-1 rounded-full text-sm font-semibold shadow-lg';
      const participantData = getParticipantUserData(participant);
      const displayName = participantData?.displayName || participant.user_name || `Participant ${index + 1}`;
      badge.textContent = displayName;
      container.appendChild(badge);
    });
  }

  // Control functions (only for participants)
  function toggleMic() {
    if (isSpectator) return;
    
    console.log("üé§ Toggling microphone. Current state:", isMicOn);
    
    isMicOn = !isMicOn;
    call.setLocalAudio(isMicOn);
    
    console.log("üé§ NEW MICROPHONE STATE:", isMicOn ? "ON" : "MUTED");
    console.log("üé§ Daily.co localAudio() returns:", call.localAudio());
    
    const micBtn = document.getElementById('mic-btn');
    if (isMicOn) {
      micBtn.classList.remove('active');
      showToast('üé§ Microphone on - Speak to test!');
      console.log("‚úÖ MICROPHONE ENABLED - Check console for audio levels");
      startAudioLevelMonitoring();
    } else {
      micBtn.classList.add('active');
      showToast('üîá Microphone muted');
      console.log("üîá MICROPHONE DISABLED");
    }
    
    const localParticipant = call.participants().local;
    if (localParticipant) {
      console.log("üë§ Local participant audio track state:", localParticipant.tracks.audio);
    }
  }

  function toggleCamera() {
    if (isSpectator) return;
    
    isCameraOn = !isCameraOn;
    call.setLocalVideo(isCameraOn);
    
    const cameraBtn = document.getElementById('camera-btn');
    const localVideo = document.getElementById('local-video');
    const placeholder = document.getElementById('local-placeholder');
    
    if (isCameraOn) {
      cameraBtn.classList.remove('active');
      localVideo.style.display = 'block';
      placeholder.style.display = 'none';
      showToast('üìπ Camera on');
    } else {
      cameraBtn.classList.add('active');
      localVideo.style.display = 'none';
      placeholder.style.display = 'flex';
      
      // Update local placeholder to show user avatar/initial when camera is off
      updateLocalPlaceholderForCameraOff();
      
      showToast('üì∑ Camera off');
    }
  }

  async function toggleScreenShare() {
    if (isSpectator) return;
    
    const screenShareBtn = document.getElementById('screen-share-btn');
    const localVideo = document.getElementById('local-video');
    
    if (!isScreenSharing) {
      try {
        await call.startScreenShare({
          displayMediaOptions: {
            audio: true,
            video: true,
            selfBrowserSurface: 'exclude',
            surfaceSwitching: 'include'
          }
        });
        isScreenSharing = true;
        screenShareBtn.classList.add('active');
        
        // CRITICAL: Remove mirror effect when screen sharing so user sees screen normally
        if (localVideo) {
          localVideo.classList.add('screen-sharing');
          console.log('üì∫ Removed mirror transform for screen sharing');
        }
        
        showToast('üñ•Ô∏è Screen sharing started');
      } catch (error) {
        console.error('Screen share failed:', error);
        showToast('‚ùå Screen share failed');
      }
    } else {
      try {
        await call.stopScreenShare();
        isScreenSharing = false;
        screenShareBtn.classList.remove('active');
        
        // CRITICAL: Restore mirror effect when screen sharing stops
        if (localVideo) {
          localVideo.classList.remove('screen-sharing');
          console.log('üìπ Restored mirror transform after screen sharing');
        }
        
        showToast('üñ•Ô∏è Screen sharing stopped');
      } catch (error) {
        console.error('Stop screen share failed:', error);
      }
    }
  }

  function toggleRecording() {
    if (isSpectator) return; // Only participants can record
    
    if (!isRecording) {
      showRecordingConsentModal();
    } else {
      stopRecording();
    }
  }

  function showRecordingConsentModal() {
    document.getElementById('recording-consent-modal').classList.remove('hidden');
  }

  function cancelRecording() {
    document.getElementById('recording-consent-modal').classList.add('hidden');
  }

  async function confirmRecording() {
    const privacy = document.getElementById('recording-privacy').value;
    const autoDelete = document.getElementById('recording-auto-delete').value;
    
    document.getElementById('recording-consent-modal').classList.add('hidden');
    
    try {
      // Start Daily.co recording
      await call.startRecording({
        instanceId: `chatspheres_${Date.now()}`,
        layout: {
          preset: 'default'
        }
      });
      
      // Store recording preferences
      window.recordingPreferences = {
        privacy: privacy,
        autoDelete: autoDelete
      };
      
      console.log('üé¨ Recording started with preferences:', window.recordingPreferences);
      
    } catch (error) {
      console.error('‚ùå Failed to start recording:', error);
      showToast('‚ùå Failed to start recording: ' + error.message);
    }
  }

  async function stopRecording() {
    try {
      await call.stopRecording();
      console.log('üõë Recording stopped');
    } catch (error) {
      console.error('‚ùå Failed to stop recording:', error);
      showToast('‚ùå Failed to stop recording: ' + error.message);
    }
  }

  async function saveRecordingMetadata(event) {
    if (!roomUrl) {
      throw new Error('Room URL missing while saving recording metadata');
    }
    if (!firebaseConfig.databaseURL) {
      throw new Error('Realtime Database URL missing while saving recording metadata');
    }
  
    const roomId = btoa(roomUrl);
    const recordingPath = `recordings/${roomId}/${recordingId}`;
    const recordingEndpoint = getRealtimeDatabaseRestUrl(firebaseConfig.databaseURL, recordingPath);
    const currentTopic = document.getElementById('topic-display').textContent || 'General Chat';
    const preferences = window.recordingPreferences || { privacy: 'private', autoDelete: 'never' };
    const now = getServerNow();
  
    const recordingData = {
      recordingId,
      roomUrl,
      topic: currentTopic,
      participants: Object.values(call.participants()).map(p => p.user_name || 'Guest'),
      privacy: preferences.privacy,
      autoDelete: preferences.autoDelete,
      status: 'uploading',
      uploadProgress: 0,
      createdAt: now,
      uploadInitiatedAt: now,
      downloadUrl: null
    };
  
    const payloadString = JSON.stringify(recordingData);
    recordingUploadState.pendingPayloadString = payloadString;
    recordingUploadState.pendingEndpoint = recordingEndpoint;
    recordingUploadState.dbPath = recordingPath;
  
    const response = await fetch(recordingEndpoint, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: payloadString,
      keepalive: true
    });
  
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Failed to save recording metadata: ${response.status} ${response.statusText} ${errorBody}`);
    }
  
    recordingUploadState.pendingPayloadString = null;
    recordingUploadState.progress = 100;
    updateRecordingStatusIndicator('uploading', 100);

    await fetch(recordingEndpoint, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status: 'uploaded',
        uploadProgress: 100,
        uploadCompletedAt: now
      }),
      keepalive: true
    }).catch((error) => {
      console.warn('‚ö†Ô∏è Failed to mark recording upload complete via REST:', error);
    });

    finalizeRecordingUpload('metadata-saved');
    console.log('üíæ Recording metadata saved to Firebase');
  }

  function toggleSettings() {
    if (isSpectator) return;
    
    const settingsPanel = document.getElementById('settings-panel');
    if (settingsPanel.classList.contains('hidden')) {
      settingsPanel.classList.remove('hidden');
    } else {
      settingsPanel.classList.add('hidden');
    }
  }

  async function leaveCall(event) {
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }

    console.log('üëã Leave button clicked');
    
    // Execute comprehensive cleanup
    await executeComprehensiveCleanup('leave-button');
    
    // Reload page after cleanup
    setTimeout(() => {
      window.location.reload();
    }, 500);
  }

  function cleanup() {
    console.log('üßπ Cleanup triggered');
    executeComprehensiveCleanup('cleanup');
  }

  // Event listeners for controls (only set up for participants)
  if (!isSpectator) {
    document.getElementById('mic-btn').addEventListener('click', toggleMic);
    document.getElementById('camera-btn').addEventListener('click', toggleCamera);
    document.getElementById('screen-share-btn').addEventListener('click', toggleScreenShare);
    document.getElementById('record-btn').addEventListener('click', toggleRecording);
    document.getElementById('settings-btn').addEventListener('click', toggleSettings);
    document.getElementById('leave-btn').addEventListener('click', leaveCall);
    document.getElementById('close-settings').addEventListener('click', toggleSettings);
  } else {
    // Hide participant-only controls for spectators
    const participantContainer = document.getElementById('local-video-container');
    if (participantContainer) {
      participantContainer.style.display = 'none';
    }
  }

  // Device setup functions (only for participants)
  async function requestPermissionsAndSetupDevices() {
    if (isSpectator) return;
    
    try {
      console.log("üîê Requesting media permissions...");
      
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: true, 
        audio: true 
      });
      
      console.log("‚úÖ Permissions granted successfully!");
      console.log("üé§ Audio tracks:", stream.getAudioTracks().length);
      console.log("üìπ Video tracks:", stream.getVideoTracks().length);
      
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length > 0) {
        console.log("üé§ Audio track label:", audioTracks[0].label);
        console.log("üé§ Audio track enabled:", audioTracks[0].enabled);
        console.log("üé§ Audio track ready state:", audioTracks[0].readyState);
      }
      
      stream.getTracks().forEach(track => track.stop());
      setTimeout(setupDeviceSelectors, 1000);
      
    } catch (error) {
      console.error("‚ùå Permission denied or device error:", error);
      
      if (error.name === 'NotAllowedError') {
        showToast('‚ùå Please allow camera and microphone access and reload the page');
      } else if (error.name === 'NotFoundError') {
        showToast('‚ùå No camera or microphone found. Please check your devices.');
      } else {
        showToast('‚ùå Camera/mic permissions needed. Error: ' + error.name);
      }
      
      setTimeout(setupDeviceSelectors, 1000);
    }
  }

  async function setupDeviceSelectors() {
    if (isSpectator) return;
    
    try {
      console.log("üîß Setting up device selectors...");
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const selectedDevices = await call.getInputDevices();
      const { devices: allDevices } = await call.enumerateDevices();
      
      console.log("üì± Selected devices:", selectedDevices);
      console.log("üì± All devices:", allDevices);

      const cameraSelector = document.getElementById('camera-selector');
      const micSelector = document.getElementById('mic-selector');

      if (!cameraSelector || !micSelector) {
        console.error("‚ùå Settings selectors not found in DOM");
        return;
      }

      // Setup camera selector
      cameraSelector.innerHTML = '<option disabled selected>Select camera...</option>';
      const videoDevices = allDevices.filter(d => d.kind === 'videoinput');
      console.log("üìπ Video devices found:", videoDevices.length);
      
      videoDevices.forEach(device => {
        const option = new Option(
          device.label || `Camera ${device.deviceId.slice(0, 8)}...`, 
          device.deviceId
        );
        if (selectedDevices.camera && selectedDevices.camera.deviceId === device.deviceId) {
          option.selected = true;
        }
        cameraSelector.appendChild(option);
      });

      // Setup mic selector  
      micSelector.innerHTML = '<option disabled selected>Select microphone...</option>';
      const audioDevices = allDevices.filter(d => d.kind === 'audioinput');
      console.log("üé§ Audio devices found:", audioDevices.length);
      
      audioDevices.forEach(device => {
        const option = new Option(
          device.label || `Microphone ${device.deviceId.slice(0, 8)}...`, 
          device.deviceId
        );
        if (selectedDevices.mic && selectedDevices.mic.deviceId === device.deviceId) {
          option.selected = true;
        }
        micSelector.appendChild(option);
      });

      // Add event listeners
      cameraSelector.addEventListener('change', async (e) => {
        if (e.target.value) {
          console.log("üìπ Changing camera to:", e.target.value);
          try {
            await call.setInputDevicesAsync({ videoDeviceId: e.target.value });
            showToast('üìπ Camera changed');
          } catch (error) {
            console.error("‚ùå Camera change failed:", error);
            showToast('‚ùå Camera change failed');
          }
        }
      });

      micSelector.addEventListener('change', async (e) => {
        if (e.target.value) {
          console.log("üé§ Changing microphone to:", e.target.value);
          try {
            await call.setInputDevicesAsync({ audioDeviceId: e.target.value });
            showToast('üé§ Microphone changed');
          } catch (error) {
            console.error("‚ùå Microphone change failed:", error);
            showToast('‚ùå Microphone change failed');
          }
        }
      });

      console.log("‚úÖ Device selectors set up successfully");

    } catch (error) {
      console.error('‚ùå Error setting up device selectors:', error);
      showToast('‚ùå Device settings unavailable');
    }
  }

  // Audio level monitoring for microphone confirmation (participants only)
  let audioLevelObserver = null;
  
  function startAudioLevelMonitoring() {
    if (isSpectator) return;
    
    if (call && !audioLevelObserver) {
      console.log("üé§ Starting audio level monitoring...");
      audioLevelObserver = call.startLocalAudioLevelObserver(100);
      
      call.on('local-audio-level', (event) => {
        const level = event.audioLevel;
        console.log("üîä MICROPHONE AUDIO LEVEL:", level);
        
        if (level > 0.01) {
          console.log("‚úÖ MICROPHONE IS WORKING! Audio detected:", level);
        }
      });
    }
  }

  // Timer functions
  function startTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    timerExpiredHandled = false;
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
  }

  async function updateTimer() {
    let effectiveTimeRemaining = timeRemaining;

    if (timerState.expiresAt) {
      const remainingMs = timerState.expiresAt - getServerNow();
      effectiveTimeRemaining = Math.max(0, Math.ceil(remainingMs / 1000));
      timeRemaining = effectiveTimeRemaining;
    }

    const minutes = Math.floor(effectiveTimeRemaining / 60);
    const seconds = effectiveTimeRemaining % 60;
    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    const timerElement = document.getElementById('timer');
    if (timerElement) {
      timerElement.textContent = timerState.expiresAt ? timeString : '--:--';
    }

    const timerHeaderElement = document.getElementById('timer-header');
    if (timerHeaderElement) {
      timerHeaderElement.textContent = timerState.expiresAt ? timeString : '--:--';
    }

    const headerMinutesElement = document.getElementById('minutes-used-header');
    const stickyMinutesElement = document.getElementById('minutes-used-sticky');

    if (timerState.startedAt && typeof timerState.durationSeconds === 'number') {
      let elapsedSeconds = Math.max(0, Math.floor((getServerNow() - timerState.startedAt) / 1000));
      elapsedSeconds = Math.min(elapsedSeconds, timerState.durationSeconds);
      const minutesUsed = Math.floor(elapsedSeconds / 60);

      if (headerMinutesElement) {
        headerMinutesElement.textContent = minutesUsed.toString();
      }

      if (stickyMinutesElement) {
        stickyMinutesElement.textContent = minutesUsed.toString();
      }
    } else {
      if (headerMinutesElement) {
        headerMinutesElement.textContent = '0';
      }
      if (stickyMinutesElement) {
        stickyMinutesElement.textContent = '0';
      }
    }

    if (!timerState.expiresAt) {
      return;
    }

    if (effectiveTimeRemaining > 0) {
      timerExpiredHandled = false;
      return;
    }

    if (timerExpiredHandled) {
      return;
    }

    timerExpiredHandled = true;
    clearInterval(timerInterval);
    showToast('‚è∞ Time\'s up! Thanks for chatting!');

    await executeComprehensiveCleanup('timer-expired');

    setTimeout(() => {
      window.location.reload();
    }, 1000);
  }

  // Sticky timer scroll handler
  window.addEventListener('scroll', function() {
    const stickyTimer = document.getElementById('stickyTimer');
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    if (scrollTop > 200 && !document.getElementById('video-interface').classList.contains('hidden')) {
      stickyTimer.style.opacity = '1';
      stickyTimer.style.transform = 'translateY(0)';
    } else {
      stickyTimer.style.opacity = '0';
      stickyTimer.style.transform = 'translateY(-20px)';
    }
  });

  // Toast function
  function showToast(message) {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    toastMessage.textContent = message;
    toast.classList.remove('hidden', 'translate-y-full');
    
    setTimeout(() => {
      toast.classList.add('translate-y-full');
      setTimeout(() => toast.classList.add('hidden'), 300);
    }, 3000);
  }

  // Spark functions (available to all users but only participants can generate new ones)
  function navigateSpark(direction) {
    if (direction === 'next') {
      currentSparkIndex = (currentSparkIndex + 1) % currentSparks.length;
    } else {
      currentSparkIndex = currentSparkIndex === 0 ? currentSparks.length - 1 : currentSparkIndex - 1;
    }
    updateSparkDisplay();
    
    // Sync with other participants
    if (call) {
      call.sendAppMessage({
        type: 'spark-navigation',
        sparkIndex: currentSparkIndex
      });
    }
  }

  function updateSparkDisplay() {
    document.getElementById('sparkText').textContent = currentSparks[currentSparkIndex];
    document.getElementById('sparkNumber').textContent = currentSparkIndex + 1;
    
    // Update navigation dots
    for (let i = 1; i <= 3; i++) {
      const dot = document.getElementById(`sparkDot${i}`);
      if (i === currentSparkIndex + 1) {
        dot.className = 'w-2 h-2 bg-main-red rounded-full transition-all';
      } else {
        dot.className = 'w-2 h-2 bg-gray-300 rounded-full transition-all';
      }
    }
    
    // Reset selection state
    const currentSparkEl = document.getElementById('currentSpark');
    currentSparkEl.classList.remove('ring-4', 'ring-gold');
    currentSparkEl.style.background = '';
    sparkIsSelected = false;
  }

  function selectCurrentSpark() {
    const currentSparkEl = document.getElementById('currentSpark');
    
    sparkIsSelected = !sparkIsSelected;
    
    if (sparkIsSelected) {
      currentSparkEl.classList.add('ring-4', 'ring-gold');
      currentSparkEl.style.background = 'linear-gradient(135deg, #FFD166 0%, #FFB6B9 100%)';
      showToast('üåü Spark highlighted for both users!');
    } else {
      currentSparkEl.classList.remove('ring-4', 'ring-gold');
      currentSparkEl.style.background = '';
      showToast('üí´ Spark deselected');
    }
    
    // Sync selection with other participants
    if (call) {
      call.sendAppMessage({
        type: 'spark-selected',
        sparkIndex: currentSparkIndex,
        isSelected: sparkIsSelected
      });
    }
  }

  // Load existing sparks for this room on join
  async function loadExistingSparks() {
    if (!roomUrl) {
      console.warn("‚ö†Ô∏è Cannot load sparks without a room URL");
      return;
    }
    if (!promptsDatabaseBaseUrl) {
      console.warn("‚ö†Ô∏è Prompts database URL missing - skipping sparks lookup");
      return;
    }
  
    try {
      console.log("üîç Loading existing sparks for room...");
      console.log("üîó Room URL from params:", roomUrl);
  
      const firebaseUrl = buildRealtimeQueryUrl(promptsDatabaseBaseUrl, 'sparks', {
        orderBy: JSON.stringify('room_url'),
        equalTo: JSON.stringify(roomUrl),
        limitToLast: 1
      });
      console.log("üîç Firebase query URL:", firebaseUrl);
  
      const response = await fetch(firebaseUrl);
  
      if (response.ok) {
        const data = await response.json();
  
        if (data && Object.keys(data).length > 0) {
          const latestSparkEntry = Object.values(data)[0];
  
          if (latestSparkEntry.sparks && latestSparkEntry.sparks.length > 0) {
            console.log("‚úÖ Found existing sparks:", latestSparkEntry.sparks);
            currentSparks = latestSparkEntry.sparks;
            currentSparkIndex = 0;
            updateSparkDisplay();
            showToast(`üìö Loaded ${latestSparkEntry.sparks.length} saved sparks for "${latestSparkEntry.topic}"!`);
            return;
          }
        }
      } else {
        const errorText = await response.text();
        console.error("‚ùå Firebase response not ok:", response.status, response.statusText, errorText);
        console.error("‚ùå Request URL was:", response.url);
      }
  
      console.log("üìù No existing sparks found, using defaults");
    } catch (error) {
      console.error("‚ùå Error loading existing sparks:", error);
      console.log("üìù Using default sparks due to error");
    }
  }

  // Initialize sparks after joining call
  async function initializeSparks() {
    await loadExistingSparks();
    
    const currentTopic = document.getElementById('topic-display').textContent;
    if (!isSpectator && currentSparks.length === 3 && currentTopic && currentTopic !== 'Loading Topic...' && currentTopic !== 'General Chat') {
      console.log("ü§ñ Auto-generating sparks for topic:", currentTopic);
      try {
        await generateSparksWithAI(currentTopic);
      } catch (error) {
        console.log("üìù Auto-generation failed, keeping defaults:", error.message);
      }
    }
  }

  // AI Spark Generation Functions (only for participants)
  async function generateNewSparks() {
    if (isSpectator) {
      showToast('üëÄ Only participants can generate sparks');
      return;
    }
    
    const generateBtn = document.getElementById('newSparkBtn');
    const originalText = generateBtn.innerHTML;
    
    try {
      generateBtn.innerHTML = 'üîÑ generating...';
      generateBtn.disabled = true;
      
      const currentTopic = document.getElementById('topic-display').textContent || 'general conversation';
      console.log("üß† Generating sparks for topic:", currentTopic);
      
      await generateSparksWithAI(currentTopic);
      
    } catch (error) {
      console.error("‚ùå Spark generation failed:", error);
      showToast('‚ùå Failed to generate sparks: ' + error.message);
    } finally {
      generateBtn.innerHTML = originalText;
      generateBtn.disabled = false;
    }
  }

  async function generateCustomSparks() {
    if (isSpectator) {
      showToast('üëÄ Only participants can generate sparks');
      return;
    }
    
    const customTopic = document.getElementById('userPrompt').value.trim();
    const generateBtn = document.querySelector('button[onclick="generateCustomSparks()"]');
    const originalText = generateBtn.innerHTML;
    
    if (!customTopic) {
      showToast('üí≠ Please enter a topic first!');
      document.getElementById('userPrompt').focus();
      return;
    }
    
    try {
      generateBtn.innerHTML = '‚ö° generating...';
      generateBtn.disabled = true;
      
      console.log("üß† Generating custom sparks for:", customTopic);
      
      await generateSparksWithAI(customTopic);
      
      document.getElementById('userPrompt').value = '';
      
    } catch (error) {
      console.error("‚ùå Custom spark generation failed:", error);
      showToast('‚ùå Failed to generate custom sparks: ' + error.message);
    } finally {
      generateBtn.innerHTML = originalText;
      generateBtn.disabled = false;
    }
  }

  async function generateSparksWithAI(topic) {
    const sparkPrompt = `Give 5 fresh and creative conversation starters about "${topic}". Number each one clearly (1. 2. 3. 4. 5.) and make them engaging and thought-provoking.`;

    console.log("ü§ñ Calling Netlify Function for AI sparks...");
    if (!promptsDatabaseBaseUrl) {
      throw new Error("Prompts database URL is not configured");
    }
    
    const response = await fetch("/.netlify/functions/generateSpark", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json" 
      },
      body: JSON.stringify({ 
        prompt: sparkPrompt 
      })
    });

    if (!response.ok) {
      let errorMessage = `Netlify Function error: ${response.status} ${response.statusText}`;
      
      if (response.status === 401) {
        errorMessage = "‚ùå API Authentication failed. Please check your OpenAI API key configuration in Netlify.";
        console.error("üîë 401 Error - API key issue:", {
          status: response.status,
          statusText: response.statusText,
          url: response.url
        });
      } else if (response.status === 404) {
        errorMessage = "‚ùå Netlify Function not found. Make sure your generateSpark function is deployed.";
      } else if (response.status >= 500) {
        errorMessage = "‚ùå Server error. Please try again in a moment.";
      }
      
      throw new Error(errorMessage);
    }

    const json = await response.json();
    const rawContent = json.result || "";
    
    console.log("ü§ñ Netlify Function raw response:", rawContent);
    
    const sparks = rawContent
      .split("\n")
      .map(line => line.trim())
      .filter(line => line.length > 0 && /^\d+\./.test(line))
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(line => line.length > 10);

    console.log("‚ú® Parsed sparks:", sparks);

    if (sparks.length === 0) {
      throw new Error("No valid sparks generated from AI response");
    }

    console.log("üíæ Saving sparks to Firebase...");
    
    const sparkData = {
      topic: topic,
      sparks: sparks,
      room_url: roomUrl,
      created_at: new Date().toISOString(),
      generated_by: "ai"
    };

    const sparksEndpoint = getRealtimeDatabaseRestUrl(promptsDatabaseBaseUrl, 'sparks');
    const saveResponse = await fetch(sparksEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(sparkData)
    });

    if (!saveResponse.ok) {
      const errorBody = await saveResponse.text();
      throw new Error(`Failed to save sparks to Firebase: ${saveResponse.status} ${saveResponse.statusText} ${errorBody}`);
    }

    console.log("üé® Updating UI with new sparks...");
    
    currentSparks = sparks;
    currentSparkIndex = 0;
    updateSparkDisplay();
    
    // Sync with other participant
    if (call) {
      call.sendAppMessage({
        type: 'sparks-updated',
        sparks: sparks,
        topic: topic
      });
    }

    showToast(`‚úÖ Generated ${sparks.length} sparks for "${topic}"!`);
    console.log("‚úÖ Spark generation complete!");
  }

  // Set up existing participants for participants who join late or refresh
  function setupExistingParticipantsForParticipant() {
    if (isSpectator) return;
    
    console.log('üîÑ Setting up existing participants for participant refresh');
    
    const participants = call.participants();
    const remoteParticipants = Object.entries(participants).filter(([id, participant]) => !participant.local);
    
    console.log('üë• Found remote participants:', remoteParticipants.length);
    
    remoteParticipants.forEach(([participantId, participant]) => {
      console.log('üé≠ Processing remote participant for participant view:', participantId, participant.user_name);
      
      // Set up video tracks if available
      if (participant.tracks && participant.tracks.video && participant.tracks.video.persistentTrack) {
        console.log('üé• Setting up remote video for existing participant:', participantId);
        setupRemoteVideo(participant.tracks.video.persistentTrack);
        updateRemoteInfo(participant.user_name || 'Guest');
      }
      
      // Set up screen share tracks if available
      if (participant.tracks && participant.tracks.screenVideo && participant.tracks.screenVideo.persistentTrack) {
        console.log('üì∫ Setting up screen share for existing participant:', participantId);
        setupScreenShareVideo(participant.tracks.screenVideo.persistentTrack);
      }
      
      // Set up audio tracks if available
      if (participant.tracks && participant.tracks.audio && participant.tracks.audio.persistentTrack) {
        console.log('üîä Setting up audio for existing participant:', participantId);
        setupRemoteAudio(participant.tracks.audio.persistentTrack);
      }
    });
    
    console.log('‚úÖ Participant refresh setup complete');
  }

  // Set up existing participants for spectators who join late or refresh
  function setupExistingParticipants(retryCount = 0) {
    if (!isSpectator) return;
    
    console.log(`üîÑ Setting up existing participants for spectator (attempt ${retryCount + 1}/5)`);
    
    const participants = call.participants();
    const remoteParticipants = Object.entries(participants).filter(([id, participant]) => !participant.local);
    
    console.log('üë• Found participants:', remoteParticipants.length);
    
    // If no participants found and we haven't exceeded retry limit, try again
    if (remoteParticipants.length === 0 && retryCount < 4) {
      console.log(`‚è≥ No participants found, retrying in ${(retryCount + 1) * 500}ms...`);
      setTimeout(() => {
        setupExistingParticipants(retryCount + 1);
      }, (retryCount + 1) * 500);
      return;
    }
    
    if (remoteParticipants.length > 0) {
      console.log('‚úÖ Found existing participants, setting them up...');
      
      remoteParticipants.forEach(([participantId, participant]) => {
        console.log('üé≠ Processing participant:', participantId, participant.user_name);
        
        // Set up video tracks if available
        if (participant.tracks && participant.tracks.video && participant.tracks.video.persistentTrack) {
          console.log('üé• Setting up video for existing participant:', participantId);
          setupSpectatorVideo(participant.tracks.video.persistentTrack, participantId);
        }
        
        // Set up screen share tracks if available
        if (participant.tracks && participant.tracks.screenVideo && participant.tracks.screenVideo.persistentTrack) {
          console.log('üì∫ Setting up screen share for existing participant:', participantId);
          setupSpectatorScreenShare(participant.tracks.screenVideo.persistentTrack);
        }
        
        // Set up audio tracks if available
        if (participant.tracks && participant.tracks.audio && participant.tracks.audio.persistentTrack) {
          console.log('üîä Setting up audio for existing participant:', participantId);
          setupRemoteAudio(participant.tracks.audio.persistentTrack);
        }
      });
      
      // Update click overlay since we have participants, but don't hide until user interacts
      checkAndHideClickOverlay();
      
    } else {
      console.log('üì∫ No participants found after retries, showing click overlay');
      // If no participants were found after retries, make sure click overlay is visible
      forceSpectatorOverlayVisible('no-participants');
    }
  }

  // Enable spectator video on user interaction
  function enableSpectatorVideo() {
    console.log("üé¨ User clicked to enable spectator video");
    
    // Mark that user has interacted
    userHasInteracted = true;
    
    // Enable audio context
    enableAudioContext();
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    // Try to play all available participant videos and auto-play future videos
    let playPromises = [];
    let participantCount = 0;
    
    // Play participant 1 video if available
    const video1 = document.getElementById('spectator-participant-1');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    if (video1 && video1.srcObject) {
      console.log("üé¨ Attempting to play participant 1 video");
      video1.classList.remove('hidden');
      video1.style.display = 'block';
      if (placeholder1) placeholder1.style.display = 'none';
      participantCount++;
      playPromises.push(
        video1.play().then(() => {
          console.log("‚úÖ Participant 1 video now playing");
          return true;
        }).catch(err => {
          console.error("‚ùå Participant 1 video play failed:", err);
          return false;
        })
      );
    }
    
    // Play participant 2 video if available
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    if (video2 && video2.srcObject) {
      console.log("üé¨ Attempting to play participant 2 video");
      video2.classList.remove('hidden');
      video2.style.display = 'block';
      if (placeholder2) placeholder2.style.display = 'none';
      participantCount++;
      playPromises.push(
        video2.play().then(() => {
          console.log("‚úÖ Participant 2 video now playing");
          return true;
        }).catch(err => {
          console.error("‚ùå Participant 2 video play failed:", err);
          return false;
        })
      );
    }
    
    // Show appropriate feedback based on what's available
    if (playPromises.length > 0) {
      // Hide overlay immediately since we have videos to play
      clickOverlay.style.opacity = '0';
      clickOverlay.style.transform = 'scale(0.95)';
      setTimeout(() => {
        clickOverlay.style.display = 'none';
      }, 300);
      
      Promise.allSettled(playPromises).then((results) => {
        const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
        if (successCount > 0) {
          showToast(`üé¨ Now watching ${successCount} participant${successCount > 1 ? 's' : ''}! üëÄ`);
        } else {
          showToast('üé¨ Videos ready! They may start playing shortly...');
        }
        
        // Check if videos are actually playing after a short delay
        setTimeout(() => {
          if (!areVideosPlaying()) {
            console.log('‚ö†Ô∏è Videos not playing yet, keeping overlay ready to show');
          }
        }, 1000);
      });
    } else {
      console.log("üé¨ No videos available yet, but user interaction registered");
      showToast('üé¨ Ready for video! Waiting for participants to join...');
      
      // Keep overlay visible but update its state
      const overlayText = clickOverlay.querySelector('.text-center.text-white');
      if (overlayText) {
        const title = overlayText.querySelector('.font-bold.text-xl.text-white');
        const subtitle = overlayText.querySelector('.text-sm.text-gold');
        
        if (title) title.textContent = '‚è≥ Waiting for Participants';
        if (subtitle) subtitle.textContent = 'Videos will start automatically when participants join!';
      }
    }
    
    // Also try to play any remote audio
    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio && remoteAudio.srcObject) {
      remoteAudio.play().then(() => {
        console.log("‚úÖ Remote audio now playing");
      }).catch(err => {
        console.log("Remote audio play attempt:", err);
      });
    }
    
    console.log('üé¨ User interaction complete, videos should automatically play and start when new participants join');
    
    // CRITICAL: Update expand buttons now that user has interacted
    updateSpectatorExpandButtons();
    
    // Check overlay status
    setTimeout(() => {
      checkAndHideClickOverlay();
    }, 500);
  }

  // Enable audio context on user interaction
  document.addEventListener('click', enableAudioContext, { once: true });
  document.addEventListener('touchstart', enableAudioContext, { once: true });
  
  function enableAudioContext() {
    console.log("üîä Enabling audio context from user interaction");
    if (window.AudioContext || window.webkitAudioContext) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log("‚úÖ Audio context resumed");
        });
      }
    }
    
    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio) {
      remoteAudio.play().catch(err => console.log("Audio play attempt:", err));
    }
  }

  // Fullscreen functionality
  function toggleFullscreen(videoId) {
    const video = document.getElementById(videoId === 'remote-video' ? 'screen-share-video' : videoId);
    const container = video ? video.parentElement : null;
    
    if (!container) {
      console.error('Video container not found for fullscreen');
      return;
    }
    
    if (container.classList.contains('video-fullscreen')) {
      // Exit fullscreen
      container.classList.remove('video-fullscreen');
      showToast('üì∫ Exited fullscreen mode');
    } else {
      // Enter fullscreen
      container.classList.add('video-fullscreen');
      showToast('üì∫ Entered fullscreen mode - Press ESC or click again to exit');
      
      // Add escape key listener
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          container.classList.remove('video-fullscreen');
          document.removeEventListener('keydown', escapeHandler);
          showToast('üì∫ Exited fullscreen mode');
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
  }

  // Make fullscreen function global
  window.toggleFullscreen = toggleFullscreen;

  // Spectator Immersive Viewing Functions
  let isSpectatorExpanded = false;
  let currentExpansionMode = null; // 'participants' or 'screenshare'

  function toggleSpectatorExpansion(mode) {
    if (!isSpectator) return;
    
    console.log(`üé¨ Toggling spectator expansion mode: ${mode}`);
    
    const spectatorLayout = document.getElementById('spectator-layout');
    const videoContainer = spectatorLayout.querySelector('.lg\\:col-span-3');
    const participantsBtn = document.getElementById('expand-participants-btn');
    const screenshareBtn = document.getElementById('expand-screenshare-btn');
    
    if (isSpectatorExpanded && currentExpansionMode === mode) {
      // Exit expansion mode
      console.log('üì∫ Exiting spectator expansion mode');
      
      isSpectatorExpanded = false;
      currentExpansionMode = null;
      
      // Reset layout
      spectatorLayout.classList.remove('spectator-expanded');
      videoContainer.classList.remove('spectator-video-expanded');
      
      // Update button states
      participantsBtn.classList.remove('expanded');
      screenshareBtn.classList.remove('expanded');
      participantsBtn.innerHTML = `
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
          <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
        </svg>
        EXPAND
      `;
      screenshareBtn.innerHTML = `
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
          <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 15a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1v-2z"/>
        </svg>
        EXPAND
      `;
      
      showToast('üì∫ Exited immersive view');
      
    } else {
      // Enter expansion mode
      console.log(`üé¨ Entering spectator expansion mode: ${mode}`);
      
      isSpectatorExpanded = true;
      currentExpansionMode = mode;
      
      // Apply expansion layout
      spectatorLayout.classList.add('spectator-expanded');
      videoContainer.classList.add('spectator-video-expanded');
      
      // Update button states
      if (mode === 'participants') {
        participantsBtn.classList.add('expanded');
        screenshareBtn.classList.remove('expanded');
        participantsBtn.innerHTML = `
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
            <path d="M13 7H7v6h6V7z"/>
            <path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 110-2h1V5a2 2 0 012-2h2V2z" clip-rule="evenodd"/>
          </svg>
          COLLAPSE
        `;
        showToast('üé¨ Immersive participant view activated! Chat remains visible.');
      } else if (mode === 'screenshare') {
        screenshareBtn.classList.add('expanded');
        participantsBtn.classList.remove('expanded');
        screenshareBtn.innerHTML = `
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
            <path d="M13 7H7v6h6V7z"/>
            <path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 110-2h1V5a2 2 0 012-2h2V2z" clip-rule="evenodd"/>
          </svg>
          COLLAPSE
        `;
        showToast('üé¨ Immersive screen share view activated! Chat remains visible.');
      }
    }
    
    // Add keyboard shortcut to exit
    if (isSpectatorExpanded) {
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          toggleSpectatorExpansion(currentExpansionMode);
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
  }

  // Function to show/hide expand buttons based on content availability
  function updateSpectatorExpandButtons() {
    if (!isSpectator) return;
    
    const participantsBtn = document.getElementById('expand-participants-btn');
    const screenshareBtn = document.getElementById('expand-screenshare-btn');
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    
    // Check if screen share is actually active
    const hasScreenShare = spectatorScreenShare && 
                          spectatorScreenShare.srcObject && 
                          !spectatorScreenShare.classList.contains('hidden');
    
    // Check if participants are available
    const hasParticipants = (video1 && video1.srcObject && !video1.classList.contains('hidden')) || 
                           (video2 && video2.srcObject && !video2.classList.contains('hidden'));
    
    console.log(`üé¨ Button update check - Participants: ${hasParticipants}, ScreenShare: ${hasScreenShare}, UserInteracted: ${userHasInteracted}`);
    
    // Show expand buttons only after user interaction AND content is available
    if (userHasInteracted) {
      // PRIORITY: Screen share button takes precedence when active
      if (hasScreenShare) {
        // Show ONLY screen share button when screen sharing
        screenshareBtn.style.display = 'flex';
        screenshareBtn.classList.remove('hidden');
        participantsBtn.style.display = 'none';
        participantsBtn.classList.add('hidden');
        console.log('‚úÖ Showing screen share expand button');
      } else if (hasParticipants) {
        // Show ONLY participants button when no screen share but participants available
        participantsBtn.style.display = 'flex';
        participantsBtn.classList.remove('hidden');
        screenshareBtn.style.display = 'none';
        screenshareBtn.classList.add('hidden');
        console.log('‚úÖ Showing participants expand button');
      } else {
        // Hide both buttons when no content available
        participantsBtn.style.display = 'none';
        participantsBtn.classList.add('hidden');
        screenshareBtn.style.display = 'none';
        screenshareBtn.classList.add('hidden');
        console.log('‚ùå Hiding all expand buttons - no content');
      }
    } else {
      // Hide both buttons when user hasn't interacted yet
      participantsBtn.style.display = 'none';
      participantsBtn.classList.add('hidden');
      screenshareBtn.style.display = 'none';
      screenshareBtn.classList.add('hidden');
      console.log('‚ùå Hiding all expand buttons - no user interaction');
    }
  }

  // Make functions global
  window.toggleSpectatorExpansion = toggleSpectatorExpansion;

  // Initialize
  console.log("ChatSpheres Video Chat Room Loading... üåü");
  console.log(`Mode: ${isSpectator ? 'Spectator üëÄ' : 'Participant üé§'}`);
</script>

</body>
</html>
