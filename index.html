<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ChatSpheres - Join Your Sphere</title>
  
  <!-- Google AdSense -->
  <meta name="google-adsense-account" content="ca-pub-8986841930339200">

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- LiveKit Web SDK -->
    <script src="https://cdn.jsdelivr.net/npm/livekit-client@2.3.0/dist/livekit-client.umd.min.js"></script>
    <script>
      window.__CHATSPHERES_CONFIG__ = window.__CHATSPHERES_CONFIG__ || {};
    </script>
    <script src="/.netlify/functions/client-config"></script>
  <!-- Tailwind styles are generated by npm run build and served from /styles -->
  <link rel="stylesheet" href="styles/tailwind.generated.css">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
  
  <!-- Brand CSS -->
  <link rel="stylesheet" href="/assets/css/brand.css">
  
  <!-- Ads CSS -->
  <link rel="stylesheet" href="/assets/css/ads.css">

  <style>
    * {
      font-family: 'Nunito', sans-serif;
    }
    
    .video-placeholder {
      background: linear-gradient(135deg, #22223B 0%, #2a2a4a 100%);
    }
    
    /* Fix screen share orientation and display */
    #screen-share-video,
    #spectator-screen-share {
      transform: scaleX(1) !important; /* Ensure no horizontal flip */
      object-fit: contain !important; /* Show full screen content */
      background-color: #000 !important; /* Black background for letterboxing */
    }
    
    /* Mirror local camera by default */
    #local-video {
      transform: scaleX(-1); /* Mirror local camera */
    }
    
    /* Remove mirror when screen sharing (local user sees their own screen normally) */
    #local-video.screen-sharing {
      transform: none !important;
    }
    
    /* Override any transform on screen share videos to prevent flipping */
    video[id*="screen"] {
      transform: none !important;
    }
    
    /* Ensure remote screen shares are never flipped */
    #screen-share-video,
    #spectator-screen-share {
      transform: none !important;
    }
    
    /* Full screen expansion styles */
    .video-fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9999 !important;
      background: #000 !important;
    }
    
    .video-fullscreen video {
      width: 100% !important;
      height: 100% !important;
      object-fit: contain !important;
    }
    
    /* Fullscreen button styles */
    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      padding: 8px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
      transition: background 0.2s;
    }
    
    .fullscreen-btn:hover {
      background: rgba(0, 0, 0, 0.9);
    }
    
    .chatspheres-pattern {
      position: relative;
      overflow: hidden;
    }
    
    .chatspheres-pattern::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 30% 70%, rgba(230, 57, 70, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 70% 30%, rgba(255, 209, 102, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .vesica-accent {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.1;
      pointer-events: none;
    }
    
    .timer-glow {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .new-spark-btn {
      background: #FFD166;
      color: #22223B;
      transition: all 0.2s ease;
    }
    
    .new-spark-btn:hover {
      background: #e63946;
      color: white;
      transform: scale(1.05);
    }
    
    .topic-badge {
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%);
      color: white;
    }

    /* Waiting overlay styles */
    #waiting-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      border: 3px solid #fff;
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(230, 57, 70, 0.15);
      padding: 1.5rem 2rem;
      z-index: 9999;
      text-align: center;
      width: 320px;
    }

    #waiting-overlay .waiting-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #e63946;
      margin-bottom: 0.5rem;
    }

    #waiting-overlay .waiting-subtitle {
      font-size: 0.95rem;
      color: #22223B;
      margin-bottom: 1rem;
    }

    #waiting-overlay .status-badge {
      background: #FFD166;
      color: #22223B;
      padding: 0.5rem 1rem;
      border-radius: 100px;
      font-weight: 700;
      font-size: 0.85rem;
    }

    .loading-dots::after {
      content: '';
      animation: loading-dots 1.5s infinite;
      margin-left: 0.25rem;
    }

    @keyframes loading-dots {
      0% { content: ''; }
      25% { content: '.'; }
      50% { content: '..'; }
      75% { content: '...'; }
      100% { content: ''; }
    }

    .control-btn {
      transition: all 0.2s ease;
    }

    .control-btn.active {
      background: #e63946 !important;
      color: white !important;
    }

    /* Live Chat Styles */
    .live-chat {
      max-height: 400px;
      overflow-y: auto;
    }

    .live-chat::-webkit-scrollbar {
      width: 4px;
    }

    .live-chat::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 2px;
    }

    .live-chat::-webkit-scrollbar-thumb {
      background: #FFD166;
      border-radius: 2px;
    }

    .live-chat::-webkit-scrollbar-thumb:hover {
      background: #e63946;
    }

    .chat-message {
      animation: slideInRight 0.3s ease-out;
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .spectator-badge {
      background: linear-gradient(135deg, #FFB6B9 0%, #FCE2E5 100%);
      color: #22223B;
    }

    .participant-badge {
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%);
      color: white;
    }

    /* Recording Indicator */
    .recording-indicator {
      animation: recordingPulse 1s infinite;
    }

    @keyframes recordingPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* ========== TIP ANIMATION STYLES ========== */
    
    /* Animation picker selected state */
    .tip-anim-btn.selected {
      background: linear-gradient(135deg, #FFD166 0%, #e63946 100%) !important;
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
    }
    
    /* Particle base styles */
    .tip-particle {
      position: absolute;
      pointer-events: none;
      font-size: 2rem;
      z-index: 10001;
      will-change: transform, opacity;
    }
    
    /* Falling animation (for rain effects) */
    @keyframes tipFall {
      0% {
        transform: translateY(-100px) rotate(0deg) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg) scale(0.5);
        opacity: 0;
      }
    }
    
    /* Rising animation (for fire, etc) */
    @keyframes tipRise {
      0% {
        transform: translateY(100vh) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(-100px) scale(0.3);
        opacity: 0;
      }
    }
    
    /* Explosion from center */
    @keyframes tipExplode {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
      }
      50% {
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(1);
        opacity: 0;
      }
    }
    
    /* Float up gently */
    @keyframes tipFloat {
      0% {
        transform: translateY(0) translateX(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(-200px) translateX(var(--drift)) rotate(var(--rot));
        opacity: 0;
      }
    }
    
    /* Rocket animation */
    @keyframes tipRocket {
      0% {
        transform: translateX(-100%) translateY(50vh) rotate(45deg);
        opacity: 1;
      }
      100% {
        transform: translateX(100vw) translateY(-100px) rotate(45deg);
        opacity: 1;
      }
    }
    
    /* Bounce in for announcement */
    @keyframes tipBounceIn {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }
    
    /* Shake effect for big tips */
    @keyframes tipShake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    
    /* Glow pulse for amount */
    @keyframes tipGlow {
      0%, 100% {
        text-shadow: 0 0 20px rgba(255,209,102,0.8), 0 0 40px rgba(255,209,102,0.5);
      }
      50% {
        text-shadow: 0 0 40px rgba(255,209,102,1), 0 0 80px rgba(255,209,102,0.8), 0 0 120px rgba(230,57,70,0.5);
      }
    }
    
    /* Rainbow shimmer */
    @keyframes tipRainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    /* Disco strobe */
    @keyframes tipDisco {
      0% { background: rgba(255,0,0,0.3); }
      16% { background: rgba(255,165,0,0.3); }
      33% { background: rgba(255,255,0,0.3); }
      50% { background: rgba(0,255,0,0.3); }
      66% { background: rgba(0,0,255,0.3); }
      83% { background: rgba(128,0,128,0.3); }
      100% { background: rgba(255,0,0,0.3); }
    }
    
    /* Spin animation for disco ball */
    @keyframes tipSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Snow drift */
    @keyframes tipSnow {
      0% {
        transform: translateY(-50px) translateX(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) translateX(var(--drift)) rotate(360deg);
        opacity: 0.5;
      }
    }
    
    /* Announcement visible state */
    #tip-announcement.visible {
      opacity: 1;
      animation: tipBounceIn 0.5s ease-out forwards;
    }
    
    #tip-announcement-amount {
      animation: tipGlow 1s ease-in-out infinite;
    }
    
    /* Disco overlay */
    .tip-disco-overlay {
      position: fixed;
      inset: 0;
      animation: tipDisco 0.5s linear infinite;
      pointer-events: none;
      z-index: 10000;
    }
    
    /* GIF display animation */
    #tip-gif-display.visible {
      display: block !important;
      animation: tipBounceIn 0.5s ease-out forwards;
    }
    
    /* ========== END TIP ANIMATION STYLES ========== */

    .recording-upload-status {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .recording-upload-bar {
      margin-top: 4px;
      width: 100%;
      height: 3px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 9999px;
      overflow: hidden;
    }

    .recording-upload-bar-fill {
      height: 100%;
      width: 0%;
      background: #FFD166;
      transition: width 0.2s ease;
    }

    /* Modal Styles */
    .modal-overlay {
      background: rgba(34, 34, 59, 0.8);
      backdrop-filter: blur(4px);
    }
    
    /* Share Modal Animation */
    .animate-modal-pop {
      animation: modalPop 0.3s ease-out;
    }
    
    @keyframes modalPop {
      0% {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    /* CTA Button - Brand Style */
    .cta-btn {
      background: #FFD166;
      color: #22223B;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 2rem;
      font-weight: 700;
      transition: background 0.2s, color 0.2s, transform 0.2s;
    }
    .cta-btn:hover {
      background: #e63946;
      color: #ffffff;
      transform: scale(1.02);
    }
    
    /* Share button glow effect - Brand colors */
    #share-btn,
    #header-share-btn {
      animation: shareGlow 2s ease-in-out infinite;
    }
    
    @keyframes shareGlow {
      0%, 100% {
        box-shadow: 0 4px 15px rgba(255, 209, 102, 0.5);
      }
      50% {
        box-shadow: 0 4px 25px rgba(255, 209, 102, 0.9), 0 0 40px rgba(230, 57, 70, 0.3);
      }
    }
    
    /* Stats counter pop animation */
    #share-participant-count,
    #share-spectator-count,
    #share-link-shares {
      transition: transform 0.3s ease;
    }
    
    /* Share link mode button active state */
    #share-participant-link.bg-gold,
    #share-spectator-link.bg-gold {
      box-shadow: 0 4px 15px rgba(255, 209, 102, 0.5);
    }

    /* Spectator Immersive View Styles */
    .spectator-expanded {
      grid-template-columns: 5fr 1fr !important; /* Expand video area, shrink chat */
    }
    
    .spectator-video-expanded {
      transform: scale(1.02);
      transition: all 0.3s ease;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      border: 3px solid #e63946;
    }
    
    .expand-button {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(230, 57, 70, 0.9);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
      transition: all 0.2s;
      font-size: 12px;
      font-weight: bold;
      backdrop-filter: blur(4px);
    }
    
    .expand-button:hover {
      background: rgba(230, 57, 70, 1);
      transform: scale(1.05);
    }
    
    .expand-button.expanded {
      background: rgba(255, 209, 102, 0.9);
      color: #22223B;
    }
    
    .expand-button.expanded:hover {
      background: rgba(255, 209, 102, 1);
    }
    
    /* Immersive overlay for full focus */
    .immersive-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: none;
      padding: 20px;
    }
    
    .immersive-content {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: 4fr 1fr;
      gap: 20px;
      max-width: none;
    }
    
    .immersive-video {
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }
    
    .immersive-chat {
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    @media (max-width: 768px) {
      #waiting-overlay {
        width: 200px;
        top: 8px;
        left: 8px;
        right: auto;
        padding: 0.75rem 1rem;
      }
      
      .live-chat {
        max-height: 300px;
      }
    }

    /* CRITICAL: Force overlay visibility when cameras are off */
    .spectator-overlay-force-visible {
      display: flex !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      z-index: 9999 !important;
    }
  </style>
</head>
<body class="min-h-screen font-nunito" style="background-color: #FFE7DD;" data-livekit-url="wss://your-livekit-host" data-livekit-control="https://your-control-server" data-livekit-token="" data-livekit-control-key="" data-livekit-recordings="">

<!-- Auth Modal -->
<div id="auth-modal" class="auth-modal">
  <div class="auth-modal-content">
    <button onclick="hideAuthModal()" class="auth-close">√ó</button>
    
    <div class="auth-modal-logo">
      <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="24" cy="32" r="20" stroke="#FCE2E5" stroke-width="6"/>
        <circle cx="40" cy="32" r="20" stroke="#FCE2E5" stroke-width="6"/>
        <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
        <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
      </svg>
      <h2>Welcome to ChatSpheres</h2>
      <p>Sign in to connect with purpose</p>
    </div>
    
    <div id="auth-message" class="auth-message hidden"></div>
    
    <form id="signin-form" class="auth-form" onsubmit="handleSignIn(event)">
      <div class="form-group">
        <label class="form-label">Email</label>
        <input type="email" id="signin-email" class="form-input" required placeholder="you@example.com">
      </div>
      <div class="form-group">
        <label class="form-label">Password</label>
        <input type="password" id="signin-password" class="form-input" required placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
      </div>
      <button type="submit" id="signin-submit" class="btn btn-primary btn-full">Sign In</button>
    </form>
    
    <div class="auth-divider">
      <span>or continue with</span>
    </div>
    
    <button onclick="handleGoogleSignIn()" id="google-signin-btn" class="google-btn">
      <svg width="20" height="20" viewBox="0 0 24 24">
        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
      </svg>
      Continue with Google
    </button>
    
    <p class="auth-signup-link">
      Don't have an account? <a href="https://www.chatspheres.com/sign-up/">Sign Up</a>
    </p>
    
    <button onclick="continueAsGuest()" style="display: block; width: 100%; margin-top: var(--space-sm); text-align: center; font-size: 0.875rem; text-decoration: underline; color: var(--charcoal); opacity: 0.6; background: none; border: none; cursor: pointer;">
      Continue as guest
    </button>
    
    <!-- Auth Loading Overlay -->
    <div id="auth-loading" class="hidden" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; border-radius: var(--radius-xl); background: rgba(252, 226, 229, 0.95);">
      <div style="text-align: center;">
        <div style="width: 48px; height: 48px; border: 4px solid var(--main-red); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto var(--space-md);"></div>
        <p style="color: var(--charcoal); font-weight: var(--font-weight-semibold);" id="auth-loading-text">Signing in...</p>
      </div>
    </div>
  </div>
</div>

<!-- Tip Animation Overlay -->
<div id="tip-animation-overlay" class="fixed inset-0 z-[10000] pointer-events-none overflow-hidden" style="display: none;">
  <!-- Particle container -->
  <div id="tip-particles-container" class="absolute inset-0"></div>
  
  <!-- Center announcement -->
  <div id="tip-announcement" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center opacity-0 transition-all duration-500">
    <div id="tip-announcement-amount" class="text-6xl font-black text-white drop-shadow-lg mb-2" style="text-shadow: 0 0 20px rgba(255,209,102,0.8), 0 0 40px rgba(255,209,102,0.5);"></div>
    <div id="tip-announcement-sender" class="text-2xl font-bold text-gold mb-4"></div>
    <div id="tip-announcement-message" class="max-w-md mx-auto text-xl text-white bg-charcoal/80 rounded-2xl px-6 py-4 backdrop-blur-sm" style="display: none;"></div>
  </div>
  
  <!-- GIF display area (for cat/meme modes) -->
  <div id="tip-gif-display" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2" style="display: none;">
    <img id="tip-gif-image" class="max-w-sm max-h-64 rounded-2xl shadow-2xl border-4 border-gold" src="" alt="">
  </div>
</div>

<!-- Tip Modal (Enhanced with message + animation picker) -->
<div id="tip-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-5 max-w-md w-full shadow-2xl border-4 border-gold relative max-h-[90vh] overflow-y-auto">
    <!-- Close button -->
    <button onclick="closeTipModal()" class="absolute top-3 right-3 text-charcoal hover:text-main-red transition-colors z-10">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Content -->
    <div class="text-center">
      <!-- Icon -->
      <div class="w-14 h-14 mx-auto mb-2 bg-gold rounded-full flex items-center justify-center">
        <span class="text-2xl">üíé</span>
      </div>
      
      <!-- Title -->
      <h2 class="text-xl font-bold text-charcoal mb-1">Send a Tip</h2>
      <p class="text-sm text-charcoal opacity-70 mb-2">Choose who to support!</p>
      
      <!-- Recipient Picker -->
      <div class="mb-3">
        <label class="block text-left text-xs font-bold text-charcoal mb-1">üë§ Tip to:</label>
        <select id="tip-recipient-select" class="w-full p-2 border-2 border-charcoal rounded-xl font-bold focus:border-main-red outline-none bg-white text-charcoal" onchange="onTipRecipientChange()">
          <option value="">-- Select a participant --</option>
        </select>
        <p id="tip-recipient-info" class="text-left text-xs text-charcoal/60 mt-1 hidden">
          <span id="tip-recipient-badge"></span>
        </p>
        <p id="tip-no-recipients" class="text-left text-xs text-main-red mt-1 hidden">
          ‚ö†Ô∏è No signed-in participants to tip. Guests cannot receive tips.
        </p>
      </div>
      
      <!-- Your balance -->
      <div class="mb-3 p-2 bg-rose rounded-xl">
        <p class="text-xs text-charcoal">Your balance: <span id="tip-your-balance" class="font-bold">üíé 0</span></p>
      </div>
      
      <!-- Quick amounts -->
      <div class="grid grid-cols-4 gap-2 mb-3">
        <button onclick="selectTipAmount(10)" class="tip-amount-btn p-2 bg-gold rounded-xl font-bold text-charcoal hover:bg-main-red hover:text-white transition-all text-sm">
          üíé 10
        </button>
        <button onclick="selectTipAmount(50)" class="tip-amount-btn p-2 bg-gold rounded-xl font-bold text-charcoal hover:bg-main-red hover:text-white transition-all text-sm">
          üíé 50
        </button>
        <button onclick="selectTipAmount(100)" class="tip-amount-btn p-2 bg-gold rounded-xl font-bold text-charcoal hover:bg-main-red hover:text-white transition-all text-sm">
          üíé 100
        </button>
        <button onclick="selectTipAmount(500)" class="tip-amount-btn p-2 bg-gold rounded-xl font-bold text-charcoal hover:bg-main-red hover:text-white transition-all text-sm">
          üíé 500
        </button>
      </div>
      
      <!-- Custom amount -->
      <div class="mb-3">
        <input type="number" id="tip-custom-amount" placeholder="Custom amount (min 10)" min="10" 
          class="w-full p-2 border-2 border-charcoal rounded-xl text-center font-bold focus:border-main-red outline-none"
          onchange="selectTipAmount(this.value)">
      </div>
      
      <!-- Custom Message Input -->
      <div class="mb-3">
        <label class="block text-left text-xs font-bold text-charcoal mb-1">üí¨ Add a message (optional)</label>
        <input type="text" id="tip-message-input" placeholder="Say something nice..." maxlength="100"
          class="w-full p-2 border-2 border-charcoal rounded-xl text-sm focus:border-main-red outline-none">
        <p class="text-right text-xs text-charcoal/60 mt-1"><span id="tip-message-count">0</span>/100</p>
      </div>
      
      <!-- Animation Picker -->
      <div class="mb-3">
        <label class="block text-left text-xs font-bold text-charcoal mb-2">üé¨ Choose your celebration style</label>
        <div class="grid grid-cols-5 gap-1.5 max-h-32 overflow-y-auto p-1 bg-white/50 rounded-xl" id="animation-picker">
          <!-- Row 1: Classic -->
          <button type="button" onclick="selectTipAnimation('gems')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center selected" data-anim="gems">
            <span class="text-xl">üíé</span>
            <span class="text-[10px] font-bold">Gems</span>
          </button>
          <button type="button" onclick="selectTipAnimation('confetti')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="confetti">
            <span class="text-xl">üéâ</span>
            <span class="text-[10px] font-bold">Confetti</span>
          </button>
          <button type="button" onclick="selectTipAnimation('money')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="money">
            <span class="text-xl">üí∞</span>
            <span class="text-[10px] font-bold">Money</span>
          </button>
          <button type="button" onclick="selectTipAnimation('fire')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="fire">
            <span class="text-xl">üî•</span>
            <span class="text-[10px] font-bold">Fire</span>
          </button>
          <button type="button" onclick="selectTipAnimation('stars')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="stars">
            <span class="text-xl">‚≠ê</span>
            <span class="text-[10px] font-bold">Stars</span>
          </button>
          <!-- Row 2: Animals -->
          <button type="button" onclick="selectTipAnimation('cats')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="cats">
            <span class="text-xl">üê±</span>
            <span class="text-[10px] font-bold">Cats</span>
          </button>
          <button type="button" onclick="selectTipAnimation('dogs')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="dogs">
            <span class="text-xl">üêï</span>
            <span class="text-[10px] font-bold">Dogs</span>
          </button>
          <button type="button" onclick="selectTipAnimation('frogs')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="frogs">
            <span class="text-xl">üê∏</span>
            <span class="text-[10px] font-bold">Frogs</span>
          </button>
          <button type="button" onclick="selectTipAnimation('butterflies')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="butterflies">
            <span class="text-xl">ü¶ã</span>
            <span class="text-[10px] font-bold">Butterfly</span>
          </button>
          <button type="button" onclick="selectTipAnimation('unicorn')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="unicorn">
            <span class="text-xl">ü¶Ñ</span>
            <span class="text-[10px] font-bold">Unicorn</span>
          </button>
          <!-- Row 3: Food & Fun -->
          <button type="button" onclick="selectTipAnimation('pizza')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="pizza">
            <span class="text-xl">üçï</span>
            <span class="text-[10px] font-bold">Pizza</span>
          </button>
          <button type="button" onclick="selectTipAnimation('tacos')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="tacos">
            <span class="text-xl">üåÆ</span>
            <span class="text-[10px] font-bold">Tacos</span>
          </button>
          <button type="button" onclick="selectTipAnimation('hearts')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="hearts">
            <span class="text-xl">üíñ</span>
            <span class="text-[10px] font-bold">Hearts</span>
          </button>
          <button type="button" onclick="selectTipAnimation('rocket')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="rocket">
            <span class="text-xl">üöÄ</span>
            <span class="text-[10px] font-bold">Rocket</span>
          </button>
          <button type="button" onclick="selectTipAnimation('rainbow')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="rainbow">
            <span class="text-xl">üåà</span>
            <span class="text-[10px] font-bold">Rainbow</span>
          </button>
          <!-- Row 4: Vibes -->
          <button type="button" onclick="selectTipAnimation('gaming')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="gaming">
            <span class="text-xl">üéÆ</span>
            <span class="text-[10px] font-bold">Gaming</span>
          </button>
          <button type="button" onclick="selectTipAnimation('music')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="music">
            <span class="text-xl">üéµ</span>
            <span class="text-[10px] font-bold">Music</span>
          </button>
          <button type="button" onclick="selectTipAnimation('disco')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="disco">
            <span class="text-xl">ü™©</span>
            <span class="text-[10px] font-bold">Disco</span>
          </button>
          <button type="button" onclick="selectTipAnimation('skull')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="skull">
            <span class="text-xl">üíÄ</span>
            <span class="text-[10px] font-bold">Spooky</span>
          </button>
          <button type="button" onclick="selectTipAnimation('sparkles')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="sparkles">
            <span class="text-xl">‚ú®</span>
            <span class="text-[10px] font-bold">Sparkle</span>
          </button>
          <!-- Row 5: Nature & Weather -->
          <button type="button" onclick="selectTipAnimation('snow')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="snow">
            <span class="text-xl">‚ùÑÔ∏è</span>
            <span class="text-[10px] font-bold">Snow</span>
          </button>
          <button type="button" onclick="selectTipAnimation('cherry')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="cherry">
            <span class="text-xl">üå∏</span>
            <span class="text-[10px] font-bold">Sakura</span>
          </button>
          <button type="button" onclick="selectTipAnimation('leaves')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="leaves">
            <span class="text-xl">üçÇ</span>
            <span class="text-[10px] font-bold">Autumn</span>
          </button>
          <button type="button" onclick="selectTipAnimation('meme')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="meme">
            <span class="text-xl">üòÇ</span>
            <span class="text-[10px] font-bold">Meme</span>
          </button>
          <button type="button" onclick="selectTipAnimation('random')" class="tip-anim-btn p-2 rounded-lg bg-white hover:bg-gold transition-all flex flex-col items-center" data-anim="random">
            <span class="text-xl">üé≤</span>
            <span class="text-[10px] font-bold">Random</span>
          </button>
        </div>
      </div>
      
      <!-- TTS Toggle -->
      <div class="mb-3 flex items-center justify-between bg-white/50 rounded-xl p-2">
        <label class="text-xs font-bold text-charcoal flex items-center gap-1">
          üîä Read message aloud (TTS)
        </label>
        <label class="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" id="tip-tts-toggle" class="sr-only peer" checked>
          <div class="w-9 h-5 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-main-red"></div>
        </label>
      </div>
      
      <!-- Selected amount display -->
      <div class="mb-3 p-3 bg-charcoal rounded-xl">
        <p class="text-white text-sm">Sending: <span id="tip-selected-amount" class="text-xl font-bold text-gold">üíé 0</span></p>
        <p class="text-xs text-gray-300 mt-1">Recipient receives 50% ‚Ä¢ <span id="tip-host-receives">üíé 0</span></p>
      </div>
      
      <!-- Send button -->
      <button id="send-tip-btn" onclick="sendTip()" disabled
        class="w-full py-3 px-6 bg-gold text-charcoal font-bold rounded-full hover:bg-main-red hover:text-white transition-all disabled:opacity-50 disabled:cursor-not-allowed text-lg">
        üéâ Send Tip
      </button>
      
      <!-- Error message -->
      <p id="tip-error" class="hidden mt-2 text-sm text-main-red font-semibold"></p>
    </div>
  </div>
</div>

<!-- End Debate Modal (Host Only - for closing Red Room debates) -->
<div id="end-debate-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-gradient-to-br from-red-900 to-red-800 rounded-3xl p-6 max-w-md w-full shadow-2xl border-4 border-red-400 relative">
    <!-- Close button -->
    <button onclick="hideEndDebateModal()" class="absolute top-3 right-3 text-white hover:text-red-200 transition-colors">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Confirmation View (shown initially) -->
    <div id="end-debate-confirm" class="text-center">
      <div class="text-5xl mb-4">üèÅ</div>
      <h3 class="text-2xl font-extrabold text-white mb-3">End This Debate?</h3>
      
      <div class="bg-black bg-opacity-30 rounded-xl p-4 mb-4">
        <div class="text-sm text-red-200 mb-2">Current Pot Status:</div>
        <div id="end-debate-pot-status" class="text-2xl font-bold text-white">üíé 0</div>
        <div id="end-debate-void-warning" class="hidden text-xs text-yellow-300 mt-2">
          ‚ö†Ô∏è Under 100 gems - everyone will be refunded
        </div>
      </div>
      
      <div class="text-sm text-red-200 mb-4">
        The winner (debater with most tips) will receive 50% of the pot.<br>
        This room will be closed and removed from /live.
      </div>
      
      <div class="flex gap-3">
        <button onclick="hideEndDebateModal()" class="flex-1 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-xl transition">
          Cancel
        </button>
        <button onclick="confirmEndDebate()" id="confirm-end-debate-btn" class="flex-1 py-3 bg-gradient-to-r from-red-500 to-red-600 hover:from-red-400 hover:to-red-500 text-white font-bold rounded-xl transition">
          üèÅ End Debate
        </button>
      </div>
    </div>
    
    <!-- Loading View -->
    <div id="end-debate-loading" class="hidden text-center py-8">
      <div class="text-5xl mb-4 animate-spin">‚è≥</div>
      <div class="text-xl font-bold text-white">Ending debate...</div>
      <div class="text-sm text-red-200 mt-2">Distributing pot to winner</div>
    </div>
    
    <!-- Results View (shown after API call) -->
    <div id="end-debate-results" class="hidden text-center">
      <div id="end-debate-result-icon" class="text-5xl mb-4">üèÜ</div>
      <h3 id="end-debate-result-title" class="text-2xl font-extrabold text-white mb-3">Debate Ended!</h3>
      
      <div id="end-debate-result-details" class="bg-black bg-opacity-30 rounded-xl p-4 mb-4">
        <!-- Populated by JS -->
      </div>
      
      <button onclick="closeEndDebateAndLeave()" class="w-full py-3 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-400 hover:to-green-500 text-white font-bold rounded-xl transition">
        ‚úì Got It
      </button>
    </div>
  </div>
</div>

<!-- Debate Winner Announcement Modal (shown to ALL users when debate ends) -->
<div id="winner-announcement-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-gradient-to-br from-purple-900 via-purple-800 to-pink-900 rounded-3xl p-6 max-w-md w-full shadow-2xl border-4 border-yellow-400 relative overflow-hidden">
    <!-- Sparkle effects -->
    <div class="absolute inset-0 overflow-hidden pointer-events-none">
      <div class="absolute top-4 left-4 text-4xl animate-bounce" style="animation-delay: 0s;">‚ú®</div>
      <div class="absolute top-8 right-8 text-3xl animate-bounce" style="animation-delay: 0.2s;">‚≠ê</div>
      <div class="absolute bottom-12 left-8 text-3xl animate-bounce" style="animation-delay: 0.4s;">üåü</div>
      <div class="absolute bottom-8 right-4 text-4xl animate-bounce" style="animation-delay: 0.6s;">‚ú®</div>
    </div>
    
    <!-- Content -->
    <div class="relative text-center">
      <div id="winner-icon" class="text-7xl mb-4 animate-pulse">üèÜ</div>
      <h2 id="winner-title" class="text-3xl font-extrabold text-white mb-3">Debate Over!</h2>
      
      <div id="winner-details" class="bg-black bg-opacity-30 rounded-xl p-5 mb-5">
        <!-- Populated by JS -->
        <div class="text-yellow-300 text-lg font-bold mb-2">Loading results...</div>
      </div>
      
      <div id="winner-message" class="text-sm text-purple-200 mb-5">
        Thanks for participating!
      </div>
      
      <button onclick="closeWinnerModal()" class="w-full py-3 bg-gradient-to-r from-yellow-400 to-yellow-500 hover:from-yellow-300 hover:to-yellow-400 text-black font-bold rounded-xl transition transform hover:scale-105">
        ‚úì Got It!
      </button>
    </div>
  </div>
</div>

<!-- Floating Tip Button (shown to non-hosts) -->
<button id="floating-tip-btn" onclick="openTipModal()" 
  class="hidden fixed bottom-24 right-6 z-50 bg-gold hover:bg-main-red text-charcoal hover:text-white p-4 rounded-full shadow-lg transition-all transform hover:scale-110"
  title="Send a tip to the host">
  <span class="text-2xl">üíé</span>
</button>

<!-- Floating Report Button (shown during calls) -->
<button id="floating-report-btn" onclick="showReportModal()" 
  class="hidden fixed bottom-24 left-6 z-50 bg-charcoal hover:bg-main-red text-white p-4 rounded-full shadow-lg transition-all transform hover:scale-110 opacity-70 hover:opacity-100"
  title="Report user">
  <span class="text-2xl">üö©</span>
</button>

<!-- Floating Block Button (shown during calls) -->
<button id="floating-block-btn" onclick="blockUser(otherParticipantId, otherParticipantName)" 
  class="hidden fixed bottom-40 left-6 z-50 bg-charcoal hover:bg-main-red text-white p-3 rounded-full shadow-lg transition-all transform hover:scale-110 opacity-70 hover:opacity-100"
  title="Block user (never match again)">
  <span class="text-xl">üö´</span>
</button>

<!-- Floating Bug Report Button (always visible for everyone) -->
<button id="floating-bug-btn" onclick="showBugReportModal()" 
  class="hidden fixed bottom-6 right-6 z-50 bg-charcoal hover:bg-gold text-white hover:text-charcoal p-3 rounded-full shadow-lg transition-all transform hover:scale-110 opacity-70 hover:opacity-100"
  title="Report a bug">
  <span class="text-xl">üêõ</span>
</button>

<!-- Session Limit / Upgrade Modal -->
<div id="upgrade-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-8 max-w-md w-full shadow-2xl border-4 border-gold relative overflow-hidden">
    <!-- Decorative background -->
    <div class="absolute inset-0 opacity-10 pointer-events-none" style="background: radial-gradient(circle at 30% 70%, #e63946 0%, transparent 50%), radial-gradient(circle at 70% 30%, #FFD166 0%, transparent 50%);"></div>
    
    <!-- Content -->
    <div class="relative z-10 text-center">
      <!-- Icon -->
      <div class="w-20 h-20 mx-auto mb-4 bg-gold rounded-full flex items-center justify-center">
        <span class="text-4xl">‚è∞</span>
      </div>
      
      <!-- Title -->
      <h2 id="upgrade-modal-title" class="text-2xl font-bold text-charcoal mb-2">Time's Up!</h2>
      
      <!-- Message -->
      <p id="upgrade-modal-message" class="text-charcoal mb-6">
        You've reached the <strong>60-minute limit</strong> on the Free plan.<br>
        Upgrade to Host Pro for <strong>3 hours</strong> of uninterrupted conversation!
      </p>
      
      <!-- Countdown -->
      <div id="upgrade-grace-countdown" class="mb-6 p-3 bg-rose rounded-xl">
        <p class="text-sm text-charcoal">Session ending in <strong id="grace-seconds">60</strong> seconds...</p>
      </div>
      
      <!-- Buttons -->
      <div class="flex flex-col gap-3">
        <a href="/pricing.html" target="_blank" class="w-full py-3 px-6 bg-gold text-charcoal font-bold rounded-full hover:bg-main-red hover:text-white transition-all text-center">
          ‚¨ÜÔ∏è Upgrade Now
        </a>
        <button onclick="endSessionFromUpgradeModal()" class="w-full py-3 px-6 bg-charcoal text-white font-bold rounded-full hover:bg-main-red transition-all">
          End Session
        </button>
      </div>
      
      <!-- Plan info -->
      <p class="mt-4 text-xs text-charcoal opacity-70">
        Current plan: <span id="upgrade-modal-plan" class="font-bold">Free</span>
      </p>
    </div>
  </div>
</div>

<!-- Branding Settings Modal (Pro Users) -->
<div id="branding-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-6 max-w-md w-full shadow-2xl border-4 border-gold relative">
    <!-- Close button -->
    <button onclick="closeBrandingModal()" class="absolute top-4 right-4 text-charcoal hover:text-main-red transition-colors">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Header -->
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-gold rounded-full flex items-center justify-center">
        <span class="text-3xl">üé®</span>
      </div>
      <h3 class="text-xl font-bold text-charcoal">Custom Branding</h3>
      <p class="text-charcoal opacity-70 text-sm">Personalize your sphere experience</p>
    </div>
    
    <!-- Current Badge Display -->
    <div class="rounded-2xl p-4 mb-4 border-2 border-rose" style="background: var(--bg-main);">
      <div class="flex items-center justify-between">
        <div>
          <p class="text-sm font-bold text-charcoal mb-1">Your Badge</p>
          <div class="flex items-center gap-2">
            <span id="branding-badge-emoji" class="text-2xl">‚≠ê</span>
            <span id="branding-badge-label" class="text-sm font-semibold text-charcoal">Host Pro</span>
          </div>
        </div>
        <label class="flex items-center gap-2 cursor-pointer">
          <span class="text-xs text-charcoal">Show badge</span>
          <input type="checkbox" id="badge-visible-toggle" checked class="w-5 h-5 accent-main-red">
        </label>
      </div>
    </div>
    
    <!-- Custom Logo Upload -->
    <div class="rounded-2xl p-4 mb-4 border-2 border-rose" style="background: var(--bg-main);">
      <p class="text-sm font-bold text-charcoal mb-3">Custom Logo</p>
      <p class="text-xs text-charcoal opacity-70 mb-3">Upload your logo to display on recordings (max 500KB)</p>
      
      <!-- Current Logo Preview -->
      <div id="logo-preview-container" class="hidden mb-3">
        <div class="flex items-center gap-3">
          <img id="logo-preview" src="" alt="Your logo" class="w-16 h-16 object-contain rounded-lg border-2 border-gold">
          <button onclick="removeLogo()" class="text-xs text-main-red hover:underline">Remove</button>
        </div>
      </div>
      
      <!-- Upload Button -->
      <label class="flex items-center justify-center gap-2 px-4 py-3 bg-gold hover:bg-main-red hover:text-white text-charcoal rounded-full font-bold cursor-pointer transition-all">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
        </svg>
        <span id="logo-upload-text">Upload Logo</span>
        <input type="file" id="logo-upload-input" accept="image/png,image/jpeg,image/gif" class="hidden" onchange="handleLogoUpload(event)">
      </label>
      
      <!-- Upload Status -->
      <p id="logo-upload-status" class="text-xs text-center mt-2 hidden"></p>
    </div>
    
    <!-- Not Pro Message (shown if user isn't pro) -->
    <div id="branding-upgrade-prompt" class="hidden bg-rose rounded-2xl p-4 text-center">
      <p class="text-sm font-bold text-charcoal mb-2">üîí Pro Feature</p>
      <p class="text-xs text-charcoal opacity-70 mb-3">Custom branding is available for Host Pro and Pro Bundle subscribers.</p>
      <a href="/pricing.html" class="inline-block px-4 py-2 bg-gold hover:bg-main-red hover:text-white text-charcoal rounded-full font-bold text-sm transition-all">
        Upgrade Now
      </a>
    </div>
    
    <!-- Save Button -->
    <button id="branding-save-btn" onclick="saveBrandingSettings()" class="w-full mt-4 px-6 py-3 bg-gold hover:bg-main-red hover:text-white text-charcoal rounded-full font-bold transition-all">
      Save Settings
    </button>
  </div>
</div>

<!-- Recording Consent Modal -->
<div id="recording-consent-modal" class="hidden fixed inset-0 z-50 modal-overlay flex items-center justify-center p-4">
  <div class="rounded-2xl p-6 max-w-md w-full shadow-2xl" style="background: var(--light-rose); border: 3px solid var(--rose);">
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center">
        <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M7 4V2a1 1 0 011-1h4a1 1 0 011 1v2h3a1 1 0 110 2h-1v9a2 2 0 01-2 2H7a2 2 0 01-2-2V6H4a1 1 0 110-2h3zM9 6v8a1 1 0 102 0V6a1 1 0 10-2 0z" clip-rule="evenodd"/>
        </svg>
      </div>
      <h3 class="text-xl font-bold text-charcoal dark:text-white mb-2">üé• Start Recording?</h3>
      <p class="text-gray-600 dark:text-gray-300 text-sm">This will record video, audio, screen shares, and chat messages for all participants.</p>
    </div>
    
    <div class="space-y-4 mb-6">
      <div>
        <label class="block text-sm font-semibold text-charcoal mb-2">Privacy Setting</label>
        <select id="recording-privacy" class="w-full px-3 py-2 text-base rounded-lg focus:ring-2 focus:ring-main-red text-charcoal" style="background: var(--bg-main); border: 2px solid var(--rose);">
          <option value="private">üîí Private (only participants can view)</option>
          <option value="public">üåê Public (anyone with link can view)</option>
        </select>
      </div>
      
      <div>
        <label class="block text-sm font-semibold text-charcoal mb-2">Auto-delete</label>
        <select id="recording-auto-delete" class="w-full px-3 py-2 text-base rounded-lg focus:ring-2 focus:ring-main-red text-charcoal" style="background: var(--bg-main); border: 2px solid var(--rose);">
          <option value="never">Never delete</option>
          <option value="7">Delete after 7 days</option>
          <option value="30">Delete after 30 days</option>
          <option value="90">Delete after 90 days</option>
        </select>
      </div>
    </div>
    
    <div class="flex space-x-3">
      <button onclick="cancelRecording()" class="flex-1 px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg font-semibold">Cancel</button>
      <button onclick="confirmRecording()" class="flex-1 px-4 py-2 bg-main-red text-white hover:bg-red-600 rounded-lg font-semibold">Start Recording</button>
    </div>
  </div>
</div>

<!-- Waiting Overlay -->
<div id="waiting-overlay">
  <div class="mb-4">
    <svg viewBox="0 0 64 64" width="64" height="64" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="6"/>
      <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="6"/>
      <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
      <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
    </svg>
  </div>
  <div class="text-2xl mb-2">üê±‚ú®</div>
  <div class="waiting-title">preparing your sphere</div>
  <div class="waiting-subtitle" id="waiting-mode">joining room...</div>
  <div class="status-badge">
    Connecting<span class="loading-dots"></span>
  </div>
  
  <div style="margin-top: 1rem; font-size: 0.85rem; color: #222;">
    <strong>Topic:</strong> <span id="topic-text">Loading...</span><br>
    <strong>Description:</strong> <span id="topic-description">Please wait...</span>
  </div>
</div>

<!-- Main Video Chat Interface -->
<div id="video-interface" class="hidden">
  <!-- Header -->
  <header class="video-header" style="background: var(--light-rose); border-bottom: 2px solid var(--rose); padding: 0.75rem 1rem;">
    <div class="max-w-7xl mx-auto flex items-center justify-between">
      <!-- Logo - Links to main site -->
      <div class="flex items-center space-x-3">
        <a href="https://www.chatspheres.com" class="flex items-center space-x-2 hover:opacity-80 transition-opacity" title="Go to ChatSpheres Home">
          <svg viewBox="0 0 64 64" width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="24" cy="32" r="20" stroke="#FCE2E5" stroke-width="6"/>
            <circle cx="40" cy="32" r="20" stroke="#FCE2E5" stroke-width="6"/>
            <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
            <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
          </svg>
          <span class="text-xl font-extrabold" style="color: var(--charcoal);">ChatSpheres</span>
        </a>
        
        <!-- Gem Balance (shown when logged in) -->
        <div id="header-gem-balance" class="hidden items-center gap-1 px-3 py-1 rounded-full cursor-pointer transition-colors" style="background: var(--gold);" onclick="window.location.href='/cashout.html'" title="Your gem balance - Click to cash out">
          <span>üíé</span>
          <span id="gem-count" class="text-sm font-bold" style="color: var(--charcoal);">0</span>
        </div>
        
        <!-- Hamburger Menu Toggle (always visible) -->
        <button id="video-menu-toggle" onclick="toggleVideoMenu()" class="ml-2 p-2 rounded-lg transition-colors hover:opacity-80" style="background: var(--gold);" aria-label="Toggle menu">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: var(--charcoal);">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16M4 18h16"/>
          </svg>
        </button>
        
        <!-- User Role Badge -->
        <div id="user-role-badge" class="hidden px-3 py-1 rounded-full text-xs font-bold">
          <span id="role-text">participant</span>
        </div>
        
        <!-- Live Indicator -->
        <div id="live-indicator" class="hidden flex items-center space-x-2 bg-main-red text-white px-3 py-1 rounded-full text-xs font-bold">
          <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
          <span>LIVE</span>
          <span id="viewer-count">0</span>
          <span>üëÅÔ∏è</span>
        </div>
        
          <!-- Recording Indicator -->
          <div id="recording-status" class="hidden bg-red-600 text-white px-3 py-2 rounded-2xl text-xs font-bold space-y-1">
            <div class="flex items-center space-x-2">
              <div class="recording-dot w-2 h-2 bg-white rounded-full"></div>
              <span id="recording-mode-label">REC</span>
              <span id="recording-upload-status" class="recording-upload-status hidden">
                <span id="recording-upload-label">uploading</span>
                <span id="recording-upload-percent">0%</span>
              </span>
            </div>
            <div id="recording-upload-bar" class="recording-upload-bar hidden">
              <div id="recording-upload-bar-fill" class="recording-upload-bar-fill"></div>
            </div>
          </div>
          <div id="recording-download-container" class="hidden bg-white text-charcoal dark:bg-gray-800 dark:text-white px-3 py-2 rounded-2xl text-xs font-semibold space-y-1 shadow-sm border border-gray-200 dark:border-gray-700">
            <div id="recording-download-message" class="flex items-center gap-2">
              <span>üìº Recording link</span>
              <span id="recording-download-status-text" class="text-gray-500 dark:text-gray-300">Preparing...</span>
            </div>
            <div class="flex flex-wrap gap-2">
              <a id="recording-download-link" href="#" target="_blank" class="px-3 py-1 rounded-full bg-main-red text-white transition disabled:opacity-50 disabled:cursor-not-allowed pointer-events-none opacity-50">Open</a>
              <button id="copy-recording-link" class="px-3 py-1 rounded-full border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition" type="button" disabled>
                Copy link
              </button>
            </div>
          </div>
          
          <!-- PROMINENT SHARE BUTTON IN HEADER -->
          <button id="header-share-btn" onclick="openShareModal()" class="cta-btn flex items-center gap-2 px-5 py-2 font-bold text-sm shadow-lg hover:shadow-xl transition-all hover:scale-105" title="Share room link">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"/>
            </svg>
            <span>Share</span>
          </button>
      </div>
      
      <!-- Timer -->
        <div class="flex items-center space-x-3">
        <div class="timer-glow bg-main-red text-white px-4 py-2 rounded-full font-bold text-lg">
          <span id="timer-header">60:00</span>
        </div>
          <div class="hidden sm:flex flex-col leading-tight">
            <span id="timer-header-subtitle" class="text-sm text-gray-600 dark:text-gray-300">time remaining</span>
            <span id="minutes-used-header-wrapper" class="text-xs text-gray-500 dark:text-gray-400">minutes used: <span id="minutes-used-header">0</span></span>
          </div>
      </div>
    </div>
  </header>
  
  <!-- Slide-out Navigation Menu -->
  <div id="video-mobile-nav" class="hidden fixed inset-0 z-[100]">
    <div class="absolute inset-0 bg-charcoal/70 backdrop-blur-sm" onclick="toggleVideoMenu()"></div>
    <nav class="absolute right-0 top-0 h-full w-80 max-w-[90vw] overflow-y-auto shadow-2xl" style="background: var(--light-rose);">
      <!-- Nav Header -->
      <div class="flex items-center justify-between p-4" style="border-bottom: 2px solid var(--rose);">
        <div class="flex items-center gap-2">
          <svg viewBox="0 0 64 64" width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="3" fill="none"/>
            <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="3" fill="none"/>
          </svg>
          <span class="font-bold" style="color: var(--charcoal);">Menu</span>
        </div>
        <button onclick="toggleVideoMenu()" class="p-2 rounded-lg transition-colors" style="background: var(--rose); color: var(--charcoal);">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      
      <!-- Nav Links -->
      <div class="p-4 space-y-1">
        <a href="/" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal); background: var(--rose);">
          <span>üîÆ</span> Video Chat
        </a>
        <a href="/matchmaking.html" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üéØ</span> Find Match
        </a>
        <a href="/recordings.html" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üìπ</span> Recordings
        </a>
        <a href="/pricing.html" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üíé</span> Pricing
        </a>
        
        <div style="height: 2px; background: var(--rose); margin: 1rem 0;"></div>
        
        <a href="/profile.html" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üë§</span> Profile
        </a>
        <a href="/cashout.html" class="flex items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üí∞</span> Cash Out
        </a>
        <a href="/branding.html" id="mobile-branding-link" class="hidden items-center gap-3 px-4 py-3 rounded-xl font-semibold transition hover:translate-x-1" style="color: var(--charcoal);">
          <span>üé®</span> Branding
        </a>
      </div>
      
      <!-- User Section -->
      <div class="absolute bottom-0 left-0 right-0 p-4" style="background: var(--rose); border-top: 2px solid var(--gold);">
        <!-- Guest State -->
        <div id="mobile-auth-guest" class="space-y-3">
          <button onclick="showAuthModal(); toggleVideoMenu();" class="w-full px-4 py-3 rounded-full font-bold transition hover:scale-[1.02]" style="background: var(--gold); color: var(--charcoal);">
            Sign In
          </button>
          <a href="https://www.chatspheres.com/sign-up/" class="block w-full px-4 py-3 rounded-full font-bold text-center transition hover:scale-[1.02]" style="background: var(--main-red); color: var(--light-rose); text-decoration: none;">
            Sign Up
          </a>
        </div>
        
        <!-- Logged In State -->
        <div id="mobile-auth-user" class="hidden space-y-3">
          <div class="flex items-center gap-3 px-4 py-3 rounded-xl" style="background: var(--light-rose);">
            <div class="w-10 h-10 rounded-full flex items-center justify-center text-lg" style="background: var(--gold);">üë§</div>
            <div>
              <div id="mobile-username" class="font-bold" style="color: var(--charcoal);">User</div>
              <div class="text-sm flex items-center gap-1" style="color: var(--charcoal); opacity: 0.7;">
                <span>üíé</span>
                <span id="mobile-gem-count">0</span> gems
              </div>
            </div>
          </div>
          <button onclick="signOut(); toggleVideoMenu();" class="w-full px-4 py-3 rounded-full font-bold transition hover:scale-[1.02]" style="background: var(--charcoal); color: var(--light-rose);">
            Sign Out
          </button>
        </div>
      </div>
    </nav>
  </div>

  <div class="max-w-7xl mx-auto px-4 py-6" style="background: var(--bg-main);">
    <!-- Topic Section -->
    <div class="mb-6 text-center">
      <div class="topic-badge inline-block px-6 py-3 rounded-full font-bold text-lg mb-3">
        üåü <span id="topic-display">Loading Topic...</span>
      </div>
      <p class="text-charcoal dark:text-gray-300 text-base max-w-2xl mx-auto" id="topic-desc-display">
        Loading description...
      </p>
    </div>

    <!-- Main Content Grid - Both modes now have chat -->
    <div id="participant-layout" class="grid lg:grid-cols-4 gap-6">
      <!-- Video Section -->
      <div class="lg:col-span-3 space-y-4">
        <!-- Remote Video -->
        <div class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video chatspheres-pattern">
          <video id="remote-video" class="w-full h-full object-cover hidden" autoplay playsinline webkit-playsinline></video>
          <video id="screen-share-video" class="w-full h-full object-cover hidden" autoplay playsinline webkit-playsinline></video>
          
          <!-- Fullscreen Button -->
          <button class="fullscreen-btn" onclick="toggleFullscreen('remote-video')" title="Expand video">
            <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
              <path d="M3 3a1 1 0 000 2h2.586L2.293 8.293a1 1 0 101.414 1.414L7 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1H3zM17 3a1 1 0 100 2h-2.586l3.293 3.293a1 1 0 01-1.414 1.414L13 6.414V9a1 1 0 11-2 0V4a1 1 0 011-1h5z"/>
            </svg>
          </button>
          
          <div id="remote-placeholder" class="absolute inset-0 flex items-center justify-center video-placeholder">
            <svg class="vesica-accent" viewBox="0 0 64 64" width="120" height="120" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="3"/>
              <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="3"/>
              <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="2" fill="none"/>
              <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="2" fill="none"/>
            </svg>
            
            <div class="text-center text-white relative z-10">
              <div class="w-16 h-16 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg">
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              </div>
              <p class="font-bold text-lg text-white">Waiting for your chat partner...</p>
              <p class="text-sm text-gold mt-1">üê± They might be as curious as a cat about this topic!</p>
              <!-- Reload hint for participants only -->
              <p id="video-reload-hint" class="hidden text-xs text-rose mt-3 opacity-80">
                üì∫ Video not loading? Try <button onclick="location.reload()" class="underline hover:text-white">refreshing the page</button>
              </p>
            </div>
          </div>

          <!-- Participant Info -->
          <div id="remote-info" class="absolute top-4 left-4 bg-main-red text-white px-4 py-2 rounded-full text-sm font-semibold shadow-lg flex items-center gap-1.5">
            <span id="remote-badge" class="hidden"></span>
            <span id="remote-name">Guest</span>
          </div>
        </div>

        <!-- Local Video (hidden for spectators) -->
        <div id="local-video-container" class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video sm:aspect-[4/3] lg:aspect-video chatspheres-pattern">
          <video id="local-video" class="w-full h-full object-cover scale-x-[-1]" autoplay playsinline muted></video>
          
          <div id="local-placeholder" class="absolute inset-0 flex items-center justify-center video-placeholder">
            <svg class="vesica-accent" viewBox="0 0 64 64" width="80" height="80" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="2"/>
              <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="2"/>
              <circle cx="24" cy="32" r="18" stroke="#FFD166" stroke-width="2" fill="none"/>
              <circle cx="40" cy="32" r="18" stroke="#FFD166" stroke-width="2" fill="none"/>
            </svg>
            
            <div class="text-center text-white relative z-10">
              <div class="w-12 h-12 mx-auto mb-3 bg-gold rounded-full flex items-center justify-center shadow-lg">
                <svg class="w-6 h-6 text-charcoal" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              </div>
              <p class="font-bold text-gold">You</p>
            </div>
          </div>

          <!-- Enhanced Controls (hidden for spectators) -->
          <div id="participant-controls" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2">
            <button id="mic-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-main-red text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="camera-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-main-red text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"/>
              </svg>
            </button>
            <button id="screen-share-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-gold text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zm2 3a1 1 0 000 2h.01a1 1 0 100-2H5zm3 0a1 1 0 000 2h.01a1 1 0 100-2H8zm3 0a1 1 0 000 2h.01a1 1 0 100-2H11z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="record-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-red-600 text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="settings-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-gold text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/>
              </svg>
            </button>
            <button id="share-btn" class="control-btn bg-charcoal bg-opacity-80 hover:bg-emerald-500 text-white p-3 rounded-full shadow-lg" title="Share room link">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"/>
              </svg>
            </button>
            <button id="leave-btn" class="control-btn bg-main-red hover:bg-red-600 text-white p-3 rounded-full shadow-lg">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 1.414L9.586 11l-2.293 2.293a1 1 0 001.414 1.414L10 12.414l1.293 1.293a1 1 0 001.414-1.414L11.414 11l2.293-2.293z" clip-rule="evenodd"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Device Settings Panel -->
        <div id="settings-panel" class="hidden bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <h3 class="text-lg font-bold text-charcoal dark:text-white mb-4">üéõÔ∏è Device Settings</h3>
          
          <div class="grid md:grid-cols-2 gap-4">
            <div>
              <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">üìπ Camera</label>
              <select id="camera-selector" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
                <option disabled selected>Select camera...</option>
              </select>
            </div>
            
            <div>
              <label class="block text-sm font-semibold text-charcoal dark:text-white mb-2">üé§ Microphone</label>
              <select id="mic-selector" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red bg-white dark:bg-gray-700 text-charcoal dark:text-white">
                <option disabled selected>Select microphone...</option>
              </select>
            </div>
          </div>
          
          <div class="mt-4 text-center">
            <button id="close-settings" class="new-spark-btn px-6 py-2 rounded-full font-bold text-sm">Close Settings</button>
          </div>
        </div>
      </div>

      <!-- Live Chat and Sparks Sidebar -->
      <div class="lg:col-span-1 space-y-6">
        
        <!-- RED ROOM POT DISPLAY (Visible to all in Red Rooms) -->
        <div id="red-room-pot-panel" class="hidden bg-gradient-to-br from-red-600 to-red-800 rounded-2xl shadow-lg border-2 border-red-400 overflow-hidden">
          <!-- Pot Header -->
          <div class="p-3 bg-black bg-opacity-30">
            <div class="flex items-center justify-between">
              <h3 class="font-extrabold text-white flex items-center gap-2 text-sm">
                üî¥ <span>RED ROOM</span>
              </h3>
              <span class="bg-red-500 text-white text-xs px-2 py-1 rounded-full font-bold animate-pulse">LIVE DEBATE</span>
            </div>
          </div>
          
          <!-- LIVE SCOREBOARD - Who's Winning -->
          <div id="debate-scoreboard" class="p-4 bg-black bg-opacity-20">
            <div class="text-xs text-center text-red-200 mb-3 font-bold">‚öîÔ∏è BATTLE FOR THE POT ‚öîÔ∏è</div>
            
            <!-- Participant 1 Score -->
            <div id="debater-1-row" class="mb-2">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-2">
                  <span id="debater-1-crown" class="hidden">üëë</span>
                  <span id="debater-1-name" class="text-white font-bold text-sm truncate max-w-24">Waiting...</span>
                </div>
                <span id="debater-1-tips" class="text-yellow-300 font-bold">üíé 0</span>
              </div>
              <div class="w-full bg-black bg-opacity-40 rounded-full h-3 overflow-hidden">
                <div id="debater-1-bar" class="h-full bg-gradient-to-r from-yellow-400 to-yellow-500 transition-all duration-500 rounded-full" style="width: 0%"></div>
              </div>
            </div>
            
            <!-- VS Divider -->
            <div class="text-center my-2">
              <span class="text-white font-extrabold text-lg">VS</span>
            </div>
            
            <!-- Participant 2 Score -->
            <div id="debater-2-row" class="mb-2">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-2">
                  <span id="debater-2-crown" class="hidden">üëë</span>
                  <span id="debater-2-name" class="text-white font-bold text-sm truncate max-w-24">Waiting...</span>
                </div>
                <span id="debater-2-tips" class="text-yellow-300 font-bold">üíé 0</span>
              </div>
              <div class="w-full bg-black bg-opacity-40 rounded-full h-3 overflow-hidden">
                <div id="debater-2-bar" class="h-full bg-gradient-to-r from-blue-400 to-blue-500 transition-all duration-500 rounded-full" style="width: 0%"></div>
              </div>
            </div>
          </div>
          
          <!-- Total Pot Display -->
          <div class="p-4 text-center bg-black bg-opacity-10">
            <div class="text-xs text-red-200 mb-1">üí∞ TOTAL POT</div>
            <div id="pot-amount-display" class="text-3xl font-extrabold text-white mb-1">üíé 0</div>
            <div class="text-xs text-red-200">Winner takes 50%</div>
          </div>
          
          <!-- Tip to Pot Buttons (Spectators Only) -->
          <div id="pot-tip-section" class="p-4 bg-black bg-opacity-20">
            <div class="text-xs text-yellow-300 text-center mb-2">üëÅÔ∏è Pick your champion and tip!</div>
            <div class="text-xs text-red-200 text-center mb-3">Your balance: <span id="pot-tip-balance">üíé 0</span></div>
            
            <!-- Select who to tip -->
            <div id="pot-tip-targets" class="grid grid-cols-2 gap-2 mb-3">
              <!-- Populated dynamically with participant names -->
            </div>
            
            <!-- Tip amounts -->
            <div class="grid grid-cols-4 gap-2">
              <button onclick="tipToPot(10)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé10</button>
              <button onclick="tipToPot(25)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé25</button>
              <button onclick="tipToPot(50)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé50</button>
              <button onclick="tipToPot(100)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé100</button>
            </div>
          </div>
          
          <!-- Participant Message -->
          <div id="pot-participant-message" class="p-4 bg-black bg-opacity-20 hidden">
            <div class="text-center">
              <div class="text-yellow-300 font-bold mb-1">üé§ You're in the ring!</div>
              <div class="text-xs text-red-200">Spectators are betting on you. Make your case!</div>
            </div>
          </div>
          
          <!-- Void Rule Warning -->
          <div class="p-2 bg-black bg-opacity-40 text-center">
            <div class="text-xs text-red-300">
              ‚ö†Ô∏è Void Rule: Pot under 100üíé = full refund
            </div>
          </div>
          
          <!-- End Debate Button (Host Only - Red Rooms) -->
          <div id="end-debate-section" class="p-3 bg-black bg-opacity-30 hidden">
            <button 
              id="end-debate-btn"
              onclick="showEndDebateConfirm()"
              class="w-full py-2 bg-gradient-to-r from-gray-700 to-gray-800 hover:from-gray-600 hover:to-gray-700 text-white font-bold rounded-lg text-sm transition transform hover:scale-102 border border-gray-500"
            >
              üèÅ End Debate & Distribute Pot
            </button>
          </div>
        </div>
        
        <!-- End Session Button (Host Only - Green Rooms) -->
        <div id="end-session-section" class="mt-4 hidden">
          <button 
            id="end-session-btn"
            onclick="confirmEndGreenRoom()"
            class="w-full py-3 bg-gradient-to-r from-green-700 to-green-800 hover:from-green-600 hover:to-green-700 text-white font-bold rounded-lg text-sm transition transform hover:scale-102 border-2 border-green-400 shadow-lg"
          >
            üèÅ End Help Session
          </button>
          <p class="text-xs text-gray-400 text-center mt-1">This will close the room for all participants</p>
        </div>
        
        <!-- VOTING PANEL (Shown when debate ends) -->
        <div id="voting-panel" class="hidden bg-gradient-to-br from-purple-600 to-purple-800 rounded-2xl shadow-lg border-2 border-purple-400 p-6">
          <div class="text-center">
            <div class="text-3xl mb-2">üó≥Ô∏è</div>
            <h3 class="text-xl font-extrabold text-white mb-4">Who Won?</h3>
            <div id="vote-options" class="space-y-3">
              <!-- Populated dynamically -->
            </div>
            <button onclick="voteForDraw()" class="mt-4 w-full py-2 bg-gray-500 hover:bg-gray-400 text-white font-bold rounded-lg transition">
              ü§ù It's a Draw
            </button>
          </div>
        </div>
        
        <!-- Live Chat (also for participants) -->
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col">
          <!-- Chat Header -->
          <div class="p-4 border-b border-gray-200 dark:border-gray-600">
            <div class="flex items-center justify-between">
              <h3 class="font-bold text-charcoal dark:text-white">üí¨ Live Chat</h3>
              <div class="text-xs text-gray-500 dark:text-gray-400">
                <span id="participant-chat-viewer-count">0</span> viewers
              </div>
            </div>
          </div>

          <!-- Chat Messages -->
          <div id="participant-chat-messages" class="flex-1 overflow-y-auto p-4 space-y-3 live-chat" style="height: 250px;">
            <!-- Welcome message -->
            <div class="text-center text-xs text-gray-500 dark:text-gray-400 py-2">
              Welcome to the chat! üëã
            </div>
          </div>

          <!-- Chat Input -->
          <div class="p-4 border-t border-gray-200 dark:border-gray-600">
            <div class="flex space-x-2">
              <input 
                type="text" 
                id="participant-chat-input"
                placeholder="Type a message..."
                maxlength="200"
                class="flex-1 px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                id="participant-send-chat"
                onclick="sendParticipantChatMessage()"
                class="bg-main-red hover:bg-red-600 text-white p-2 rounded-lg transition-colors"
              >
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"/>
                </svg>
              </button>
            </div>
            <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
              <span id="participant-char-count">0</span>/200 characters
            </div>
          </div>
        </div>

        <!-- Conversation Sparks -->
        <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <!-- Header -->
          <div class="flex items-center justify-between mb-6">
            <h3 class="text-lg font-bold text-charcoal dark:text-white flex items-center">
              ‚ú® conversation sparks
            </h3>
            <button 
              id="newSparkBtn" 
              class="new-spark-btn px-4 py-2 rounded-full font-bold text-sm"
              onclick="generateNewSparks()"
            >
              üîÑ new spark
            </button>
          </div>

          <!-- Single Conversation Spark -->
          <div id="sparksContainer">
            <div class="relative">
              <!-- Main Spark Display -->
              <div id="currentSpark" class="bg-gradient-to-br from-light-rose to-rose p-6 rounded-2xl shadow-lg border-2 border-transparent hover:border-main-red transition-all cursor-pointer" onclick="selectCurrentSpark()">
                <div class="flex items-start justify-between mb-3">
                  <div class="bg-main-red text-white px-3 py-1 rounded-full text-xs font-bold">
                    SPARK #<span id="sparkNumber">1</span>
                  </div>
                  <div class="text-main-red">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                    </svg>
                  </div>
                </div>
                <blockquote class="text-charcoal font-bold text-base leading-relaxed italic">
                  "<span id="sparkText">If you could have a conversation with your future self from 10 years from now, what would you want to ask them about the choices you're making today?</span>"
                </blockquote>
                <div class="mt-4 text-center">
                  <span class="text-xs text-charcoal font-semibold opacity-70">üëÜ Click to highlight for both users</span>
                </div>
              </div>

              <!-- Navigation Controls -->
              <div class="flex justify-between items-center mt-4">
                <button 
                  id="prevSparkBtn"
                  onclick="navigateSpark('prev')" 
                  class="flex items-center space-x-2 bg-gold hover:bg-main-red text-charcoal hover:text-white px-4 py-2 rounded-full font-bold text-sm transition-all"
                >
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"/>
                  </svg>
                  <span>Previous</span>
                </button>
                
                <div class="flex space-x-2">
                  <span id="sparkDot1" class="w-2 h-2 bg-main-red rounded-full transition-all"></span>
                  <span id="sparkDot2" class="w-2 h-2 bg-gray-300 rounded-full transition-all"></span>
                  <span id="sparkDot3" class="w-2 h-2 bg-gray-300 rounded-full transition-all"></span>
                </div>
                
                <button 
                  id="nextSparkBtn"
                  onclick="navigateSpark('next')" 
                  class="flex items-center space-x-2 bg-gold hover:bg-main-red text-charcoal hover:text-white px-4 py-2 rounded-full font-bold text-sm transition-all"
                >
                  <span>Next</span>
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <!-- User Prompts Section -->
          <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-600">
            <h4 class="text-sm font-bold text-charcoal dark:text-white mb-3">Custom Spark Request</h4>
            <div class="space-y-3">
              <input 
                type="text" 
                id="userPrompt"
                placeholder="e.g., 'questions about career changes'"
                class="w-full px-4 py-3 text-base border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                onclick="generateCustomSparks()" 
                class="w-full new-spark-btn py-3 rounded-xl font-bold text-sm"
              >
                ‚ö° Generate Custom Sparks
              </button>
            </div>
          </div>

          <!-- Fun Facts -->
          <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-600">
            <div class="text-center text-xs text-gray-500 dark:text-gray-400">
              <p>üí° Like a Pok√©mon evolving through battles,</p>
              <p>great conversations evolve through curiosity!</p>
            </div>
          </div>
        </div>
        
        <!-- Sidebar Ad (non-intrusive, below content) -->
        <div class="chatspheres-ad-container chatspheres-ad-sidebar" id="sidebar-ad" style="margin-top: var(--space-md, 1rem);">
          <ins class="adsbygoogle chatspheres-ad"
               style="display:block"
               data-ad-client="ca-pub-8986841930339200"
               data-ad-format="rectangle"
               data-full-width-responsive="true"></ins>
        </div>
      </div>
    </div>

    <!-- Spectator Layout -->
    <div id="spectator-layout" class="hidden grid lg:grid-cols-4 gap-6">
      <!-- Main Video (3/4 width) -->
      <div class="lg:col-span-3 space-y-4">
        <!-- Simple 2-Participant View for Spectators -->
        <div class="space-y-4">
          <!-- Main Conversation Area - Both Participants -->
          <div class="relative bg-charcoal rounded-2xl overflow-hidden aspect-video chatspheres-pattern">
            <!-- Screen Share Video (takes full space when active) -->
            <video id="spectator-screen-share" class="w-full h-full object-cover hidden" autoplay playsinline></video>
            
            <!-- Two-Participant Layout -->
            <div id="spectator-participants-container" class="w-full h-full grid grid-cols-2 gap-1">
              <!-- Participant 1 -->
              <div class="relative bg-charcoal">
                <video id="spectator-participant-1" class="w-full h-full object-cover hidden" autoplay playsinline></video>
                <div id="spectator-placeholder-1" class="absolute inset-0 flex items-center justify-center video-placeholder">
                  <div class="text-center text-white">
                    <div class="w-12 h-12 mx-auto mb-2 bg-main-red rounded-full flex items-center justify-center">
                      <span class="text-white font-bold">1</span>
                    </div>
                    <p class="text-sm">Waiting for participant...</p>
                  </div>
                </div>
                <div id="spectator-name-1" class="absolute bottom-2 left-2 bg-main-red text-white px-2 py-1 rounded text-sm font-semibold hidden flex items-center gap-1">
                  <span id="spectator-badge-1" class="hidden"></span>
                  <span id="spectator-name-text-1">Participant 1</span>
                </div>
              </div>
              
              <!-- Participant 2 -->
              <div class="relative bg-charcoal">
                <video id="spectator-participant-2" class="w-full h-full object-cover hidden" autoplay playsinline></video>
                <div id="spectator-placeholder-2" class="absolute inset-0 flex items-center justify-center video-placeholder">
                  <div class="text-center text-white">
                    <div class="w-12 h-12 mx-auto mb-2 bg-gold rounded-full flex items-center justify-center">
                      <span class="text-charcoal font-bold">2</span>
                    </div>
                    <p class="text-sm">Waiting for participant...</p>
                  </div>
                </div>
                <div id="spectator-name-2" class="absolute bottom-2 left-2 bg-gold text-charcoal px-2 py-1 rounded text-sm font-semibold hidden flex items-center gap-1">
                  <span id="spectator-badge-2" class="hidden"></span>
                  <span id="spectator-name-text-2">Participant 2</span>
                </div>
              </div>
            </div>
            
            <!-- Expand Button for Participants View -->
            <button id="expand-participants-btn" class="expand-button" onclick="toggleSpectatorExpansion('participants')" style="display: none;">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
              </svg>
              EXPAND
            </button>

            <!-- Expand Button for Screen Share -->
            <button id="expand-screenshare-btn" class="expand-button" onclick="toggleSpectatorExpansion('screenshare')" style="display: none;">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 15a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1v-2z"/>
              </svg>
              EXPAND
            </button>
            
            <!-- Click to Enable Overlay -->
            <div id="spectator-click-overlay" class="absolute inset-0 flex items-center justify-center video-placeholder cursor-pointer transition-all hover:bg-opacity-80 spectator-overlay-force-visible" onclick="enableSpectatorVideo()" style="z-index: 9999 !important; display: flex !important; opacity: 1 !important; visibility: visible !important; pointer-events: auto !important;"
              <div class="text-center text-white">
                <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
                  <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
                  </svg>
                </div>
                <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
                <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
                <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
                  üëÜ Click Here to Enable Video
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Spectator Notice -->
        <div class="bg-gradient-to-r from-light-rose to-rose rounded-xl p-4 border border-rose">
          <div class="flex items-center space-x-3">
            <div class="text-2xl">üëÄ</div>
            <div>
              <h3 class="font-bold text-charcoal mb-1">You're watching as a spectator</h3>
              <p class="text-sm text-charcoal opacity-80">Enjoy the conversation and share your thoughts in the live chat!</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Spectator Sidebar (1/4 width) -->
      <div class="lg:col-span-1 space-y-4">
        
        <!-- RED ROOM POT DISPLAY FOR SPECTATORS -->
        <div id="spectator-red-room-pot-panel" class="hidden bg-gradient-to-br from-red-600 to-red-800 rounded-2xl shadow-lg border-2 border-red-400 overflow-hidden">
          <!-- Pot Header -->
          <div class="p-3 bg-black bg-opacity-30">
            <div class="flex items-center justify-between">
              <h3 class="font-extrabold text-white flex items-center gap-2 text-sm">
                üî¥ <span>RED ROOM</span>
              </h3>
              <span class="bg-red-500 text-white text-xs px-2 py-1 rounded-full font-bold animate-pulse">LIVE DEBATE</span>
            </div>
          </div>
          
          <!-- LIVE SCOREBOARD -->
          <div id="spectator-debate-scoreboard" class="p-4 bg-black bg-opacity-20">
            <div class="text-xs text-center text-red-200 mb-3 font-bold">‚öîÔ∏è BATTLE FOR THE POT ‚öîÔ∏è</div>
            
            <!-- Participant 1 Score -->
            <div class="mb-2">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-2">
                  <span id="spectator-debater-1-crown" class="hidden">üëë</span>
                  <span id="spectator-debater-1-name" class="text-white font-bold text-sm truncate max-w-24">Waiting...</span>
                </div>
                <span id="spectator-debater-1-tips" class="text-yellow-300 font-bold">üíé 0</span>
              </div>
              <div class="w-full bg-black bg-opacity-40 rounded-full h-3 overflow-hidden">
                <div id="spectator-debater-1-bar" class="h-full bg-gradient-to-r from-yellow-400 to-yellow-500 transition-all duration-500 rounded-full" style="width: 0%"></div>
              </div>
            </div>
            
            <!-- VS Divider -->
            <div class="text-center my-2">
              <span class="text-white font-extrabold text-lg">VS</span>
            </div>
            
            <!-- Participant 2 Score -->
            <div class="mb-2">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-2">
                  <span id="spectator-debater-2-crown" class="hidden">üëë</span>
                  <span id="spectator-debater-2-name" class="text-white font-bold text-sm truncate max-w-24">Waiting...</span>
                </div>
                <span id="spectator-debater-2-tips" class="text-yellow-300 font-bold">üíé 0</span>
              </div>
              <div class="w-full bg-black bg-opacity-40 rounded-full h-3 overflow-hidden">
                <div id="spectator-debater-2-bar" class="h-full bg-gradient-to-r from-blue-400 to-blue-500 transition-all duration-500 rounded-full" style="width: 0%"></div>
              </div>
            </div>
          </div>
          
          <!-- Total Pot Display -->
          <div class="p-4 text-center bg-black bg-opacity-10">
            <div class="text-xs text-red-200 mb-1">üí∞ TOTAL POT</div>
            <div id="spectator-pot-amount-display" class="text-3xl font-extrabold text-white mb-1">üíé 0</div>
            <div class="text-xs text-red-200">Winner takes 50%</div>
          </div>
          
          <!-- Tip to Pot Buttons -->
          <div id="spectator-pot-tip-section" class="p-4 bg-black bg-opacity-20">
            <div class="text-xs text-yellow-300 text-center mb-2">üëÅÔ∏è Pick your champion and tip!</div>
            <div class="text-xs text-red-200 text-center mb-3">Your balance: <span id="spectator-pot-tip-balance">üíé 0</span></div>
            
            <!-- Select who to tip -->
            <div id="spectator-pot-tip-targets" class="grid grid-cols-2 gap-2 mb-3">
              <!-- Populated dynamically -->
            </div>
            
            <!-- Tip amounts -->
            <div class="grid grid-cols-4 gap-2">
              <button onclick="tipToPot(10)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé10</button>
              <button onclick="tipToPot(25)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé25</button>
              <button onclick="tipToPot(50)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé50</button>
              <button onclick="tipToPot(100)" class="bg-yellow-400 hover:bg-yellow-300 text-black font-bold py-2 rounded-lg text-sm transition transform hover:scale-105">üíé100</button>
            </div>
          </div>
          
          <!-- Void Rule Warning -->
          <div class="p-2 bg-black bg-opacity-40 text-center">
            <div class="text-xs text-red-300">
              ‚ö†Ô∏è Void Rule: Pot under 100üíé = full refund
            </div>
          </div>
        </div>
        
        <!-- SPECTATOR VOTING PANEL -->
        <div id="spectator-voting-panel" class="hidden bg-gradient-to-br from-purple-600 to-purple-800 rounded-2xl shadow-lg border-2 border-purple-400 p-6">
          <div class="text-center">
            <div class="text-3xl mb-2">üó≥Ô∏è</div>
            <h3 class="text-xl font-extrabold text-white mb-4">Who Won?</h3>
            <div id="spectator-vote-options" class="space-y-3">
              <!-- Populated dynamically -->
            </div>
            <button onclick="voteForDraw()" class="mt-4 w-full py-2 bg-gray-500 hover:bg-gray-400 text-white font-bold rounded-lg transition">
              ü§ù It's a Draw
            </button>
          </div>
        </div>
        
        <!-- Live Chat -->
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col">
          <!-- Chat Header -->
          <div class="p-4 border-b border-gray-200 dark:border-gray-600">
            <div class="flex items-center justify-between">
              <h3 class="font-bold text-charcoal dark:text-white">üí¨ Live Chat</h3>
              <div class="text-xs text-gray-500 dark:text-gray-400">
                <span id="chat-viewer-count">0</span> viewers
              </div>
            </div>
          </div>

          <!-- Chat Messages -->
          <div id="live-chat-messages" class="flex-1 overflow-y-auto p-4 space-y-3 live-chat" style="height: 250px;">
            <!-- Welcome message -->
            <div class="text-center text-xs text-gray-500 dark:text-gray-400 py-2">
              Welcome to the chat! üëã
            </div>
          </div>

          <!-- Chat Input -->
          <div class="p-4 border-t border-gray-200 dark:border-gray-600">
            <div class="flex space-x-2">
              <input 
                type="text" 
                id="chat-input"
                placeholder="Type a message..."
                maxlength="200"
                class="flex-1 px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-main-red focus:border-transparent bg-white dark:bg-gray-700 text-charcoal dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              >
              <button 
                id="send-chat"
                onclick="sendChatMessage()"
                class="bg-main-red hover:bg-red-600 text-white p-2 rounded-lg transition-colors"
              >
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"/>
                </svg>
              </button>
            </div>
            <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
              <span id="char-count">0</span>/200 characters
            </div>
          </div>
        </div>
        
        <!-- Spectator Sidebar Ad -->
        <div class="chatspheres-ad-container chatspheres-ad-sidebar" id="spectator-sidebar-ad" style="margin-top: 1rem;">
          <ins class="adsbygoogle chatspheres-ad"
               style="display:block"
               data-ad-client="ca-pub-8986841930339200"
               data-ad-format="rectangle"
               data-full-width-responsive="true"></ins>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Sticky Timer -->
<div id="stickyTimer" class="fixed top-4 right-4 z-50 transition-all duration-300 opacity-0 transform translate-y-[-20px]">
  <div class="timer-glow bg-main-red text-white px-3 py-2 rounded-full font-bold text-sm shadow-lg">
    <div class="flex flex-col items-center leading-tight">
      <span id="timer">60:00</span>
      <span id="minutes-used-sticky-wrapper" class="text-[11px] text-white text-opacity-80 mt-1">used <span id="minutes-used-sticky">0</span> min</span>
    </div>
  </div>
</div>

<!-- Toast -->
<div id="toast" class="fixed bottom-4 right-4 bg-main-red text-white px-6 py-3 rounded-xl shadow-lg transform translate-y-full transition-transform hidden z-40">
  <p id="toastMessage"></p>
</div>

<!-- Share Modal - Clean Branding -->
<div id="share-modal" class="fixed inset-0 bg-charcoal bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
  <div class="bg-light-rose rounded-3xl p-6 max-w-md w-full mx-4 shadow-2xl border-2 border-gold animate-modal-pop">
    <!-- Header with Logo -->
    <div class="flex justify-between items-center mb-5">
      <div class="flex items-center gap-3">
        <svg viewBox="0 0 64 64" width="48" height="48" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="24" cy="32" r="20" stroke="#fff" stroke-width="6"/>
          <circle cx="40" cy="32" r="20" stroke="#fff" stroke-width="6"/>
          <circle cx="24" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
          <circle cx="40" cy="32" r="18" stroke="#e63946" stroke-width="4" fill="none"/>
        </svg>
        <div>
          <h3 class="text-xl font-bold text-charcoal">Share Your Sphere</h3>
          <p class="text-xs text-charcoal opacity-70">Two seats. One topic. Infinite insight.</p>
        </div>
      </div>
      <button id="share-modal-close" class="text-charcoal hover:text-main-red transition-colors p-1">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
    </div>
    
    <!-- Live Presence Stats -->
    <div class="bg-rose rounded-xl p-4 mb-5">
      <div class="flex justify-around text-center">
        <div>
          <div class="text-2xl font-bold text-main-red" id="share-participant-count">0</div>
          <div class="text-xs text-charcoal font-semibold">Participants</div>
        </div>
        <div class="w-px bg-main-red opacity-30"></div>
        <div>
          <div class="text-2xl font-bold text-charcoal" id="share-spectator-count">0</div>
          <div class="text-xs text-charcoal font-semibold">Spectators</div>
        </div>
        <div class="w-px bg-main-red opacity-30"></div>
        <div>
          <div class="text-2xl font-bold text-gold" id="share-link-shares">0</div>
          <div class="text-xs text-charcoal font-semibold">Shares</div>
        </div>
      </div>
    </div>
    
    <!-- Link Type Selection -->
    <div class="flex gap-3 mb-4">
      <button id="share-participant-link" class="flex-1 px-4 py-3 bg-gold text-charcoal rounded-full font-bold text-sm transition-all shadow-md hover:bg-main-red hover:text-white">
        üë§ Participant
      </button>
      <button id="share-spectator-link" class="flex-1 px-4 py-3 bg-charcoal text-white rounded-full font-bold text-sm transition-all shadow-md hover:bg-main-red opacity-70">
        üëÅÔ∏è Spectator
      </button>
    </div>
    
    <!-- Selected Mode Indicator -->
    <div id="share-mode-indicator" class="text-center text-sm font-semibold text-charcoal mb-3">
      <span id="share-mode-text">üé§ Participant link selected</span>
    </div>
    
    <!-- Link Display & Copy -->
    <div class="bg-white rounded-xl p-4 mb-4 border border-rose">
      <input id="share-link-input" type="text" readonly 
        class="w-full px-3 py-2 bg-transparent text-charcoal text-sm font-mono border-none focus:outline-none truncate">
      <button id="copy-share-link" class="cta-btn w-full mt-3 py-3 font-bold text-sm">
        <span id="copy-btn-text">üìã Copy Link</span>
      </button>
    </div>
    
    <!-- Success Message (hidden by default) -->
    <div id="share-success-msg" class="hidden text-center py-3 bg-gold rounded-xl mb-4">
      <span class="text-charcoal font-bold">‚úÖ Link copied! Share it with a friend</span>
    </div>
    
    <!-- Footer -->
    <p class="text-center text-xs text-charcoal opacity-60">
      Talk with purpose. Connect with heart. üí¨
    </p>
  </div>
</div>

<!-- ========== RATING MODAL ========== -->
<div id="rating-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-6 max-w-sm w-full shadow-2xl border-4 border-gold relative">
    <!-- Close button -->
    <button onclick="skipRating()" class="absolute top-4 right-4 text-charcoal hover:text-main-red transition-colors">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Header -->
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-gold rounded-full flex items-center justify-center">
        <span class="text-3xl">‚≠ê</span>
      </div>
      <h2 class="text-xl font-bold text-charcoal mb-2">How was your chat?</h2>
      <p id="rating-with-user" class="text-charcoal opacity-70 text-sm">with <strong id="rating-other-user-name">User</strong></p>
      <p class="text-charcoal opacity-60 text-xs mt-2">Your feedback keeps ChatSpheres safe and helps us match you with better people.</p>
    </div>
    
    <!-- Rating Buttons -->
    <div class="flex justify-center gap-6 mb-6">
      <button onclick="submitRating('good')" class="rating-btn flex flex-col items-center p-4 rounded-2xl border-3 border-rose hover:border-gold hover:bg-gold transition-all group">
        <span class="text-4xl mb-2 group-hover:scale-125 transition-transform">üëç</span>
        <span class="text-charcoal font-semibold">Good</span>
      </button>
      <button onclick="submitRating('bad')" class="rating-btn flex flex-col items-center p-4 rounded-2xl border-3 border-rose hover:border-main-red hover:bg-rose transition-all group">
        <span class="text-4xl mb-2 group-hover:scale-125 transition-transform">üëé</span>
        <span class="text-charcoal font-semibold">Bad</span>
      </button>
    </div>
    
    <!-- Optional Feedback -->
    <div class="mb-4">
      <label class="block text-charcoal text-sm font-semibold mb-2">Feedback (optional)</label>
      <textarea 
        id="rating-feedback" 
        placeholder="Tell us more about your experience..."
        maxlength="500"
        rows="2"
        class="w-full px-4 py-3 rounded-xl border-2 border-rose focus:border-gold focus:outline-none bg-bg-main text-charcoal placeholder-gray-400 resize-none"
      ></textarea>
      <p class="text-right text-xs text-charcoal opacity-50 mt-1"><span id="feedback-char-count">0</span>/500</p>
    </div>
    
    <!-- Skip Link -->
    <p class="text-center">
      <button onclick="skipRating()" class="text-charcoal opacity-60 hover:opacity-100 text-sm underline">Skip for now</button>
    </p>
  </div>
</div>

<!-- ========== REPORT MODAL ========== -->
<div id="report-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-6 max-w-sm w-full shadow-2xl border-4 border-main-red relative">
    <!-- Close button -->
    <button onclick="closeReportModal()" class="absolute top-4 right-4 text-charcoal hover:text-main-red transition-colors">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Header -->
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center">
        <span class="text-3xl">üö©</span>
      </div>
      <h2 class="text-xl font-bold text-charcoal mb-2">Report User</h2>
      <p id="report-user-name" class="text-charcoal opacity-70 text-sm">Reporting: <strong>User</strong></p>
    </div>
    
    <!-- Report Categories -->
    <div class="space-y-2 mb-4">
      <button onclick="selectReportCategory('inappropriate')" class="report-category-btn w-full text-left px-4 py-3 rounded-xl border-2 border-rose hover:border-main-red hover:bg-rose transition-all flex items-center gap-3">
        <span class="text-xl">üîû</span>
        <span class="text-charcoal font-semibold">Inappropriate Content</span>
      </button>
      <button onclick="selectReportCategory('harassment')" class="report-category-btn w-full text-left px-4 py-3 rounded-xl border-2 border-rose hover:border-main-red hover:bg-rose transition-all flex items-center gap-3">
        <span class="text-xl">üëä</span>
        <span class="text-charcoal font-semibold">Harassment / Threats</span>
      </button>
      <button onclick="selectReportCategory('underage')" class="report-category-btn w-full text-left px-4 py-3 rounded-xl border-2 border-rose hover:border-main-red hover:bg-rose transition-all flex items-center gap-3">
        <span class="text-xl">üë∂</span>
        <span class="text-charcoal font-semibold">Underage User</span>
      </button>
      <button onclick="selectReportCategory('spam')" class="report-category-btn w-full text-left px-4 py-3 rounded-xl border-2 border-rose hover:border-main-red hover:bg-rose transition-all flex items-center gap-3">
        <span class="text-xl">ü§ñ</span>
        <span class="text-charcoal font-semibold">Spam / Bot</span>
      </button>
      <button onclick="selectReportCategory('other')" class="report-category-btn w-full text-left px-4 py-3 rounded-xl border-2 border-rose hover:border-main-red hover:bg-rose transition-all flex items-center gap-3">
        <span class="text-xl">‚ö†Ô∏è</span>
        <span class="text-charcoal font-semibold">Other</span>
      </button>
    </div>
    
    <!-- Optional Description (shown after category selected) -->
    <div id="report-description-section" class="hidden mb-4">
      <label class="block text-charcoal text-sm font-semibold mb-2">Details (optional)</label>
      <textarea 
        id="report-description" 
        placeholder="What happened?"
        maxlength="500"
        rows="2"
        class="w-full px-4 py-3 rounded-xl border-2 border-rose focus:border-main-red focus:outline-none bg-bg-main text-charcoal placeholder-gray-400 resize-none"
      ></textarea>
    </div>
    
    <!-- Submit Button (shown after category selected) -->
    <button id="submit-report-btn" onclick="submitReport()" class="hidden w-full bg-main-red hover:bg-red-700 text-white font-bold py-3 px-6 rounded-xl transition-all">
      Submit Report
    </button>
    
    <!-- Cancel Link -->
    <p class="text-center mt-3">
      <button onclick="closeReportModal()" class="text-charcoal opacity-60 hover:opacity-100 text-sm underline">Cancel</button>
    </p>
  </div>
</div>

<!-- ========== BUG REPORT MODAL ========== -->
<div id="bug-report-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-6 max-w-sm w-full shadow-2xl border-4 border-gold relative">
    <!-- Close button -->
    <button onclick="closeBugReportModal()" class="absolute top-4 right-4 text-charcoal hover:text-main-red transition-colors">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
      </svg>
    </button>
    
    <!-- Header -->
    <div class="text-center mb-6">
      <div class="w-16 h-16 mx-auto mb-4 bg-gold rounded-full flex items-center justify-center">
        <span class="text-3xl">üêõ</span>
      </div>
      <h2 class="text-xl font-bold text-charcoal mb-2">Report a Bug</h2>
      <p class="text-charcoal opacity-70 text-sm">Help us improve ChatSpheres!</p>
    </div>
    
    <!-- Bug Category -->
    <div class="mb-4">
      <label class="block text-charcoal text-sm font-semibold mb-2">Category</label>
      <select 
        id="bug-category" 
        class="w-full px-4 py-3 rounded-xl border-2 border-rose focus:border-gold focus:outline-none bg-bg-main text-charcoal"
      >
        <option value="">Select a category...</option>
        <option value="video">üé• Video Issues</option>
        <option value="audio">üîä Audio Issues</option>
        <option value="connection">üîå Connection Problems</option>
        <option value="chat">üí¨ Chat Issues</option>
        <option value="ui">üñ•Ô∏è UI/Display Problems</option>
        <option value="performance">‚ö° Performance/Slow</option>
        <option value="other">‚ùì Other</option>
      </select>
    </div>
    
    <!-- Bug Description -->
    <div class="mb-4">
      <label class="block text-charcoal text-sm font-semibold mb-2">Description <span class="text-main-red">*</span></label>
      <textarea 
        id="bug-description" 
        placeholder="Please describe what happened and what you expected to happen..."
        maxlength="1000"
        rows="4"
        class="w-full px-4 py-3 rounded-xl border-2 border-rose focus:border-gold focus:outline-none bg-bg-main text-charcoal placeholder-gray-400 resize-none"
        required
      ></textarea>
      <p class="text-xs text-charcoal opacity-50 mt-1">Max 1000 characters</p>
    </div>
    
    <!-- Browser/Device Info (auto-filled) -->
    <div class="mb-4 text-xs text-charcoal opacity-60 bg-rose rounded-lg p-2">
      <p>üì± <span id="bug-device-info">Collecting device info...</span></p>
    </div>
    
    <!-- Submit Button -->
    <button id="submit-bug-btn" onclick="submitBugReport()" class="w-full bg-gold hover:bg-yellow-500 text-charcoal font-bold py-3 px-6 rounded-xl transition-all">
      Submit Bug Report
    </button>
    
    <!-- Cancel Link -->
    <p class="text-center mt-3">
      <button onclick="closeBugReportModal()" class="text-charcoal opacity-60 hover:opacity-100 text-sm underline">Cancel</button>
    </p>
  </div>
</div>

<!-- ========== SPECTATOR MANAGEMENT MODAL (Host Only) ========== -->
<div id="spectator-management-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4" style="background: rgba(34, 34, 59, 0.95); backdrop-filter: blur(8px);">
  <div class="bg-light-rose rounded-3xl p-6 max-w-lg w-full shadow-2xl max-h-[80vh] overflow-hidden flex flex-col">
    <!-- Modal Header -->
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-xl font-bold text-charcoal">üë• Manage Viewers</h2>
      <button onclick="closeSpectatorManagementModal()" class="text-charcoal hover:text-main-red transition-colors">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
    </div>
    
    <!-- Info Text -->
    <p class="text-charcoal text-sm opacity-70 mb-2">
      Mute spectators to hide their chat messages from everyone.
    </p>
    
    <!-- Search Box -->
    <div class="mb-4">
      <input 
        type="text" 
        id="spectator-search" 
        placeholder="üîç Search by name..." 
        oninput="searchSpectators(this.value)"
        class="w-full px-4 py-2 rounded-full border-2 border-rose focus:border-gold focus:outline-none text-charcoal"
      />
    </div>
    
    <!-- Spectator Count -->
    <div id="spectator-count" class="text-sm text-charcoal opacity-70 mb-2"></div>
    
    <!-- Spectator List -->
    <div id="spectator-list" class="flex-1 overflow-y-auto space-y-2 min-h-[100px] max-h-[300px]">
      <div class="text-center text-charcoal opacity-60 py-8">
        <p>Loading spectators...</p>
      </div>
    </div>
    
    <!-- Close Button -->
    <div class="mt-4 pt-4 border-t border-rose">
      <button onclick="closeSpectatorManagementModal()" class="w-full py-3 px-6 bg-charcoal text-white font-bold rounded-full hover:bg-main-red transition-all">
        Close
      </button>
    </div>
  </div>
</div>

<!-- Floating Spectator Management Button (Host Only) -->
<button id="floating-spectator-btn" onclick="showSpectatorManagementModal()" 
  class="hidden fixed bottom-40 right-4 z-40 bg-charcoal text-white px-4 py-3 rounded-full shadow-lg hover:bg-gold hover:text-charcoal transition-all font-bold text-sm"
  title="Manage spectators">
  üë• Manage Viewers
</button>

<script>
  // Firebase config - Main database
  const runtimeConfig = window.__CHATSPHERES_CONFIG__ || {};
  const firebaseConfig = runtimeConfig.firebaseMain || {};

  // Prompts Realtime Database (REST access only, authenticated via secondary app)
  var promptsFirebaseConfig = {
    ...runtimeConfig.promptsFirebase
  };
  let promptsDatabaseBaseUrl = (promptsFirebaseConfig.databaseURL || '').replace(/\/$/, '');

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const auth = firebase.auth();
  let promptsAuthApp = null;
  let promptsAuth = null;

  let firebaseAuthInitialized = false;
  let firebaseAuthInitPromise = null;
  let promptsAuthInitialized = false;
  let promptsAuthInitPromise = null;

  function ensureFirebaseAuth() {
    if (firebaseAuthInitialized && auth.currentUser) {
      return Promise.resolve(auth.currentUser);
    }

    if (firebaseAuthInitPromise) {
      return firebaseAuthInitPromise;
    }

    firebaseAuthInitPromise = (async () => {
      try {
        if (auth.currentUser) {
          firebaseAuthInitialized = true;
          return auth.currentUser;
        }
        const credential = await auth.signInAnonymously();
        firebaseAuthInitialized = true;
        console.log('‚úÖ Firebase anonymous auth ready:', credential.user?.uid);
        return credential.user;
      } catch (error) {
        firebaseAuthInitPromise = null;
        console.error('‚ùå Firebase anonymous auth failed:', error);
        throw error;
      }
    })();

    return firebaseAuthInitPromise;
  }

  async function getFirebaseIdToken(forceRefresh = false) {
    const user = await ensureFirebaseAuth();
    if (!user) {
      throw new Error('Firebase auth user unavailable');
    }
    return user.getIdToken(forceRefresh);
  }

  function ensurePromptsAuth() {
    const authInstance = initializePromptsFirebaseApp();
    if (!authInstance) {
      return Promise.reject(new Error('Prompts Firebase auth unavailable'));
    }
    if (promptsAuthInitialized && authInstance.currentUser) {
      return Promise.resolve(authInstance.currentUser);
    }

    if (promptsAuthInitPromise) {
      return promptsAuthInitPromise;
    }

    promptsAuthInitPromise = (async () => {
      try {
        if (authInstance.currentUser) {
          promptsAuthInitialized = true;
          return authInstance.currentUser;
        }
        const credential = await authInstance.signInAnonymously();
        promptsAuthInitialized = true;
        console.log('‚úÖ Prompts Firebase anonymous auth ready:', credential.user?.uid);
        return credential.user;
      } catch (error) {
        promptsAuthInitPromise = null;
        console.error('‚ùå Prompts Firebase anonymous auth failed:', error);
        throw error;
      }
    })();

    return promptsAuthInitPromise;
  }

  async function getPromptsIdToken(forceRefresh = false) {
    const user = await ensurePromptsAuth();
    if (!user) {
      throw new Error('Prompts Firebase auth user unavailable');
    }
    return user.getIdToken(forceRefresh);
  }

  function cleanupLegacyFirebaseApps() {
    if (!firebase || !firebase.apps) {
      return;
    }
    firebase.apps.forEach((app) => {
      const appName = app?.name || '';
      if (appName && appName !== '[DEFAULT]' && appName.toLowerCase().includes('prompts') && appName !== 'promptsAuth') {
        try {
          app.delete().then(() => {
            console.log(`üßπ Removed legacy Firebase app: ${appName}`);
          }).catch((error) => {
            console.warn(`‚ö†Ô∏è Unable to delete legacy Firebase app ${appName}:`, error);
          });
        } catch (error) {
          console.warn(`‚ö†Ô∏è Error while removing legacy Firebase app ${appName}:`, error);
        }
      }
    });
  }
  cleanupLegacyFirebaseApps();
  Promise.all([ensureFirebaseAuth(), ensurePromptsAuth()]).catch(() => {
    showToast('‚ùå Failed to authenticate with Firebase. Please refresh.');
  });

  firebase.database().ref('.info/serverTimeOffset').on('value', (snapshot) => {
    const offset = snapshot.val();
    serverTimeOffset = typeof offset === 'number' ? offset : 0;
  });

    // Supabase client setup for session tracking AND authentication
    const supabaseRuntimeConfig = runtimeConfig.supabase || {};
    const authRuntimeConfig = runtimeConfig.auth || {};
    const SUPABASE_URL = supabaseRuntimeConfig.url || '';
    const SUPABASE_ANON_KEY = supabaseRuntimeConfig.anonKey || '';
    
    // Auth cookie configuration for cross-subdomain sessions
    // Cookie domain should be .chatspheres.com to work across:
    // - chatspheres.com (Forum/Web)
    // - sphere.chatspheres.com (Video Sphere/Netlify)
    const AUTH_COOKIE_DOMAIN = authRuntimeConfig.cookieDomain || '.chatspheres.com';
    const AUTH_SITE_URL = authRuntimeConfig.siteUrl || window.location.origin;
    const AUTH_REDIRECT_URL = authRuntimeConfig.redirectUrl || `${AUTH_SITE_URL}/.netlify/functions/auth-callback`;

    let supabaseClient = null;
    let supabaseAuthUser = null;
    let authInitialized = false;

    if (window.supabase && window.supabase.createClient) {
      try {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true,
            flowType: 'pkce',
            storage: {
              // Custom storage to set cookies with the proper domain
              getItem: (key) => {
                if (typeof document === 'undefined') return null;
                const cookies = document.cookie.split(';');
                for (const cookie of cookies) {
                  const [cookieName, cookieValue] = cookie.trim().split('=');
                  if (cookieName === key) {
                    return decodeURIComponent(cookieValue);
                  }
                }
                // Fallback to localStorage for non-cookie storage
                try {
                  return localStorage.getItem(key);
                } catch (e) {
                  return null;
                }
              },
              setItem: (key, value) => {
                if (typeof document === 'undefined') return;
                // Set cookie with domain for cross-subdomain access
                const maxAge = 60 * 60 * 24 * 365; // 1 year
                const cookieDomain = AUTH_COOKIE_DOMAIN;
                const secure = window.location.protocol === 'https:';
                const sameSite = 'Lax';
                
                let cookieString = `${key}=${encodeURIComponent(value)}; path=/; max-age=${maxAge}; SameSite=${sameSite}`;
                if (secure) {
                  cookieString += '; Secure';
                }
                // Only add domain if it's explicitly set (for cross-subdomain)
                if (cookieDomain && cookieDomain !== 'localhost') {
                  cookieString += `; domain=${cookieDomain}`;
                }
                document.cookie = cookieString;
                
                // Also store in localStorage as backup
                try {
                  localStorage.setItem(key, value);
                } catch (e) {
                  console.warn('localStorage unavailable:', e);
                }
              },
              removeItem: (key) => {
                if (typeof document === 'undefined') return;
                const cookieDomain = AUTH_COOKIE_DOMAIN;
                let cookieString = `${key}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
                if (cookieDomain && cookieDomain !== 'localhost') {
                  cookieString += `; domain=${cookieDomain}`;
                }
                document.cookie = cookieString;
                try {
                  localStorage.removeItem(key);
                } catch (e) {}
              }
            }
          }
        });
        console.log('‚úÖ Supabase client initialized with cross-domain auth support');
        console.log(`üç™ Auth cookie domain: ${AUTH_COOKIE_DOMAIN}`);
      } catch (error) {
        console.error('‚ùå Failed to initialize Supabase:', error);
      }
    } else {
      console.error('‚ùå Supabase library not loaded from CDN');
    }

    // ============================================================
    // AUTHENTICATION SYSTEM
    // ============================================================

    // Check for auth callback hash (OAuth redirect)
    function handleAuthCallback() {
      if (window.location.hash.includes('auth-callback') || window.location.hash.includes('access_token')) {
        console.log('üîê Handling auth callback...');
        // The Supabase client will automatically detect and process the tokens
        // Clear the hash after processing
        setTimeout(() => {
          if (window.location.hash) {
            history.replaceState(null, '', window.location.pathname + window.location.search);
          }
        }, 100);
      }
    }

    // Initialize authentication state
    async function initializeAuth() {
      if (!supabaseClient) {
        console.warn('‚ö†Ô∏è Supabase client not available for auth');
        updateHeaderAuthState(false);
        return null;
      }

      try {
        // Handle any OAuth callback first
        handleAuthCallback();

        // Check for existing session
        const { data: { session }, error } = await supabaseClient.auth.getSession();
        
        if (error) {
          console.error('‚ùå Error getting auth session:', error);
          updateHeaderAuthState(false);
          return null;
        }

        if (session?.user) {
          supabaseAuthUser = session.user;
          authInitialized = true;
          console.log('‚úÖ User authenticated:', session.user.email);
          // Update UI with user data
          await updateUserDataFromAuth(session.user);
          return session.user;
        }

        console.log('‚ÑπÔ∏è No active auth session');
        updateHeaderAuthState(false);
        return null;
      } catch (error) {
        console.error('‚ùå Auth initialization error:', error);
        updateHeaderAuthState(false);
        return null;
      }
    }

    // Listen for auth state changes
    function setupAuthListener() {
      if (!supabaseClient) return;

      supabaseClient.auth.onAuthStateChange(async (event, session) => {
        console.log('üîÑ Auth state changed:', event);
        
        if (session?.user) {
          supabaseAuthUser = session.user;
          console.log('‚úÖ User signed in:', session.user.email);
          hideAuthModal();
          await updateUserDataFromAuth(session.user);
          
          // Track referral signup if this is a new user
          if (event === 'SIGNED_IN') {
            // Use cross-domain referral tracking
            if (window.ChatSpheresReferral) {
              window.ChatSpheresReferral.trackReferralSignup(session.user.id);
            }
          }
        } else {
          supabaseAuthUser = null;
          console.log('‚ÑπÔ∏è User signed out');
        }
      });
    }

    // Update window.currentUserData from Supabase auth user
    // Fetches profile from profiles table and prioritizes that over Google auth metadata
    async function updateUserDataFromAuth(user) {
      if (!user) return;
      
      // Default to Google auth metadata as fallback
      const metadata = user.user_metadata || {};
      const fallbackName = metadata.name || metadata.full_name || user.email?.split('@')[0] || 'User';
      const fallbackAvatar = metadata.avatar_url || metadata.picture || '';
      
      // Set initial data from auth
      window.currentUserData = {
        ...window.currentUserData,
        username: fallbackName,
        displayName: fallbackName,
        email: user.email,
        avatar: fallbackAvatar,
        userId: user.id,
        isAuthenticated: true
      };
      
      // Update global userId for session tracking
      userId = user.id;
      userName = window.currentUserData.username;
      
      // Now fetch profile from database to override with user's custom settings
      try {
        const response = await fetch(`/.netlify/functions/get-subscription?userId=${user.id}`);
        if (response.ok) {
          const data = await response.json();
          const mainProfile = data.mainProfile || {};
          
          // Override with profile data if available (prioritize user's custom settings)
          if (mainProfile.displayName) {
            window.currentUserData.displayName = mainProfile.displayName;
            userName = mainProfile.displayName;
          }
          if (mainProfile.username) {
            window.currentUserData.username = mainProfile.username;
          }
          if (mainProfile.avatarUrl) {
            window.currentUserData.avatar = mainProfile.avatarUrl;
          }
          
          console.log('‚úÖ Loaded profile from database:', mainProfile);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not fetch profile, using auth metadata:', error);
      }
      
      // Update header auth buttons
      updateHeaderAuthState(true, window.currentUserData.displayName);
      
      console.log('üë§ Updated user data from auth:', window.currentUserData);
    }

    // Update header auth buttons based on auth state
    function updateHeaderAuthState(isLoggedIn, displayName = '') {
      // Header elements
      const headerGemBalance = document.getElementById('header-gem-balance');
      
      // Menu elements
      const mobileGuestButtons = document.getElementById('mobile-auth-guest');
      const mobileUserButtons = document.getElementById('mobile-auth-user');
      const mobileUsername = document.getElementById('mobile-username');
      
      if (isLoggedIn) {
        // Show gem balance in header
        if (headerGemBalance) {
          headerGemBalance.classList.remove('hidden');
          headerGemBalance.style.display = 'flex';
        }
        
        // Menu: show user, hide guest
        if (mobileGuestButtons) mobileGuestButtons.classList.add('hidden');
        if (mobileUserButtons) mobileUserButtons.classList.remove('hidden');
        if (mobileUsername) mobileUsername.textContent = displayName;
        
        // Fetch and display gem balance
        fetchAndDisplayGemBalance();
      } else {
        // Hide gem balance in header
        if (headerGemBalance) headerGemBalance.classList.add('hidden');
        
        // Menu: show guest, hide user
        if (mobileGuestButtons) mobileGuestButtons.classList.remove('hidden');
        if (mobileUserButtons) mobileUserButtons.classList.add('hidden');
      }
    }
    
    // Fetch and display gem balance in header
    async function fetchAndDisplayGemBalance() {
      const gemCountEl = document.getElementById('gem-count');
      const brandingBtn = document.getElementById('branding-btn');
      if (!gemCountEl) return;
      
      // Get user ID from currentUserData or URL
      const currentUserId = window.currentUserData?.userId || userId;
      
      if (!currentUserId || !isValidUuid(currentUserId)) {
        gemCountEl.textContent = '0';
        if (brandingBtn) brandingBtn.classList.add('hidden');
        return;
      }
      
      try {
        const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
        if (!response.ok) {
          gemCountEl.textContent = '0';
          if (brandingBtn) brandingBtn.classList.add('hidden');
          return;
        }
        
        const data = await response.json();
        const totalGems = data.totalGems || 0;
        
        // Format with commas for large numbers
        gemCountEl.textContent = totalGems.toLocaleString();
        
        // Also update mobile gem count
        const mobileGemCount = document.getElementById('mobile-gem-count');
        if (mobileGemCount) mobileGemCount.textContent = totalGems.toLocaleString();
        
        console.log(`üíé Gem balance loaded: ${totalGems}`);
        
        // Show branding button for pro users
        const canBrand = data.limits?.canCustomBrand || false;
        const mobileBrandingLink = document.getElementById('mobile-branding-link');
        if (brandingBtn) {
          if (canBrand) {
            brandingBtn.classList.remove('hidden');
            if (mobileBrandingLink) {
              mobileBrandingLink.classList.remove('hidden');
              mobileBrandingLink.style.display = 'flex';
            }
            console.log('üé® Branding enabled for pro user');
          } else {
            brandingBtn.classList.add('hidden');
            if (mobileBrandingLink) mobileBrandingLink.classList.add('hidden');
          }
        }
        
        // Cache badge info
        if (data.badge) {
          window.currentUserBadge = data.badge;
        }
      } catch (error) {
        console.error('‚ùå Error fetching gem balance:', error);
        gemCountEl.textContent = '0';
      }
    }

    // Auth Modal Functions
    function showAuthModal() {
      const modal = document.getElementById('auth-modal');
      if (modal) {
        modal.classList.add('active');
      }
    }
    window.showAuthModal = showAuthModal;

    function hideAuthModal() {
      const modal = document.getElementById('auth-modal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.hideAuthModal = hideAuthModal;

    function switchAuthTab(tab) {
      const signinTab = document.getElementById('auth-tab-signin');
      const signupTab = document.getElementById('auth-tab-signup');
      const signinForm = document.getElementById('signin-form');
      const signupForm = document.getElementById('signup-form');
      const messageEl = document.getElementById('auth-message');
      
      // Clear any messages
      if (messageEl) {
        messageEl.classList.add('hidden');
      }
      
      if (tab === 'signin') {
        signinTab?.classList.add('bg-main-red', 'text-white');
        signinTab?.classList.remove('text-gray-600');
        signupTab?.classList.remove('bg-main-red', 'text-white');
        signupTab?.classList.add('text-gray-600');
        signinForm?.classList.remove('hidden');
        signupForm?.classList.add('hidden');
      } else {
        signupTab?.classList.add('bg-main-red', 'text-white');
        signupTab?.classList.remove('text-gray-600');
        signinTab?.classList.remove('bg-main-red', 'text-white');
        signinTab?.classList.add('text-gray-600');
        signupForm?.classList.remove('hidden');
        signinForm?.classList.add('hidden');
      }
    }

    function showAuthMessage(message, isError = true) {
      const messageEl = document.getElementById('auth-message');
      if (messageEl) {
        messageEl.textContent = message;
        messageEl.classList.remove('hidden', 'bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700');
        if (isError) {
          messageEl.classList.add('bg-red-100', 'text-red-700');
        } else {
          messageEl.classList.add('bg-green-100', 'text-green-700');
        }
      }
    }

    function showAuthLoading(show, text = 'Signing in...') {
      const loadingEl = document.getElementById('auth-loading');
      const loadingTextEl = document.getElementById('auth-loading-text');
      if (loadingEl) {
        if (show) {
          loadingEl.classList.remove('hidden');
          if (loadingTextEl) loadingTextEl.textContent = text;
        } else {
          loadingEl.classList.add('hidden');
        }
      }
    }

    // Handle Email Sign In
    async function handleSignIn(event) {
      event.preventDefault();
      
      if (!supabaseClient) {
        showAuthMessage('Authentication service unavailable. Please refresh the page.');
        return;
      }

      const email = document.getElementById('signin-email')?.value?.trim();
      const password = document.getElementById('signin-password')?.value;

      if (!email || !password) {
        showAuthMessage('Please enter both email and password.');
        return;
      }

      showAuthLoading(true, 'Signing in...');

      try {
        const { data, error } = await supabaseClient.auth.signInWithPassword({
          email,
          password
        });

        if (error) {
          showAuthLoading(false);
          showAuthMessage(error.message || 'Sign in failed. Please try again.');
          return;
        }

        if (data?.user) {
          showAuthMessage('‚úÖ Signed in successfully!', false);
          setTimeout(() => {
            hideAuthModal();
            showAuthLoading(false);
            // Continue with the app flow
            if (roomUrl) {
              initializeVideoChat();
            }
          }, 500);
        }
      } catch (error) {
        showAuthLoading(false);
        showAuthMessage('An error occurred. Please try again.');
        console.error('Sign in error:', error);
      }
    }

    // Handle Email Sign Up
    async function handleSignUp(event) {
      event.preventDefault();
      
      if (!supabaseClient) {
        showAuthMessage('Authentication service unavailable. Please refresh the page.');
        return;
      }

      const name = document.getElementById('signup-name')?.value?.trim();
      const email = document.getElementById('signup-email')?.value?.trim();
      const password = document.getElementById('signup-password')?.value;

      if (!name || !email || !password) {
        showAuthMessage('Please fill in all fields.');
        return;
      }

      if (password.length < 6) {
        showAuthMessage('Password must be at least 6 characters.');
        return;
      }

      showAuthLoading(true, 'Creating account...');

      try {
        const { data, error } = await supabaseClient.auth.signUp({
          email,
          password,
          options: {
            data: {
              name: name,
              full_name: name
            },
            emailRedirectTo: AUTH_REDIRECT_URL
          }
        });

        if (error) {
          showAuthLoading(false);
          showAuthMessage(error.message || 'Sign up failed. Please try again.');
          return;
        }

        if (data?.user) {
          if (data.user.identities?.length === 0) {
            // User already exists
            showAuthLoading(false);
            showAuthMessage('An account with this email already exists. Please sign in.');
            switchAuthTab('signin');
          } else if (data.session) {
            // User is immediately signed in (email confirmation disabled)
            showAuthMessage('‚úÖ Account created successfully!', false);
            setTimeout(() => {
              hideAuthModal();
              showAuthLoading(false);
              if (roomUrl) {
                initializeVideoChat();
              }
            }, 500);
          } else {
            // Email confirmation required
            showAuthLoading(false);
            showAuthMessage('‚úÖ Account created! Please check your email to confirm.', false);
          }
        }
      } catch (error) {
        showAuthLoading(false);
        showAuthMessage('An error occurred. Please try again.');
        console.error('Sign up error:', error);
      }
    }

    // Handle Google Sign In
    async function handleGoogleSignIn() {
      if (!supabaseClient) {
        showAuthMessage('Authentication service unavailable. Please refresh the page.');
        return;
      }

      showAuthLoading(true, 'Connecting to Google...');

      try {
        const { data, error } = await supabaseClient.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: AUTH_REDIRECT_URL,
            queryParams: {
              access_type: 'offline',
              prompt: 'consent'
            }
          }
        });

        if (error) {
          showAuthLoading(false);
          showAuthMessage(error.message || 'Google sign in failed.');
          console.error('Google sign in error:', error);
        }
        // If successful, user will be redirected to Google
      } catch (error) {
        showAuthLoading(false);
        showAuthMessage('An error occurred. Please try again.');
        console.error('Google sign in error:', error);
      }
    }

    // Continue as guest (skip authentication)
    function continueAsGuest() {
      console.log('üë§ Continuing as guest...');
      hideAuthModal();
      
      // Set up guest user data
      window.currentUserData = {
        ...window.currentUserData,
        username: userName || `Guest_${Math.random().toString(36).slice(2, 8)}`,
        displayName: userName || `Guest_${Math.random().toString(36).slice(2, 8)}`,
        userId: userId || `guest_${Date.now()}`,
        isAuthenticated: false,
        isGuest: true
      };
      
      // Continue with the app flow
      if (roomUrl) {
        initializeVideoChat();
      }
    }

    // Toggle mobile menu
    function toggleVideoMenu() {
      const nav = document.getElementById('video-mobile-nav');
      if (nav) {
        nav.classList.toggle('hidden');
        document.body.style.overflow = nav.classList.contains('hidden') ? '' : 'hidden';
      }
    }
    window.toggleVideoMenu = toggleVideoMenu;

    // Sign out function
    async function signOut() {
      if (!supabaseClient) return;
      
      try {
        await supabaseClient.auth.signOut();
        supabaseAuthUser = null;
        window.currentUserData = {
          isAuthenticated: false,
          isGuest: true
        };
        // Update header to show guest buttons
        updateHeaderAuthState(false);
        console.log('‚úÖ Signed out successfully');
      } catch (error) {
        console.error('Sign out error:', error);
      }
    }

    // Check if auth is required and show modal if needed
    async function checkAuthAndProceed() {
      // First try to get existing session
      const user = await initializeAuth();
      
      if (user) {
        // User is authenticated, update data and proceed
        await updateUserDataFromAuth(user);
        return true;
      }

      // Check if user has URL params (coming from chatspheres.com with auth)
      const urlParams = new URLSearchParams(window.location.search);
      const userIdFromURL = urlParams.get('userId');
      const usernameFromURL = urlParams.get('username');
      
      if (userIdFromURL && usernameFromURL && isValidUuid(userIdFromURL)) {
        // User is coming with valid credentials from another app
        console.log('‚úÖ User authenticated via URL params');
        return true;
      }

      // No auth - show modal
      console.log('‚ÑπÔ∏è No auth found, showing auth modal');
      showAuthModal();
      return false;
    }

    // Set up auth listener on load
    setupAuthListener();

    // Referral code tracking is now handled by /assets/js/referral.js
    // which uses cross-domain cookies for better tracking across subdomains
    
    // Track referral activation when user completes first 2-minute conversation
    async function activateReferralIfEligible(minutesUsed) {
      const userId = window.currentUserData?.userId;
      if (!userId || isSpectator || minutesUsed < 2) {
        console.log('üìé Referral activation skipped:', { userId, isSpectator, minutesUsed });
        return;
      }
      
      // Check if this user has already had referral activated (stored in localStorage)
      const activatedKey = `referral_activated_${userId}`;
      if (localStorage.getItem(activatedKey)) {
        console.log('üìé Referral already activated for this user');
        return;
      }
      
      try {
        console.log('üìé Attempting to activate referral for user:', userId);
        const response = await fetch('/.netlify/functions/track-referral', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'activate',
            referredUserId: userId
          })
        });
        
        const result = await response.json();
        console.log('üìé Referral activation result:', result);
        
        if (result.success) {
          // Mark as activated so we don't try again
          localStorage.setItem(activatedKey, 'true');
          
          // Show a toast notification about the bonus!
          if (result.referredGems) {
            showToast(`üéâ Referral bonus! You earned ${result.referredGems} gems!`);
          }
        }
      } catch (error) {
        console.log('üìé Referral activation error (may not have referral):', error.message);
      }
    }

    // LiveKit runtime configuration
    const livekitRuntimeConfig = runtimeConfig;
    const runtimeDataset = document.body?.dataset || {};
    const LIVEKIT_WS_URL = livekitRuntimeConfig.livekitUrl || runtimeDataset.livekitUrl || 'wss://YOUR-LIVEKIT-HOST';
    const LIVEKIT_CONTROL_API = livekitRuntimeConfig.controlApiBaseUrl || runtimeDataset.livekitControl || '';
    const LIVEKIT_CONTROL_API_KEY = livekitRuntimeConfig.controlApiKey || runtimeDataset.livekitControlKey || '';
    const LIVEKIT_TOKEN_ENDPOINT = livekitRuntimeConfig.tokenEndpoint || runtimeDataset.livekitToken || (LIVEKIT_CONTROL_API ? `${LIVEKIT_CONTROL_API.replace(/\/$/, '')}/token` : '');
    const LIVEKIT_RECORDINGS_ENDPOINT = livekitRuntimeConfig.recordingsEndpoint || runtimeDataset.livekitRecordings || (LIVEKIT_CONTROL_API ? `${LIVEKIT_CONTROL_API.replace(/\/$/, '')}/recordings` : '');
    const DEFAULT_RECORDING_LAYOUT = livekitRuntimeConfig.recordingLayout || 'grid';
    const DEFAULT_LIVEKIT_SDK_SOURCES = [
      '/livekit-client.umd.min.js',
      'https://cdn.jsdelivr.net/npm/livekit-client@2.3.0/dist/livekit-client.umd.min.js',
      'https://unpkg.com/livekit-client@2.3.0/dist/livekit-client.umd.min.js'
    ];
    const DEFAULT_LIVEKIT_ESM_SOURCES = [
      '/livekit-client.esm.mjs',
      'https://cdn.jsdelivr.net/npm/livekit-client@2.3.0/dist/livekit-client.esm.js',
      'https://unpkg.com/livekit-client@2.3.0/dist/livekit-client.esm.js'
    ];
    const configuredEsmUrl = livekitRuntimeConfig.livekitEsmUrl || runtimeDataset.livekitEsmUrl;
    const LIVEKIT_ESM_SOURCES = (configuredEsmUrl ? [configuredEsmUrl, ...DEFAULT_LIVEKIT_ESM_SOURCES] : DEFAULT_LIVEKIT_ESM_SOURCES)
      .filter((value, index, self) => value && self.indexOf(value) === index);
    const configuredSdkUrl = livekitRuntimeConfig.livekitSdkUrl || runtimeDataset.livekitSdkUrl;
    const LIVEKIT_SDK_SOURCES = (configuredSdkUrl
      ? [configuredSdkUrl, ...DEFAULT_LIVEKIT_SDK_SOURCES]
      : DEFAULT_LIVEKIT_SDK_SOURCES
    ).filter((value, index, self) => value && self.indexOf(value) === index);
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    const TAB_INSTANCE_STORAGE_KEY = '__CHATSPHERES_TAB_INSTANCE_ID';
    let tabInstanceId = null;
    try {
      const existingTabId = window.sessionStorage.getItem(TAB_INSTANCE_STORAGE_KEY);
      if (existingTabId) {
        tabInstanceId = existingTabId;
      } else {
        tabInstanceId = `tab_${Math.random().toString(36).slice(2, 8)}`;
        window.sessionStorage.setItem(TAB_INSTANCE_STORAGE_KEY, tabInstanceId);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to persist tab instance ID, using ephemeral value.', error);
      tabInstanceId = `tab_${Date.now().toString(36).slice(-4)}_${Math.random().toString(36).slice(2, 5)}`;
    }
    window.__CHATSPHERES_TAB_INSTANCE_ID = tabInstanceId;

    const runtimeInstanceId = (() => {
      if (typeof window.crypto?.randomUUID === 'function') {
        return window.crypto.randomUUID();
      }
      return `runtime_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
    })();
    window.__CHATSPHERES_RUNTIME_INSTANCE_ID = runtimeInstanceId;

    // Allow runtime overrides for the prompts Firebase project
    const promptsConfigOverrides = {
      ...(typeof livekitRuntimeConfig.promptsFirebase === 'object'
        ? livekitRuntimeConfig.promptsFirebase
        : {}),
      apiKey: runtimeDataset.promptsApiKey || (livekitRuntimeConfig.promptsFirebase?.apiKey ?? undefined),
      authDomain: runtimeDataset.promptsAuthDomain || (livekitRuntimeConfig.promptsFirebase?.authDomain ?? undefined),
      databaseURL: runtimeDataset.promptsDatabaseUrl || (livekitRuntimeConfig.promptsFirebase?.databaseURL ?? undefined),
      projectId: runtimeDataset.promptsProjectId || (livekitRuntimeConfig.promptsFirebase?.projectId ?? undefined),
      storageBucket: runtimeDataset.promptsStorageBucket || (livekitRuntimeConfig.promptsFirebase?.storageBucket ?? undefined),
      messagingSenderId: runtimeDataset.promptsMessagingSenderId || (livekitRuntimeConfig.promptsFirebase?.messagingSenderId ?? undefined),
      appId: runtimeDataset.promptsAppId || (livekitRuntimeConfig.promptsFirebase?.appId ?? undefined),
    };

    const sanitizedPromptOverrides = {};
    Object.entries(promptsConfigOverrides).forEach(([key, value]) => {
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        sanitizedPromptOverrides[key] = value;
      }
    });
    promptsFirebaseConfig = {
      ...promptsFirebaseConfig,
      ...sanitizedPromptOverrides,
    };

    const primaryDatabaseUrl = (firebaseConfig.databaseURL || '').replace(/\/$/, '');
    promptsDatabaseBaseUrl = (promptsFirebaseConfig.databaseURL || primaryDatabaseUrl).replace(/\/$/, '');

    const sharesPrimaryApiKey = promptsFirebaseConfig.apiKey === firebaseConfig.apiKey;
    const sharesPrimaryProject = promptsFirebaseConfig.projectId === firebaseConfig.projectId;
    const promptsLooksMisconfigured =
      sharesPrimaryApiKey &&
      !sharesPrimaryProject &&
      promptsDatabaseBaseUrl &&
      primaryDatabaseUrl &&
      promptsDatabaseBaseUrl !== primaryDatabaseUrl;

    if (promptsLooksMisconfigured) {
      console.warn(
        '‚ö†Ô∏è Prompts Firebase config reuses the primary API key but points to a different database URL. Verify your promptsFirebase credentials.'
      );
    }

    function initializePromptsFirebaseApp() {
      if (promptsAuth) {
        return promptsAuth;
      }
      try {
        const reusePrimary =
          promptsFirebaseConfig.apiKey === firebaseConfig.apiKey &&
          promptsFirebaseConfig.projectId === firebaseConfig.projectId;

        if (reusePrimary) {
          promptsAuthApp = firebase.app();
        } else {
          const existingPromptsApp = firebase.apps.find((app) => app.name === 'promptsAuth');
          promptsAuthApp = existingPromptsApp || firebase.initializeApp(promptsFirebaseConfig, 'promptsAuth');
        }
        promptsAuth = promptsAuthApp.auth();
        return promptsAuth;
      } catch (error) {
        console.error('‚ùå Failed to initialize prompts Firebase app:', error);
        return null;
      }
    }

    initializePromptsFirebaseApp();

    let LiveKitSDK = resolveLiveKitGlobal();
    let LiveKitRoomEvent = LiveKitSDK ? LiveKitSDK.RoomEvent : null;
    let LiveKitTrackSource = LiveKitSDK ? LiveKitSDK.TrackSource : null;
    let LiveKitDataPacketKind = LiveKitSDK ? LiveKitSDK.DataPacket_Kind : null;

    // ===== BROWSER DETECTION FOR SAFARI COMPATIBILITY =====
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isMobileSafari = isSafari && isIOS;
    let userGestureReceived = false;
    
    console.log(`üåê Browser Detection - Safari: ${isSafari}, iOS: ${isIOS}, Mobile Safari: ${isMobileSafari}`);
    
    // Track user gesture for Safari WebRTC compatibility
    function markUserGestureReceived() {
      if (!userGestureReceived) {
        userGestureReceived = true;
        console.log('üëÜ User gesture received - Safari media access now possible');
      }
    }
    
    // Add gesture listeners for Safari
    document.addEventListener('click', markUserGestureReceived, { once: false, passive: true });
    document.addEventListener('touchstart', markUserGestureReceived, { once: false, passive: true });
    document.addEventListener('touchend', markUserGestureReceived, { once: false, passive: true });
    document.addEventListener('keydown', markUserGestureReceived, { once: false, passive: true });

    // Global variables
    let livekitRoom = null;
    let livekitRoomName = null;
    let livekitIdentity = null;
  let localVideo = null;
  let remoteVideo = null;
    let screenShareVideo = null;
    let selectedCameraDeviceId = null;
    let selectedMicDeviceId = null;
  let isCameraOn = true;
  let isMicOn = false;
  let isScreenSharing = false;
  let timeRemaining = 60 * 60; // 1 hour
  let timerInterval = null;
  let accountMinutesBaseline = null;
  let accountMinutesRemaining = null;
  let latestSessionMinutesUsed = 0;
  let accountMinutesLoaded = false;

  // User mode and recording
  let isSpectator = false;
  let isRecording = false;
  let recordingId = null;
  let recordingUploadState = {
    isUploading: false,
    progress: 0,
    pendingPayloadString: null,
    pendingEndpoint: null,
    dbPath: null,
    hideTimeout: null
  };
  const RECORDING_DOWNLOAD_POLL_INTERVAL_MS = 4000;
  const RECORDING_DOWNLOAD_MAX_ATTEMPTS = 20;
  let recordingDownloadWatcher = {
    timeoutId: null,
    currentRecordingId: null,
    dbRef: null
  };
  let userName = '';
  let userId = '';
  let conversationRoomId = null;
  let conversationSphereId = null;
  let conversationSlug = null;
  let firebaseRoomId = '';
  let conversationSessionId = null;
  let conversationPartnerId = null;
  let ensureSessionPromise = null;
  let conversationSessionStartedAt = null;
  let userJoinedAtTimestamp = null; // Track when THIS user joined (not room start time)
  let serverTimeOffset = 0;
  let timerRef = null;
  let timerSyncInitialized = false;
  let timerExpiredHandled = false;
  let timerState = {
    durationSeconds: 60 * 60,
    startedAt: null,
    expiresAt: null,
    createdBy: null
  };
  
  // Session Limit Tracking (Plan-based limits)
  let sessionLimitState = {
    userPlan: 'free',
    limitMinutes: 60, // Default: 60 min for free
    sessionStartTime: null,
    warningShown80: false,
    warningShown95: false,
    limitReached: false,
    graceEndTime: null
  };
  const conversationSessionEndState = {
    inFlight: false,
    ended: false
  };

  // Chat system
  let chatRef = null;
  let viewerCountRef = null;

  // Helper to check if a string looks like a UUID
  function isUuid(str) {
    if (!str) return false;
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const uuidNoDashRegex = /^[0-9a-f]{32}$/i;
    return uuidRegex.test(str) || uuidNoDashRegex.test(str);
  }
  
  // Helper to check if a string is a valid display name
  function isValidDisplayName(name) {
    if (!name) return false;
    if (name.startsWith('cs_')) return false;
    if (name.startsWith('PA_')) return false;
    if (isUuid(name)) return false;
    if (/^\d+$/.test(name)) return false;
    return true;
  }

  // Sparks data
  let currentSparks = [
    "If you could have a conversation with your future self from 10 years from now, what would you want to ask them about the choices you're making today?",
    "What's something you believed strongly about life when you were younger that you've completely changed your mind about now?",
    "If you had to choose one value to guide every major decision for the rest of your life, what would it be and why?"
  ];
  let currentSparkIndex = 0;
  let sparkIsSelected = false;

    const roomUrl = new URLSearchParams(window.location.search).get('room');
    const spectatorMode = new URLSearchParams(window.location.search).get('mode') === 'spectator';

    // Extract sphereId from any room format for consistent presence path
    function extractSphereId(roomParam) {
      if (!roomParam) return null;
      
      // UUID pattern
      const uuidPattern = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/i;
      
      // Try to find first UUID in the string (this is the sphereId)
      const match = roomParam.match(uuidPattern);
      if (match) {
        return match[1];
      }
      
      // Fallback: return as-is
      return roomParam;
    }

    function extractRoomIdentifier(url) {
      if (!url) return null;

      try {
        var parsed = new URL(url);
        var pathname = parsed.pathname || '';
        var segments = pathname.split('/').filter(function(segment) {
          return segment && segment.trim().length > 0;
        });

        if (segments.length > 0) {
          return segments[segments.length - 1];
        }

        return pathname || url;
      } catch (error) {
        var sanitized = url.split('?')[0].split('#')[0];
        var fallbackSegments = sanitized.split('/').filter(function(segment) {
          return segment && segment.trim().length > 0;
        });

        if (fallbackSegments.length > 0) {
          return fallbackSegments[fallbackSegments.length - 1];
        }

        return sanitized || url;
      }
    }

  function isValidUuid(value) {
    return typeof value === 'string' && /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(value);
  }

  function getParticipantUserData(participant) {
    if (!participant) return null;
    // Daily can expose userData in different casings depending on SDK version
    return participant.userData || participant.user_data || null;
  }

  function participantHasActiveCamera(participant) {
    if (!participant || !participant.tracks) return false;
    const publicationCandidates = [];
    if (participant.tracks.video) publicationCandidates.push(participant.tracks.video);
    if (participant.tracks.camera) publicationCandidates.push(participant.tracks.camera);
    Object.values(participant.tracks).forEach((trackPub) => {
      if (trackPub && !publicationCandidates.includes(trackPub)) {
        publicationCandidates.push(trackPub);
      }
    });
    return publicationCandidates.some((pub) => {
      if (!pub) return false;
      if (pub.muted) return false;
      if (pub.source && pub.source !== 'camera') return false;
      return !!pub.persistentTrack || !!pub.track;
    });
  }

  function getParticipantRole(participant) {
    const userData = getParticipantUserData(participant);
    if (userData && typeof userData.role === 'string') {
      return userData.role;
    }
    const fallbackName = participant?.user_name || '';
    return fallbackName.includes('Viewer_') ? 'spectator' : 'participant';
  }

  function getParticipantUserId(participant) {
    const userData = getParticipantUserData(participant);
    const candidateId = userData?.userId || userData?.user_id;
    return isValidUuid(candidateId) ? candidateId : null;
  }

  function getServerNow() {
    return Date.now() + serverTimeOffset;
  }

  function getRealtimeDatabaseRestUrl(baseUrl, path) {
    if (!baseUrl) {
      throw new Error('Realtime Database base URL is not configured');
    }
    const normalizedBase = baseUrl.replace(/\/$/, '');
    const normalizedPath = String(path || '').replace(/^\//, '');
    return `${normalizedBase}/${normalizedPath}.json`;
  }

  function buildRealtimeQueryUrl(baseUrl, path, params = {}) {
    const url = new URL(getRealtimeDatabaseRestUrl(baseUrl, path));
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    });
    return url.toString();
  }

  async function getAuthedRealtimeUrl(baseUrl, path, params = {}) {
    const url = new URL(getRealtimeDatabaseRestUrl(baseUrl, path));
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    });
    const token = await getFirebaseIdToken();
    url.searchParams.set('auth', token);
    return url.toString();
  }

  async function getPromptsAuthedRealtimeUrl(path, params = {}) {
    const url = new URL(getRealtimeDatabaseRestUrl(promptsDatabaseBaseUrl, path));
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    });
    const token = await getPromptsIdToken();
    if (token) {
      url.searchParams.set('auth', token);
    }
    return url.toString();
  }

  function hideWaitingOverlay() {
    console.log('üé¨ Hiding waiting overlay...');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const videoInterface = document.getElementById('video-interface');
    if (waitingOverlay) {
      waitingOverlay.style.display = 'none';
      waitingOverlay.classList.add('hidden');
    }
    if (videoInterface) {
      videoInterface.classList.remove('hidden');
      videoInterface.style.display = 'block';
    }
    console.log('‚úÖ Waiting overlay hidden, video interface shown');
  }
  
  // Fallback to ensure overlay is hidden after timeout
  function ensureWaitingOverlayHidden(timeoutMs = 10000) {
    setTimeout(() => {
      const waitingOverlay = document.getElementById('waiting-overlay');
      if (waitingOverlay && waitingOverlay.style.display !== 'none') {
        console.warn('‚ö†Ô∏è Force-hiding stuck waiting overlay after timeout');
        hideWaitingOverlay();
      }
    }, timeoutMs);
  }

    // LiveKit helpers --------------------------------------------------------
    function loadLiveKitSdkScript() {
      return new Promise((resolve, reject) => {
        const existing = document.querySelector('script[data-livekit-sdk]');
        if (existing) {
          if (existing.dataset.loaded === 'true') {
            resolve();
            return;
          }
          existing.addEventListener('load', () => resolve(), { once: true });
          existing.addEventListener('error', (event) => reject(new Error('Failed to load LiveKit SDK script.')), { once: true });
          return;
        }

        let sourceIndex = 0;

        const tryNextSource = () => {
          if (sourceIndex >= LIVEKIT_SDK_SOURCES.length) {
            reject(new Error('Failed to load LiveKit SDK script from all sources.'));
            return;
          }

          const src = LIVEKIT_SDK_SOURCES[sourceIndex++];
          const script = document.createElement('script');
          script.src = src;
          script.async = true;
          script.dataset.livekitSdk = 'true';

          const cleanup = () => {
            script.removeEventListener('load', onLoad);
            script.removeEventListener('error', onError);
          };

          const onLoad = () => {
            cleanup();
            script.dataset.loaded = 'true';
            console.info(`‚úÖ LiveKit SDK loaded from ${src}`);
            resolve();
          };

          const onError = () => {
            cleanup();
            script.remove();
            console.warn(`‚ö†Ô∏è Failed to load LiveKit SDK from ${src}, trying next source...`);
            tryNextSource();
          };

          script.addEventListener('load', onLoad, { once: true });
          script.addEventListener('error', onError, { once: true });
          document.head.appendChild(script);
        };

        tryNextSource();
      });
    }

    function resolveLiveKitGlobal() {
      const candidates = [
        window.LiveKitClient,
        window.LivekitClient,
        window.livekitClient,
        window.livekitclient,
        window.LiveKit,
        window.Livekit,
        window.livekit,
        window.liveKit,
        globalThis?.LiveKitClient,
        globalThis?.LivekitClient,
        globalThis?.livekitClient,
        globalThis?.livekit,
      ];

      for (const candidate of candidates) {
        if (!candidate) {
          continue;
        }
        if (candidate.default && typeof candidate.default === 'object') {
          return candidate.default;
        }
        return candidate;
      }
      return null;
    }

    function logLiveKitDiagnostics(sdk, context = 'unknown') {
      try {
        const keys = sdk ? Object.keys(sdk).slice(0, 40) : [];
        console.groupCollapsed(`‚ÑπÔ∏è LiveKit SDK diagnostics (${context})`);
        console.log('keys', keys);
        if (sdk?.Room) {
          console.log('Room keys', Object.keys(sdk.Room).slice(0, 20));
        }
        if (sdk?.Track) {
          console.log('Track keys', Object.keys(sdk.Track).slice(0, 20));
        }
        console.groupEnd();
      } catch (error) {
        console.warn('Unable to log LiveKit diagnostics', error);
      }
    }

    function ensureLiveKitConnectShim(sdk) {
      if (!sdk) {
        return false;
      }
      if (typeof sdk.connect === 'function') {
        return true;
      }
      if (typeof sdk.Room !== 'function') {
        return false;
      }
      try {
        console.warn('‚ö†Ô∏è LiveKit SDK missing connect(); installing compatibility shim.');
        sdk.connect = async function liveKitConnectShim(url, token, options = {}) {
          const {
            room: providedRoom,
            roomOptions,
            ...connectOptions
          } = options || {};
          const roomInstance =
            providedRoom instanceof sdk.Room
              ? providedRoom
              : new sdk.Room(roomOptions);
          await roomInstance.connect(url, token, connectOptions);
          return roomInstance;
        };
        return true;
      } catch (error) {
        console.error('‚ùå Failed to install LiveKit connect() shim.', error);
        return false;
      }
    }

    function hydrateLiveKitSdk(candidate, sourceLabel = 'global') {
      if (!candidate) {
        return false;
      }

      const sdk =
        (candidate.default && typeof candidate.default === 'object' && candidate.default) || candidate;

      LiveKitSDK = sdk;

      LiveKitRoomEvent =
        sdk.RoomEvent ||
        sdk.Room?.RoomEvent ||
        sdk.Room?.Events ||
        sdk.Room?.Event ||
        sdk.default?.RoomEvent ||
        LiveKitRoomEvent ||
        null;

      LiveKitTrackSource =
        sdk.TrackSource ||
        sdk.Track?.TrackSource ||
        sdk.Track?.Source ||
        sdk.default?.TrackSource ||
        LiveKitTrackSource ||
        null;

      LiveKitDataPacketKind =
        sdk.DataPacket_Kind ||
        sdk.DataPacketKind ||
        sdk.DataPacket?.Kind ||
        sdk.default?.DataPacket_Kind ||
        sdk.default?.DataPacketKind ||
        LiveKitDataPacketKind ||
        null;

      const hasConnect = ensureLiveKitConnectShim(sdk);
      if (!hasConnect) {
        console.warn(`‚ùå LiveKit SDK candidate is missing connect() (${sourceLabel}).`);
        logLiveKitDiagnostics(sdk, `${sourceLabel}:missing-connect`);
        return false;
      }

      if (!LiveKitRoomEvent || !LiveKitTrackSource || !LiveKitDataPacketKind) {
        console.warn('‚ö†Ô∏è LiveKit SDK missing some enums, continuing anyway.', {
          hasRoomEvent: Boolean(LiveKitRoomEvent),
          hasTrackSource: Boolean(LiveKitTrackSource),
          hasDataPacketKind: Boolean(LiveKitDataPacketKind),
          sourceLabel,
        });
        logLiveKitDiagnostics(sdk, `${sourceLabel}:partial`);
      }

      return true;
    }

    function assignLiveKitGlobals() {
      const resolved = resolveLiveKitGlobal();
      if (!resolved) {
        LiveKitSDK = null;
        return false;
      }

      return hydrateLiveKitSdk(resolved, 'global');
    }

    async function loadLiveKitEsmFallback() {
      for (const src of LIVEKIT_ESM_SOURCES) {
        try {
          console.info(`‚ÑπÔ∏è Attempting LiveKit ESM import from ${src}`);
          const module = await import(/* webpackIgnore: true */ src);
          if (!hydrateLiveKitSdk(module, `esm:${src}`)) {
            console.warn(`‚ö†Ô∏è LiveKit ESM bundle from ${src} missing expected exports, trying next source...`);
            continue;
          }
          console.info(`‚úÖ LiveKit SDK loaded via ESM import from ${src}`);
          return true;
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to import LiveKit ESM bundle from ${src}:`, error);
        }
      }
      return false;
    }

    async function ensureLiveKitSDKLoaded(timeout = 10000) {
      if (assignLiveKitGlobals()) {
        return;
      }
      const startTime = Date.now();
      while (!resolveLiveKitGlobal()) {
        if (!document.querySelector('script[data-livekit-sdk]')) {
          try {
            await loadLiveKitSdkScript();
          } catch (error) {
            console.error(error);
            break;
          }
        }
        if (Date.now() - startTime > timeout) {
          throw new Error('LiveKit SDK failed to load. Ensure the CDN script is available.');
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      if (assignLiveKitGlobals()) {
        return;
      }
      if (await loadLiveKitEsmFallback()) {
        return;
      }
      throw new Error('LiveKit SDK failed to initialize. Global exports missing.');
    }

    async function ensureLiveKitConfigReady() {
      await ensureLiveKitSDKLoaded();
      if (!LIVEKIT_WS_URL || LIVEKIT_WS_URL.includes('YOUR-LIVEKIT-HOST')) {
        throw new Error('LiveKit WebSocket URL is not configured.');
      }
      if (!LIVEKIT_TOKEN_ENDPOINT) {
        throw new Error('LiveKit token endpoint is not configured.');
      }
    }

    function sanitizeLiveKitIdentity(value) {
      const fallback = `user_${Math.random().toString(36).slice(2, 8)}`;
      if (!value) return fallback;
      let sanitized = value.toString().trim();
      sanitized = sanitized.replace(/[^a-zA-Z0-9_-]/g, '_');
      if (sanitized.length > 48) {
        sanitized = sanitized.slice(0, 48);
      }
      return sanitized || fallback;
    }

    function parseLiveKitMetadata(raw) {
      if (!raw) return null;
      if (typeof raw === 'object') return raw;
      try {
        return JSON.parse(raw);
      } catch (error) {
        console.warn('‚ö†Ô∏è Unable to parse LiveKit metadata JSON:', error);
        return null;
      }
    }

    function resolveTrackPublication(participant, source) {
      if (!participant || !source) return null;
      if (typeof participant.getTrack === 'function') {
        return participant.getTrack(source) || null;
      }
      const publications = participant.trackPublications || participant.tracks;
      if (publications && typeof publications.values === 'function') {
        for (const publication of publications.values()) {
          if (publication?.source === source) {
            return publication;
          }
        }
      }
      return null;
    }

    function publicationToTrackEntry(publication) {
      if (!publication) return null;
      const mediaStreamTrack = publication.track?.mediaStreamTrack || publication.track || null;
      const kind = publication.kind || (publication.source === LiveKitTrackSource.Microphone ? 'audio' : 'video');
      return {
        state: publication.isMuted ? 'blocked' : 'playable',
        subscribed: !!publication.isSubscribed,
        kind,
        persistentTrack: mediaStreamTrack,
        track: mediaStreamTrack,
        rawPublication: publication
      };
    }

    function normalizeLiveKitParticipant(participant, overrides = {}) {
      if (!participant) return null;
      const metadata = parseLiveKitMetadata(participant.metadata);
      const tracks = {};
      if (LiveKitTrackSource) {
        tracks.audio = publicationToTrackEntry(resolveTrackPublication(participant, LiveKitTrackSource.Microphone));
        tracks.video = publicationToTrackEntry(resolveTrackPublication(participant, LiveKitTrackSource.Camera));
        tracks.screenVideo = publicationToTrackEntry(resolveTrackPublication(participant, LiveKitTrackSource.ScreenShare));
        tracks.screenAudio = publicationToTrackEntry(resolveTrackPublication(participant, LiveKitTrackSource.ScreenShareAudio));
      }

      return {
        session_id: participant.sid || participant.identity || participant.participantSid,
        user_name: metadata?.displayName || metadata?.username || participant.name || participant.identity,
        local: overrides.local ?? participant.isLocal ?? false,
        userData: metadata,
        tracks,
        lastSpokeAt: participant.lastSpokeAt || null
      };
    }

    function forEachLiveKitParticipantCollection(collection, callback) {
      if (!collection || typeof callback !== 'function') {
        return;
      }

      if (typeof collection.forEach === 'function') {
        collection.forEach((participant, key) => {
          callback(participant, key);
        });
        return;
      }

      const entries = Array.isArray(collection)
        ? collection.entries()
        : Object.entries(collection);

      for (const [key, participant] of entries) {
        callback(participant, key);
      }
    }

    function forEachRemoteLiveKitParticipant(callback) {
      if (!livekitRoom || typeof callback !== 'function') {
        return;
      }

      const visited = new Set();
      const visit = (participant, key) => {
        if (!participant) return;
        if (participant.local || participant.isLocal) return;
        const uniqueKey = participant.sid || participant.identity || participant.participantSid || key;
        if (!uniqueKey || visited.has(uniqueKey)) return;
        visited.add(uniqueKey);
        callback(participant, uniqueKey);
      };

      const candidateCollections = [
        livekitRoom.participants,
        livekitRoom.remoteParticipants,
        typeof livekitRoom.getParticipants === 'function' ? livekitRoom.getParticipants() : null,
        typeof livekitRoom.getRemoteParticipants === 'function' ? livekitRoom.getRemoteParticipants() : null
      ];

      candidateCollections.forEach((collection) => {
        if (!collection) return;
        try {
          forEachLiveKitParticipantCollection(collection, visit);
        } catch (error) {
          console.warn('‚ö†Ô∏è Unable to iterate LiveKit participant collection:', error);
        }
      });
    }

    function getParticipantsSnapshot() {
      if (!livekitRoom) return {};
      const snapshot = {};
      const seen = new Set();

      if (livekitRoom.localParticipant) {
        const localParticipant = normalizeLiveKitParticipant(livekitRoom.localParticipant, { local: true });
        if (localParticipant?.session_id) {
          snapshot[localParticipant.session_id] = localParticipant;
          snapshot.local = localParticipant;
          seen.add(localParticipant.session_id);
        }
      }

      forEachRemoteLiveKitParticipant((participant) => {
        const normalized = normalizeLiveKitParticipant(participant, { local: false });
        if (normalized?.session_id && !seen.has(normalized.session_id)) {
          snapshot[normalized.session_id] = normalized;
          seen.add(normalized.session_id);
        }
      });

      return snapshot;
    }

    function publishLiveKitDataMessage(payload) {
      if (!livekitRoom || !livekitRoom.localParticipant) {
        console.warn('‚ö†Ô∏è LiveKit room or local participant not ready');
        return false;
      }
      try {
        const message = typeof payload === 'string' ? payload : JSON.stringify(payload);
        const encoder = new TextEncoder();
        const data = encoder.encode(message);
        
        // Try different approaches for different LiveKit SDK versions
        if (LiveKitDataPacketKind && LiveKitDataPacketKind.RELIABLE !== undefined) {
          // Older SDK style: publishData(data, kind)
          livekitRoom.localParticipant.publishData(data, LiveKitDataPacketKind.RELIABLE);
        } else {
          // Newer SDK style: publishData(data, options) or publishData(data, { reliable: true })
          livekitRoom.localParticipant.publishData(data, { reliable: true });
        }
        console.log('üì° LiveKit data message published successfully');
        return true;
      } catch (error) {
        console.error('‚ùå Failed to send LiveKit data message:', error);
        return false;
      }
    }

    function buildControlApiHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      if (LIVEKIT_CONTROL_API_KEY) {
        headers['x-api-key'] = LIVEKIT_CONTROL_API_KEY;
      }
      return headers;
    }

    function coerceLiveKitTokenValue(tokenValue, depth = 0) {
      if (!tokenValue || depth > 5) {
        return null;
      }
      if (typeof tokenValue === 'string') {
        return tokenValue;
      }
      if (typeof tokenValue === 'object') {
        const candidateKeys = ['token', 'accessToken', 'jwt', 'value'];
        for (const key of candidateKeys) {
          if (key in tokenValue) {
            const nested = coerceLiveKitTokenValue(tokenValue[key], depth + 1);
            if (nested) {
              return nested;
            }
          }
        }
        if (tokenValue instanceof String) {
          return tokenValue.toString();
        }
      }
      return null;
    }

    async function fetchLiveKitAccessToken({ roomName, identity, metadata }) {
      await ensureLiveKitConfigReady();
      const payload = {
        roomName,
        identity,
        metadata,
        role: metadata?.role || (isSpectator ? 'spectator' : 'participant'),
        displayName: metadata?.displayName || userName
      };
      const response = await fetch(LIVEKIT_TOKEN_ENDPOINT, {
        method: 'POST',
        headers: buildControlApiHeaders(),
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const contentType = response.headers.get('content-type') || '';
        let serverPayload = null;
        let fallbackText = '';
        if (contentType.includes('application/json')) {
          serverPayload = await response.json().catch(() => null);
        } else {
          fallbackText = await response.text().catch(() => '');
        }
        const serverMessage =
          (serverPayload && typeof serverPayload.message === 'string' && serverPayload.message.trim().length > 0
            ? serverPayload.message.trim()
            : null) ||
          (serverPayload && typeof serverPayload.error === 'string' && serverPayload.error.trim().length > 0
            ? serverPayload.error.trim()
            : null);
        const detail = serverMessage || fallbackText || response.statusText || 'token request failed';
        const error = new Error(serverMessage || `LiveKit token request failed (${response.status}): ${detail}`);
        error.code = serverPayload?.error || 'token_request_failed';
        error.status = response.status;
        error.details = serverPayload || fallbackText;
        throw error;
      }
      const result = await response.json().catch(() => null);
      const rawToken = result?.token ?? result;
      const normalizedToken = coerceLiveKitTokenValue(rawToken);
      if (!normalizedToken) {
        console.error('‚ùå LiveKit token endpoint response was invalid:', result);
        throw new Error('LiveKit token endpoint did not return a usable token.');
      }
      if (typeof rawToken !== 'string') {
        console.warn('‚ö†Ô∏è Normalized nested LiveKit token payload.');
      }
      return normalizedToken;
    }

    function resolvePresenceRoomKeyValue() {
      if (typeof firebaseRoomId === 'string' && firebaseRoomId.length > 0) {
        return firebaseRoomId;
      }
      if (roomUrl) {
        try {
          return btoa(roomUrl);
        } catch (error) {
          console.warn('‚ö†Ô∏è Unable to encode room URL for presence key:', error);
        }
      }
      return null;
    }

    function getLiveKitMetadataPayload() {
      return {
        role: isSpectator ? 'spectator' : 'participant',
        userId: window.currentUserData?.isAuthenticated && isValidUuid(userId) ? userId : null,
        displayName: window.currentUserData?.displayName || userName,
        avatar: window.currentUserData?.avatar || null,
        sphereId: isValidUuid(conversationSphereId) ? conversationSphereId : null,
        slug: conversationSlug || null,
        roomId: conversationRoomId || null,
        roomUrl: roomUrl || null,
        presenceRoomKey: resolvePresenceRoomKeyValue()
      };
    }

    function buildLiveKitTrackForEvents(track, publication) {
      if (!track) return null;
      const mediaTrack = track.mediaStreamTrack instanceof MediaStreamTrack ? track.mediaStreamTrack : (track instanceof MediaStreamTrack ? track : null);
      if (mediaTrack && publication?.source === LiveKitTrackSource.ScreenShare && !mediaTrack.label) {
        try {
          Object.defineProperty(mediaTrack, 'label', {
            value: 'livekit-screen-share',
            configurable: true
          });
        } catch (_) {
          mediaTrack.label = 'livekit-screen-share';
        }
      }
      return mediaTrack;
    }

    function registerLiveKitEventHandlers() {
      if (!livekitRoom || !LiveKitRoomEvent) {
        return;
      }
      livekitRoom
        .on(LiveKitRoomEvent.ParticipantConnected, (participant) => {
          if (isSpectator) {
            ensureSpectatorTracksForParticipant(participant);
          }
          handleParticipantJoined({ participant: normalizeLiveKitParticipant(participant, { local: false }) });
        })
        .on(LiveKitRoomEvent.ParticipantDisconnected, (participant) => {
          handleParticipantLeft({ participant: normalizeLiveKitParticipant(participant, { local: false }) });
        })
        .on(LiveKitRoomEvent.ParticipantMetadataChanged, (participant) => {
          handleParticipantUpdated({ participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid }) });
        })
        .on(LiveKitRoomEvent.TrackSubscribed, (track, publication, participant) => {
          handleTrackStarted({
            participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid }),
            track: buildLiveKitTrackForEvents(track, publication)
          });
        })
        .on(LiveKitRoomEvent.TrackUnsubscribed, (track, publication, participant) => {
          handleTrackStopped({
            participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid }),
            track: buildLiveKitTrackForEvents(track, publication)
          });
        })
        .on(LiveKitRoomEvent.TrackMuted, (_, participant) => {
          handleParticipantUpdated({ participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid }) });
        })
        .on(LiveKitRoomEvent.TrackUnmuted, (_, participant) => {
          handleParticipantUpdated({ participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid }) });
        })
        .on(LiveKitRoomEvent.DataReceived, (payload, participant) => {
          let data = null;
          try {
            if (typeof payload === 'string') {
              data = JSON.parse(payload);
            } else if (payload instanceof ArrayBuffer) {
              data = JSON.parse(textDecoder.decode(payload));
            } else if (ArrayBuffer.isView(payload)) {
              data = JSON.parse(textDecoder.decode(payload));
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Unable to parse LiveKit data payload:', error);
          }
          if (data) {
            handleAppMessage({
              data,
              participant: normalizeLiveKitParticipant(participant, { local: participant?.sid === livekitRoom?.localParticipant?.sid })
            });
          }
        })
        .on(LiveKitRoomEvent.Disconnected, (reason) => {
          console.warn('‚ö†Ô∏è LiveKit disconnected:', reason);
          handleLeftMeeting(reason);
        })
        .on(LiveKitRoomEvent.Reconnecting, () => {
          showToast('üì° Reconnecting to LiveKit...');
        })
        .on(LiveKitRoomEvent.Reconnected, () => {
          showToast('‚úÖ Reconnected to LiveKit');
        });
    }

    async function connectToLiveKitRoom() {
      console.log('üîå connectToLiveKitRoom() called');
      console.log('üåê Browser info:', {
        isSafari,
        isIOS,
        isMobileSafari,
        userGestureReceived,
        userAgent: navigator.userAgent.substring(0, 100)
      });
      
      await ensureLiveKitConfigReady();
      console.log('‚úÖ LiveKit config ready');
      
      const metadata = getLiveKitMetadataPayload();
      const baseIdentity = metadata?.userId || userId || userName || `guest_${Date.now()}`;
      const runtimeId = window.__CHATSPHERES_RUNTIME_INSTANCE_ID || runtimeInstanceId || Math.random().toString(36);
      const runtimeSegment = runtimeId.replace(/[^a-zA-Z0-9]/g, '').slice(-8) || Math.random().toString(36).slice(2, 10);
      const tabSegment = (window.__CHATSPHERES_TAB_INSTANCE_ID || '').replace(/[^a-zA-Z0-9]/g, '').slice(-6);
      const sessionSegment = (conversationSessionId || '').replace(/[^a-zA-Z0-9]/g, '').slice(0, 6);

      const uniquePrefixParts = ['cs', runtimeSegment];
      if (tabSegment) uniquePrefixParts.push(tabSegment);
      if (sessionSegment) uniquePrefixParts.push(sessionSegment);
      const uniquePrefix = uniquePrefixParts.join('_');

      const sanitizedBase = (baseIdentity || '').replace(/[^a-zA-Z0-9]/g, '');
      const availableLength = Math.max(8, 48 - uniquePrefix.length - 1);
      const baseTail = sanitizedBase.slice(-availableLength) || Math.random().toString(36).slice(2, 2 + availableLength);
      livekitIdentity = sanitizeLiveKitIdentity(`${uniquePrefix}_${baseTail}`);
      livekitRoomName = conversationRoomId || extractRoomIdentifier(roomUrl) || metadata?.slug || 'chatspheres-room';
      
      console.log('üè† Room connection details:', {
        livekitRoomName,
        livekitIdentity: livekitIdentity.substring(0, 20) + '...',
        isSpectator,
        wsUrl: LIVEKIT_WS_URL
      });
      
      // For Safari, mark gesture as received since user clicked to join
      if (isSafari) {
        userGestureReceived = true;
        console.log('üçé Safari: User gesture marked as received');
      }
      
      const token = await fetchLiveKitAccessToken({
        roomName: livekitRoomName,
        identity: livekitIdentity,
        metadata
      });
      console.log('üéüÔ∏è LiveKit token obtained');
      
      // Build connection options with Safari-specific settings
      const connectOptions = {
        audio: !isSpectator,
        video: !isSpectator,
        autoSubscribe: true,
        adaptiveStream: true,
        dynacast: true,
        publishDefaults: {
          videoSimulcastLayers: [
            { width: 320, height: 180, bitrate: 250_000 },
            { width: 640, height: 360, bitrate: 700_000 },
            { width: 1280, height: 720, bitrate: 1_500_000 }
          ]
        }
      };
      
      // Safari-specific options
      if (isSafari) {
        console.log('üçé Applying Safari-specific connection options');
        // Safari works better with these settings
        connectOptions.adaptiveStream = false; // Safari has issues with adaptive stream
        connectOptions.dynacast = false; // Disable for Safari stability
      }
      
      console.log('üîó Connecting to LiveKit room with options:', connectOptions);
      
      try {
        livekitRoom = await LiveKitSDK.connect(LIVEKIT_WS_URL, token, connectOptions);
        console.log('‚úÖ LiveKit room connected successfully!', {
          roomName: livekitRoom.name,
          localParticipantSid: livekitRoom.localParticipant?.sid,
          state: livekitRoom.state
        });
        
        // Hide waiting overlay after successful connection
        hideWaitingOverlay();
        
      } catch (connectError) {
        console.error('‚ùå LiveKit connection failed:', connectError);
        hideWaitingOverlay();
        
        if (isSafari) {
          showToast('üçé Safari: Please allow camera/microphone access');
        }
        
        throw connectError;
      }
      
      registerLiveKitEventHandlers();
      console.log('‚úÖ LiveKit event handlers registered');
      
      // CRITICAL: Process existing remote participants immediately after connection
      // This catches participants who joined before us and already have published tracks
      if (!isSpectator && livekitRoom) {
        console.log('üîç Checking for existing remote participants immediately...');
        const existingRemoteCount = livekitRoom.remoteParticipants.size;
        console.log(`üë• Found ${existingRemoteCount} existing remote participants`);
        
        if (existingRemoteCount > 0) {
          // Process each existing participant
          for (const [sid, participant] of livekitRoom.remoteParticipants) {
            console.log(`üë§ Processing existing participant: ${participant.identity} (${sid.substring(0, 12)})`);
            
            // CRITICAL: Skip spectators - we only want actual debate participants for 1:1 view
            const participantData = normalizeLiveKitParticipant(participant, { local: false });
            const participantRole = getParticipantRole(participantData);
            if (participantRole === 'spectator') {
              console.log(`‚è≠Ô∏è Skipping spectator: ${participant.identity}`);
              continue;
            }
            
            // Check for video tracks
            for (const pub of participant.videoTrackPublications.values()) {
              // Skip screen share tracks
              if (pub.source?.includes('screen')) continue;
              
              console.log(`üìπ Video publication for ${participant.identity}:`, {
                source: pub.source,
                hasTrack: !!pub.track,
                isSubscribed: pub.isSubscribed,
                subscriptionStatus: pub.subscriptionStatus
              });
              
              // If track exists and is subscribed
              if (pub.track) {
                console.log(`üé• Found existing video track for ${participant.identity}`);
                const track = pub.track.mediaStreamTrack || pub.track;
                if (track?.readyState === 'live') {
                  setupRemoteVideo(track);
                  updateRemoteInfo(participant.identity || 'Guest');
                  hideWaitingOverlay();
                  
                  // Track this as the other participant
                  const participantData = normalizeLiveKitParticipant(participant, { local: false });
                  const remoteUserId = getParticipantUserId(participantData);
                  if (remoteUserId) {
                    updateOtherParticipant(remoteUserId, participant.identity);
                    
                    // Update pot targets for Red Room
                    if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
                      updatePotTargets();
                      // Reload pot state from Supabase to ensure fresh data
                      if (typeof loadPotStateFromSupabase === 'function') {
                        loadPotStateFromSupabase();
                      }
                    }
                  }
                  break;
                }
              } else if (pub.isSubscribed === false && typeof pub.setSubscribed === 'function') {
                // Track exists but not subscribed - subscribe to it
                console.log(`üì° Subscribing to video track for ${participant.identity}`);
                try {
                  pub.setSubscribed(true);
                } catch (e) {
                  console.log('‚ö†Ô∏è Could not subscribe:', e.message);
                }
              }
            }
            
            // Check for audio tracks
            for (const pub of participant.audioTrackPublications.values()) {
              if (pub.track) {
                console.log(`üîä Found existing audio track for ${participant.identity}`);
                const track = pub.track.mediaStreamTrack || pub.track;
                if (track) {
                  setupRemoteAudio(track);
                }
                break;
              } else if (pub.isSubscribed === false && typeof pub.setSubscribed === 'function') {
                console.log(`üì° Subscribing to audio track for ${participant.identity}`);
                try {
                  pub.setSubscribed(true);
                } catch (e) {
                  console.log('‚ö†Ô∏è Could not subscribe to audio:', e.message);
                }
              }
            }
          }
        }
      }
      
      if (isSpectator) {
        console.log('üëÄ Spectator mode: hydrating tracks after delay');
        hydrateSpectatorTracksFromLiveKit(500);
      }
      if (!isSpectator && livekitRoom?.localParticipant) {
        console.log('üé§üìπ Participant mode: enabling local media...');
        try {
          await livekitRoom.localParticipant.setMicrophoneEnabled(true);
          isMicOn = true;
          console.log('‚úÖ Microphone enabled');
        } catch (error) {
          console.warn('üé§ Unable to enable microphone automatically:', error.message);
          isMicOn = false;
          if (isSafari) {
            showToast('üé§ Tap the mic button to enable your microphone');
          }
        }
        try {
          await livekitRoom.localParticipant.setCameraEnabled(true);
          isCameraOn = true;
          console.log('‚úÖ Camera enabled');
        } catch (error) {
          console.warn('üìπ Unable to enable camera automatically:', error.message);
          isCameraOn = false;
          if (isSafari) {
            showToast('üìπ Tap the camera button to enable your camera');
          }
        }
      } else {
        isMicOn = false;
        isCameraOn = false;
      }
      return livekitRoom;
    }

    async function switchLiveKitDevice(kind, deviceId) {
      if (!livekitRoom) {
        throw new Error('LiveKit room not connected');
      }
      if (typeof livekitRoom.switchActiveDevice === 'function') {
        await livekitRoom.switchActiveDevice(kind, deviceId);
      } else {
        throw new Error('Active device switching is not supported in this LiveKit SDK version.');
      }
    }

  async function ensureConversationSessionStarted(contextLabel = 'default') {
    if (isSpectator) {
      console.log(`‚ÑπÔ∏è [${contextLabel}] Spectator detected - skipping session creation`);
      return null;
    }

    if (!supabaseClient) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase client unavailable - session lifecycle disabled`);
      return null;
    }

    if (!window.currentUserData?.isAuthenticated || !isValidUuid(userId)) {
      console.log(`‚ÑπÔ∏è [${contextLabel}] Anonymous or invalid user - skipping Supabase session tracking`);
      return null;
    }

    if (!conversationRoomId) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] No conversation room identifier - cannot start session`);
      return null;
    }

    if (conversationSessionId) {
      return conversationSessionId;
    }

    if (ensureSessionPromise) {
      return ensureSessionPromise;
    }

    ensureSessionPromise = (async () => {
      try {
        console.log(`ü™Ñ [${contextLabel}] Ensuring active conversation session for user ${userId}`);

        const { data: existingSession, error: existingError } = await supabaseClient
          .from('conversation_sessions')
          .select('id, started_at, sphere_id, partner_user_id')
          .eq('user_id', userId)
          .eq('room_id', conversationRoomId)
          .is('ended_at', null)
          .order('joined_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (existingError && existingError.code !== 'PGRST116') {
          throw existingError;
        }

        if (existingSession?.id) {
          conversationSessionId = existingSession.id;
          conversationSessionStartedAt = existingSession.started_at || conversationSessionStartedAt;
          if (!conversationSphereId && existingSession.sphere_id) {
            conversationSphereId = existingSession.sphere_id;
          }
          if (existingSession.partner_user_id && isValidUuid(existingSession.partner_user_id)) {
            conversationPartnerId = existingSession.partner_user_id;
          }
          console.log(`‚úÖ [${contextLabel}] Reusing active conversation session ${conversationSessionId}`);
          return conversationSessionId;
        }

        const payload = {
          p_room_id: conversationRoomId || roomUrl,
          p_user_id: userId,
          p_sphere_id: isValidUuid(conversationSphereId) ? conversationSphereId : null,
          p_partner_user_id: isValidUuid(conversationPartnerId) ? conversationPartnerId : null
        };

        const { data: sessionIdFromRpc, error: rpcError } = await supabaseClient.rpc('start_conversation_session', payload);

        if (rpcError) {
          throw rpcError;
        }

        if (sessionIdFromRpc) {
          conversationSessionId = typeof sessionIdFromRpc === 'string'
            ? sessionIdFromRpc
            : sessionIdFromRpc.id || null;
          conversationSessionStartedAt = new Date().toISOString();
          console.log(`‚úÖ [${contextLabel}] Started new conversation session ${conversationSessionId}`);
        } else {
          console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase RPC returned without session id`);
        }

        return conversationSessionId;
      } catch (error) {
        console.error(`‚ùå [${contextLabel}] Failed to ensure conversation session:`, error);
        return null;
      } finally {
        ensureSessionPromise = null;
      }
    })();

    return ensureSessionPromise;
  }

  async function updatePartnerUserId(partnerId, contextLabel = 'partner-link') {
    if (!isValidUuid(partnerId)) {
      return;
    }

    if (isSpectator) {
      return;
    }

    if (!supabaseClient) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Supabase client unavailable - cannot link partner`);
      return;
    }

    await ensureConversationSessionStarted(contextLabel);

    if (!conversationSessionId) {
      console.warn(`‚ö†Ô∏è [${contextLabel}] Unable to link partner - session id missing`);
      return;
    }

    if (conversationPartnerId === partnerId) {
      return;
    }

    try {
      const { error } = await supabaseClient
        .from('conversation_sessions')
        .update({ partner_user_id: partnerId })
        .eq('id', conversationSessionId);

      if (error) {
        throw error;
      }

      conversationPartnerId = partnerId;
      console.log(`ü§ù [${contextLabel}] Linked partner ${partnerId} to session ${conversationSessionId}`);
    } catch (error) {
      console.error(`‚ùå [${contextLabel}] Failed to update partner user id:`, error);
    }
  }

  async function endConversationSession(reason) {
    if (isSpectator) {
      console.log('üëÄ Spectator - skipping session end (no charges)');
      conversationSessionEndState.ended = true;
      return;
    }

    if (conversationSessionEndState.ended || conversationSessionEndState.inFlight) {
      console.log('‚ö†Ô∏è Session already ended or ending in progress');
      return;
    }

    if (!supabaseClient) {
      console.error('‚ùå CRITICAL: Supabase client not initialized - minutes will NOT be charged!');
      conversationSessionEndState.ended = true;
      return;
    }

    if (!window.currentUserData?.isAuthenticated || !isValidUuid(userId)) {
      console.log('‚ÑπÔ∏è Skipping Supabase session end for anonymous or invalid user');
      conversationSessionEndState.ended = true;
      return;
    }

    const primaryRoomIdentifier = conversationRoomId;
    const base64RoomUrl = (() => {
      if (!roomUrl) return null;
      try {
        return btoa(roomUrl);
      } catch (encodeError) {
        console.debug('‚ÑπÔ∏è Unable to base64 encode room URL for session end candidates (non-blocking).', encodeError);
        return null;
      }
    })();

    console.log(`üíæ Ending conversation session - Reason: ${reason || 'unspecified'}`);
    console.log(`üë§ User ID: ${userId}`);
    console.log(`üè† Primary Room Identifier: ${primaryRoomIdentifier || 'none'}`);

    conversationSessionEndState.inFlight = true;

    try {
      let resolvedSessionId = conversationSessionId;
      if (!resolvedSessionId) {
        resolvedSessionId = await ensureConversationSessionStarted('end-session');
      }

      const candidateRoomIds = new Set(
        [primaryRoomIdentifier, roomUrl, firebaseRoomId, conversationSlug, base64RoomUrl]
          .filter((value) => typeof value === 'string' && value.length > 0)
      );

      const candidateSphereIds = new Set(
        [conversationSphereId].filter((value) => typeof value === 'string' && value.length > 0)
      );

      if (primaryRoomIdentifier && primaryRoomIdentifier.startsWith('sphere-')) {
        candidateSphereIds.add(primaryRoomIdentifier.replace(/^sphere-/, ''));
      }
      if (conversationSlug && conversationSlug.startsWith('sphere-')) {
        candidateSphereIds.add(conversationSlug.replace(/^sphere-/, ''));
      }

      let recentSessions = [];

      if (!resolvedSessionId) {
        const { data: sessionsData, error: sessionsError } = await supabaseClient
          .from('conversation_sessions')
          .select('id, room_id, sphere_id, status, ended_at, started_at')
          .eq('user_id', userId)
          .order('joined_at', { ascending: false })
          .limit(10);

        if (sessionsError) {
          console.error('‚ùå Supabase error retrieving sessions during cleanup:', sessionsError);
        } else if (Array.isArray(sessionsData)) {
          recentSessions = sessionsData;
          sessionsData.forEach((session) => {
            if (session?.room_id) {
              candidateRoomIds.add(session.room_id);
            }
            if (session?.sphere_id) {
              candidateSphereIds.add(session.sphere_id);
            }
          });

          const matchingSession = sessionsData.find((session) => {
            if (session?.ended_at || session?.status !== 'active') return false;
            const roomMatch = session?.room_id && candidateRoomIds.has(session.room_id);
            const sphereMatch = session?.sphere_id && candidateSphereIds.has(session.sphere_id);
            return roomMatch || sphereMatch;
          });

          if (matchingSession) {
            resolvedSessionId = matchingSession.id;
            conversationSessionId = matchingSession.id;
            conversationSessionStartedAt = matchingSession.started_at || conversationSessionStartedAt;
            console.log(`üîó Matched active session ${resolvedSessionId} using candidate identifiers`);
          }
        }
      } else {
        const { data: sessionRow, error: sessionRowError } = await supabaseClient
          .from('conversation_sessions')
          .select('room_id, sphere_id, started_at')
          .eq('id', resolvedSessionId)
          .maybeSingle();

        if (!sessionRowError && sessionRow) {
          if (sessionRow.room_id) {
            candidateRoomIds.add(sessionRow.room_id);
          }
          if (sessionRow.sphere_id) {
            candidateSphereIds.add(sessionRow.sphere_id);
          }
          if (sessionRow.started_at) {
            conversationSessionStartedAt = sessionRow.started_at;
          }
        }
      }

      console.log('üßÆ Candidate room identifiers:', Array.from(candidateRoomIds));
      console.log('üßÆ Candidate sphere identifiers:', Array.from(candidateSphereIds));

      if (resolvedSessionId) {
        // Calculate actual minutes used based on elapsed time
        const actualMinutesUsed = latestSessionMinutesUsed || 0;
        console.log(`‚è±Ô∏è Actual minutes used in session: ${actualMinutesUsed}`);

        const { data: rpcResult, error: rpcError } = await supabaseClient.rpc('end_conversation_session', {
          p_session_id: resolvedSessionId,
          p_minutes_used: actualMinutesUsed
        });

        if (rpcError) {
          const message = rpcError?.message || rpcError?.details || '';
          if (message.includes('status = \'active\'')) {
            console.warn('‚ö†Ô∏è Supabase indicates the session is already closed:', rpcError);
            conversationSessionEndState.ended = true;
            return;
          }
          throw rpcError;
        }

        console.log('‚úÖ SUCCESS: Session ended via RPC', rpcResult);
        console.log(`üí∞ Charged ${actualMinutesUsed} minutes for this session`);
        conversationSessionEndState.ended = true;
        return;
      }

      console.warn('‚ö†Ô∏è No active session id found (identifier mismatch or already completed).', {
        triedRoomIdentifiers: Array.from(candidateRoomIds),
        triedSphereIdentifiers: Array.from(candidateSphereIds),
        recentSessions
      });
      conversationSessionEndState.ended = true;
    } catch (err) {
      console.error('‚ùå FAILED to end conversation session:', err);
    } finally {
      conversationSessionEndState.inFlight = false;
    }
  }

    // CRITICAL: Comprehensive cleanup to ensure sessions always end
    let cleanupExecuted = false;

    async function executeComprehensiveCleanup(reason) {
      if (cleanupExecuted) {
        console.log('‚ö†Ô∏è Cleanup already executed, skipping');
        return;
      }
      
      cleanupExecuted = true;
      console.log(`üßπ Executing comprehensive cleanup - Reason: ${reason}`);
      console.log(`‚è±Ô∏è Minutes used this session: ${latestSessionMinutesUsed}`);
      
      // Activate referral bonus if user chatted for 2+ minutes (check before resetting!)
      if (latestSessionMinutesUsed >= 2) {
        activateReferralIfEligible(latestSessionMinutesUsed);
      }
      
      // Stop the video recovery watcher
      stopVideoRecoveryWatcher();
      
      // End conversation session (most important!)
      await endConversationSession(reason);
      
      // Reset user join tracking for next session
      userJoinedAtTimestamp = null;
      latestSessionMinutesUsed = 0;
      
      // Clean up Firebase presence using the stored presenceRef (has correct key)
      if (presenceRef) {
        try {
          await presenceRef.remove();
          console.log('‚úÖ Firebase presence cleaned up');
          presenceRef = null;
        } catch (error) {
          console.error('‚ùå Error cleaning Firebase presence:', error);
        }
      } else if (firebaseRoomId) {
        // Fallback: try to construct the key if presenceRef wasn't stored
        try {
          const presenceKey = getPresenceKey();
          await db.ref(`presence/${firebaseRoomId}/${presenceKey}`).remove();
          console.log('‚úÖ Firebase presence cleaned up (fallback)');
        } catch (error) {
          console.error('‚ùå Error cleaning Firebase presence (fallback):', error);
        }
      }
      
      // Leave LiveKit room
      if (livekitRoom) {
        try {
          await livekitRoom.disconnect(true);
          console.log('‚úÖ LiveKit room disconnected');
        } catch (error) {
          console.error('‚ùå Error disconnecting from LiveKit:', error);
        } finally {
          livekitRoom = null;
        }
      }
      
      console.log('‚úÖ Comprehensive cleanup complete');
      
      // Hide floating action buttons
      hideFloatingActionButtons();

      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }

      if (timerRef) {
        timerRef.off();
        timerRef = null;
      }
      timerSyncInitialized = false;
      timerExpiredHandled = false;
      timerState = {
        durationSeconds: 60 * 60,
        startedAt: null,
        expiresAt: null,
        createdBy: null
      };
      
      // Reset presence tracking for next session
      presenceListenersBound = false;
      
      // Stop presence heartbeat
      if (presenceHeartbeatInterval) {
        clearInterval(presenceHeartbeatInterval);
        presenceHeartbeatInterval = null;
      }
    }

    // CRITICAL: Ensure cleanup on page unload
    window.addEventListener('beforeunload', (event) => {
      console.log('üö™ Page unloading - executing cleanup');
      
      // Warn Red Room hosts before leaving if debate is still active
      if (typeof roomTypeState !== 'undefined' && 
          roomTypeState.type === 'red' && 
          !roomTypeState.debateEnded && 
          !isSpectator) {
        const urlParams = new URLSearchParams(window.location.search);
        const isHost = urlParams.get('host') === 'true';
        
        if (isHost && roomTypeState.potTotal > 0) {
          // Show browser's native "are you sure?" dialog
          event.preventDefault();
          event.returnValue = 'You have an active Red Room debate with gems in the pot. The debate will auto-close if you leave.';
          return event.returnValue;
        }
      }
      
      // Warn Green Room hosts before leaving - the room will end when host leaves
      if (typeof roomTypeState !== 'undefined' && 
          roomTypeState.type === 'green' && 
          !roomTypeState.roomEnded && 
          !isSpectator) {
        const urlParams = new URLSearchParams(window.location.search);
        const isHost = urlParams.get('host') === 'true';
        
        if (isHost) {
          // End the green room when host leaves
          endGreenRoom();
          // Show warning
          event.preventDefault();
          event.returnValue = 'You are the host of this Green Room. Leaving will end the session for everyone.';
          return event.returnValue;
        }
      }
      
      // CRITICAL: Save pending rating to localStorage before page unloads
      // This ensures the rating modal shows when user returns
      if (otherParticipantId && !isSpectator && window.currentUserData?.userId && !window.currentUserData?.isGuest) {
        console.log('üíæ Saving pending rating on page unload for:', otherParticipantId);
        savePendingRatingToStorage(otherParticipantId, otherParticipantName);
      }

      if (!cleanupExecuted && !isSpectator && supabaseClient && isValidUuid(userId)) {
        if (conversationSessionId) {
          const rpcUrl = `${SUPABASE_URL}/rest/v1/rpc/end_conversation_session`;
          // Include actual minutes used when ending session on page unload
          const actualMinutesUsed = latestSessionMinutesUsed || 0;
          const rpcPayload = JSON.stringify({ 
            p_session_id: conversationSessionId,
            p_minutes_used: actualMinutesUsed
          });
          console.log(`üö™ Ending session with ${actualMinutesUsed} minutes used`);
          
          // Activate referral bonus if user chatted for 2+ minutes (use sendBeacon for tab close!)
          if (actualMinutesUsed >= 2 && window.currentUserData?.userId) {
            const referralActivateUrl = '/.netlify/functions/track-referral';
            const referralPayload = JSON.stringify({
              action: 'activate',
              referredUserId: window.currentUserData.userId
            });
            
            // Use sendBeacon so it works even when tab is closing
            try {
              navigator.sendBeacon(referralActivateUrl, new Blob([referralPayload], { type: 'application/json' }));
              console.log('üìé Referral activation sent via sendBeacon');
            } catch (e) {
              console.log('üìé sendBeacon failed, trying fetch:', e);
            }
          }

          try {
            const sent = navigator.sendBeacon(
              `${rpcUrl}?apikey=${encodeURIComponent(SUPABASE_ANON_KEY)}`,
              new Blob([rpcPayload], { type: 'application/json' })
            );
            if (sent) {
              console.log('‚úÖ Session end sent via sendBeacon (RPC)');
            } else {
              console.warn('‚ö†Ô∏è sendBeacon (RPC) did not confirm delivery');
            }
          } catch (error) {
            console.error('‚ùå sendBeacon (RPC) failed:', error);
          }

          fetch(rpcUrl, {
            method: 'POST',
            keepalive: true,
            headers: {
              'Content-Type': 'application/json',
              Accept: 'application/json',
              apikey: SUPABASE_ANON_KEY,
              Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
              Prefer: 'return=representation'
            },
            body: rpcPayload
          }).then(() => {
            console.log('‚úÖ Session end sent via fetch keepalive (RPC)');
          }).catch((error) => {
            console.error('‚ùå Fetch keepalive (RPC) failed:', error);
          });
        } else if (conversationRoomId) {
          console.warn('‚ö†Ô∏è No session id available during unload - fallback identifier cleanup may be incomplete');
        }
      }

      // Clean up Firebase presence using stored ref or construct correct key
      if (presenceRef) {
        presenceRef.remove().catch((error) => {
          console.error('‚ùå Error cleaning Firebase presence during unload:', error);
        });
      } else if (firebaseRoomId) {
        try {
          const presenceKey = getPresenceKey();
          db.ref(`presence/${firebaseRoomId}/${presenceKey}`).remove().catch((error) => {
            console.error('‚ùå Error cleaning Firebase presence during unload (fallback):', error);
          });
        } catch (e) {
          console.error('‚ùå Error constructing presence key during unload:', e);
        }
      }

      if (recordingUploadState.pendingPayloadString && recordingUploadState.pendingEndpoint) {
        try {
          fetch(recordingUploadState.pendingEndpoint, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: recordingUploadState.pendingPayloadString,
            keepalive: true
          }).then(() => {
            console.log('‚úÖ Recording metadata persisted during unload');
          }).catch((error) => {
            console.error('‚ùå Recording metadata keepalive failed:', error);
          });
        } catch (error) {
          console.error('‚ùå Unable to persist recording metadata during unload:', error);
        }
      }
    });

    window.addEventListener('pagehide', () => {
      executeComprehensiveCleanup('pagehide');
    });
    
    // CRITICAL: Save pending rating when tab becomes hidden (user switches tabs)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        // Save pending rating data when tab becomes hidden
        if (otherParticipantId && !isSpectator && window.currentUserData?.userId && !window.currentUserData?.isGuest) {
          console.log('üëÅÔ∏è Tab hidden - saving pending rating for:', otherParticipantId);
          savePendingRatingToStorage(otherParticipantId, otherParticipantName);
        }
      }
    });

// Main initialization function
async function initializeApp() {
  // Check for referral code FIRST (before any redirects)
  // Note: Cross-domain referral tracking is handled by /assets/js/referral.js
  const urlParamsInit = new URLSearchParams(window.location.search);
  const refCode = urlParamsInit.get('ref') || (window.ChatSpheresReferral ? window.ChatSpheresReferral.getReferralCode() : null);

  // Check if valid room URL - redirect to explore/landing page if no room
  if (!roomUrl) {
    // Preserve referral code in redirect
    const exploreUrl = refCode ? `/explore.html?ref=${encodeURIComponent(refCode)}` : '/explore.html';
    window.location.href = exploreUrl;
    return;
  }

  // Extract room info first
  conversationRoomId = extractRoomIdentifier(roomUrl);
  if (conversationRoomId) {
    console.log('üÜî Conversation session room identifier resolved:', conversationRoomId);
  } else {
    console.warn('‚ö†Ô∏è Unable to derive conversation room identifier from room URL.', { roomUrl: roomUrl });
  }

  // Get user data from URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const usernameFromURL = urlParams.get('username');
  const userIdFromURL = urlParams.get('userId'); 
  const avatarFromURL = urlParams.get('avatar');
  const displayNameFromURL = urlParams.get('displayName');
  const sphereIdFromURL = urlParams.get('sphereId') || urlParams.get('sphere_id');
  const slugFromURL = urlParams.get('sphereSlug') || urlParams.get('slug');

  conversationSlug = slugFromURL || null;
  conversationSphereId = sphereIdFromURL || (conversationRoomId && conversationRoomId.startsWith('sphere-')
    ? conversationRoomId.replace(/^sphere-/, '')
    : null);

  // Set user mode
  isSpectator = spectatorMode;

  // ============================================================
  // AUTHENTICATION CHECK - Before proceeding with video chat
  // ============================================================
  
  // First, try to get existing Supabase session
  const existingUser = await initializeAuth();
  
  if (existingUser) {
    // User is authenticated via Supabase - use that data
    console.log('‚úÖ User authenticated via Supabase');
    await updateUserDataFromAuth(existingUser);
    
    // Check if user is suspended
    const isSuspended = await checkUserSuspension();
    if (isSuspended) {
      return; // Stop initialization - user redirected to contact page
    }
    
    // Check for pending rating from a previous call
    checkPendingRating();
  } else if (userIdFromURL && usernameFromURL && isValidUuid(userIdFromURL)) {
    // User came with valid auth from another app (URL params)
    console.log('‚úÖ User authenticated via URL params');
    userName = usernameFromURL;
    userId = userIdFromURL;
    window.currentUserData = {
      username: usernameFromURL,
      displayName: displayNameFromURL || usernameFromURL,
      avatar: avatarFromURL || '',
      userId: userId,
      isAuthenticated: true
    };
  } else {
    // No authentication found - allow guest access
    console.log('üë§ No authentication found, joining as guest...');
    
    // Set guest values - allow joining without sign-in
    userName = isSpectator ? `Viewer_${Math.random().toString(36).slice(2, 8)}` : `Guest_${Math.random().toString(36).slice(2, 8)}`;
    userId = `guest_${Math.random().toString(36).slice(2)}_${Date.now()}`;
    
    window.currentUserData = {
      username: userName,
      displayName: userName,
      avatar: '',
      userId: userId,
      isAuthenticated: false,
      isGuest: true
    };
    
    // Continue to video chat as guest (no auth modal blocking)
    console.log('‚úÖ Guest access granted - joining video chat');
  }
    
  console.log(`üé≠ User Mode: ${isSpectator ? 'Spectator' : 'Participant'}`);
  console.log(`üë§ User Name: ${userName}`);
  console.log(`‚ú® Display Name: ${window.currentUserData.displayName}`);
  console.log(`üñºÔ∏è Avatar: ${window.currentUserData.avatar ? 'Yes' : 'None'}`);
  console.log(`üîê Authenticated: ${window.currentUserData.isAuthenticated ? 'Yes' : 'Guest'}`);
  
  // Update waiting overlay with personalized info
  if (isSpectator) {
    document.getElementById('waiting-mode').textContent = 'joining as spectator...';
  } else {
    // Show personalized welcome for authenticated users
    if (window.currentUserData.isAuthenticated) {
        document.getElementById('waiting-mode').textContent = `welcome ${window.currentUserData.displayName}!`;
      }
    }
    
    initializeVideoChat();
  }

  // Load room info
  async function loadRoomInfo() {
    const urlParam = decodeURIComponent(roomUrl);
    console.log("üîç Looking for room URL:", urlParam);

    // First check URL params for topic (works for matchmaking AND red/green rooms)
    const urlParams = new URLSearchParams(window.location.search);
    const isMatchedRoom = urlParams.get('matched') === 'true';
    const topicFromUrl = urlParams.get('topic');
    const matchedTopicFromUrl = urlParams.get('matchedTopic');
    const similarityFromUrl = urlParams.get('similarity');
    const roomTypeFromUrl = urlParams.get('roomType');
    const isHostFromUrl = urlParams.get('host') === 'true';

    // If topic is in URL, use it (works for Red/Green rooms and matchmaking)
    if (topicFromUrl) {
      const topic = decodeURIComponent(topicFromUrl);
      let description;
      
      if (isMatchedRoom) {
        // Matchmaking room
        const matchedTopic = matchedTopicFromUrl ? decodeURIComponent(matchedTopicFromUrl) : null;
        const similarity = similarityFromUrl ? `${similarityFromUrl}% Match` : '';
        description = `You're matched to discuss: "${topic}"`;
        if (matchedTopic && matchedTopic !== topic) {
          description = `Your topic: "${topic}" matched with "${matchedTopic}" ${similarity ? `(${similarity})` : ''}`;
        }
        console.log("‚úÖ Found matchmaking topic:", topic);
        console.log("‚úÖ Matched topic:", matchedTopic);
        console.log("üéØ Similarity:", similarity);
      } else if (roomTypeFromUrl === 'red') {
        // Red Room debate
        description = `üî¥ Red Room Debate: "${topic}"`;
        console.log("‚úÖ Found Red Room topic:", topic);
      } else if (roomTypeFromUrl === 'green') {
        // Green Room help session
        description = `üü¢ Green Room Help: "${topic}"`;
        console.log("‚úÖ Found Green Room topic:", topic);
      } else {
        // Generic room with topic
        description = `Discussing: "${topic}"`;
        console.log("‚úÖ Found topic from URL:", topic);
      }
      
      updateTopicDisplay(topic, description);
      return;
    }

    // No topic in URL, try to load from API
    try {
      const apiUrl = `https://x8ki-letl-twmt.n7.xano.io/api:6PAcsVDu/get-room-info?room_identifier=${encodeURIComponent(urlParam)}`;
      console.log("üåê API URL:", apiUrl);
      
      let response = await fetch(apiUrl);
      
      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log("üì¶ API Response:", data);
      
      if (data.topic) {
        const topic = data.topic.charAt(0).toUpperCase() + data.topic.slice(1);
        const description = data.description || `Discover and discuss fascinating aspects of ${data.topic.toLowerCase()}!`;
        
        console.log("‚úÖ Found topic:", topic);
        console.log("‚úÖ Found description:", description);
        console.log("üéØ Room type:", data.room_type);
        
        updateTopicDisplay(topic, description);
        return;
      } else {
        console.log("‚ùå API response missing topic:", data);
      }
      
    } catch (error) {
      console.error("‚ùå API Error:", error);
      console.log("üîÑ API failed, trying Firebase for topic...");
    }
    
    // Try to get topic from Firebase as last resort
    try {
      const sphereId = extractSphereId(roomUrl);
      if (sphereId && db) {
        const roomInfoRef = db.ref(`chats/${sphereId}/roomInfo`);
        const snapshot = await roomInfoRef.once('value');
        const roomInfo = snapshot.val();
        if (roomInfo?.topic) {
          const topic = roomInfo.topic;
          const roomType = roomInfo.roomType || 'red';
          let description;
          if (roomType === 'red') {
            description = `üî¥ Red Room Debate: "${topic}"`;
          } else if (roomType === 'green') {
            description = `üü¢ Green Room Help: "${topic}"`;
          } else {
            description = `Discussing: "${topic}"`;
          }
          console.log("‚úÖ Found topic from Firebase:", topic);
          updateTopicDisplay(topic, description);
          return;
        }
      }
    } catch (firebaseError) {
      console.log("‚ö†Ô∏è Could not get topic from Firebase:", firebaseError.message);
    }
    
    // Also try to get from Supabase active_rooms
    try {
      const sphereId = extractSphereId(roomUrl);
      if (sphereId) {
        const response = await fetch(`/.netlify/functions/manage-room?roomId=${sphereId}`);
        if (response.ok) {
          const roomData = await response.json();
          if (roomData?.topic) {
            const topic = roomData.topic;
            const roomType = roomData.room_type || 'red';
            let description;
            if (roomType === 'red') {
              description = `üî¥ Red Room Debate: "${topic}"`;
            } else if (roomType === 'green') {
              description = `üü¢ Green Room Help: "${topic}"`;
            } else {
              description = `Discussing: "${topic}"`;
            }
            console.log("‚úÖ Found topic from database:", topic);
            updateTopicDisplay(topic, description);
            return;
          }
        }
      }
    } catch (dbError) {
      console.log("‚ö†Ô∏è Could not get topic from database:", dbError.message);
    }
    
    console.log("üîÑ Using fallback topic - no topic found anywhere");
    updateTopicDisplay("General Chat", "Connect and have meaningful conversations!");
  }

  function updateTopicDisplay(topic, description) {
    const elements = [
      'topic-text', 'topic-description', 
      'topic-display', 'topic-desc-display'
    ];
    
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        if (id.includes('description') || id.includes('desc')) {
          element.innerText = description;
        } else {
          element.innerText = topic;
        }
      }
    });
    
    console.log("‚úÖ Updated topic:", topic);
    console.log("‚úÖ Updated description:", description);
  }

  async function initializeVideoChat() {
    console.log('üöÄ ======= INITIALIZING VIDEO CHAT =======');
    console.log('üåê Browser info:', {
      isSafari,
      isIOS,
      isMobileSafari,
      userGestureReceived,
      userAgent: navigator.userAgent.substring(0, 80)
    });
    console.log('üë§ User info:', {
      isSpectator,
      userName,
      userId: userId?.substring(0, 8) + '...',
      roomUrl: roomUrl?.substring(0, 50) + '...'
    });
    
    await loadRoomInfo();
    console.log('‚úÖ Room info loaded');
    
    await ensureFirebaseAuth();
    console.log('‚úÖ Firebase auth ready');
    
    // Set up Firebase for chat and presence
    // Use sphereId for consistent presence path (works with any room URL format)
    const sphereId = extractSphereId(roomUrl);
    firebaseRoomId = sphereId || btoa(roomUrl); // Use sphereId directly, fallback to btoa
    const roomId = firebaseRoomId;
    console.log(`üîë Firebase Room ID (sphereId): ${firebaseRoomId}`);
    chatRef = db.ref(`chats/${roomId}`);
    viewerCountRef = db.ref(`viewers/${roomId}`);
    
    // Set up user role display
    setupUserRoleDisplay();
    configureTimerUiForMode();
    console.log('‚úÖ UI configured');
    
    // Initialize room type (Red Room or Green Room)
    initializeRoomType();
    console.log('‚úÖ Room type initialized');
    
    // Set up layout based on user type
    if (isSpectator) {
      console.log('üëÄ Setting up SPECTATOR mode');
      setupSpectatorMode();
    } else {
      console.log('üé§ Setting up PARTICIPANT mode');
      setupParticipantMode();
    }

    try {
      if (isSpectator) {
        resetTimerDisplayForSpectator();
      }
      await initializeTimerSync();
      console.log('‚úÖ Timer sync initialized');
    } catch (error) {
      console.error('‚ùå Failed to initialize timer synchronization:', error);
    }
    
    try {
      console.log('üîå Connecting to LiveKit room...');
      
      // Set up fallback timeout to hide overlay in case connection gets stuck
      ensureWaitingOverlayHidden(15000);
      
      await connectToLiveKitRoom();
      console.log('‚úÖ LiveKit room connected!');
      
      // CRITICAL: Hide waiting overlay immediately after connection (especially for Safari)
      hideWaitingOverlay();
      
      await handleJoinedMeeting({
        participant: normalizeLiveKitParticipant(livekitRoom?.localParticipant, { local: true })
      });
      console.log('‚úÖ Joined meeting handled');

      // Set up Firebase presence
      await setupPresence(roomId);
      console.log('‚úÖ Firebase presence set up');
      
      // Initialize tipping (host tracking + notifications) - AFTER presence is set
      // This ensures our presence is written before we determine who is host
      initializeHostTracking();
      listenForTipNotifications();
      
      // Set up chat listeners
      setupChatListeners();
      console.log('‚úÖ Chat listeners set up');
      
      // Set up mute listener for real-time mute sync
      setupMuteListener();
      
      // Show bug report button for everyone
      const bugBtn = document.getElementById('floating-bug-btn');
      if (bugBtn) {
        bugBtn.classList.remove('hidden');
        bugBtn.style.display = 'flex';
      }
      
      // Show video reload hint for participants only (not spectators)
      if (!isSpectator) {
        const reloadHint = document.getElementById('video-reload-hint');
        if (reloadHint) {
          // Show the hint after a delay if video hasn't loaded
          setTimeout(() => {
            const remoteVideo = document.getElementById('remote-video');
            // Show hint if remote video doesn't have a stream yet
            if (!remoteVideo || !remoteVideo.srcObject) {
              reloadHint.classList.remove('hidden');
            }
          }, 10000); // Show after 10 seconds if no video
        }
      }
      
      console.log('üéâ ======= VIDEO CHAT INITIALIZED SUCCESSFULLY =======');

    } catch (error) {
      console.error('‚ùå ======= VIDEO CHAT INITIALIZATION FAILED =======');
      console.error('Failed to join call:', error);
      console.error('Error details:', {
        name: error?.name,
        message: error?.message,
        stack: error?.stack?.substring(0, 200)
      });
      
      const friendlyMessage =
        typeof error?.message === 'string' && error.message.trim().length > 0
          ? error.message.trim()
          : 'Failed to join the video call. Please try refreshing the page.';
      
      // Safari-specific error messages
      if (isSafari && error?.message?.includes('permission')) {
        showToast('üçé Safari requires camera/mic permission. Check Settings > Safari > Camera');
      } else {
        showToast(friendlyMessage);
      }
    }
  }

  function setupUserRoleDisplay() {
    const roleBadge = document.getElementById('user-role-badge');
    const roleText = document.getElementById('role-text');
    
    if (isSpectator) {
      roleBadge.classList.add('spectator-badge');
      roleText.textContent = 'spectator';
    } else {
      roleBadge.classList.add('participant-badge');
      roleText.textContent = 'participant';
    }
    
    roleBadge.classList.remove('hidden');
  }

  function setupSpectatorMode() {
    // Hide participant layout, show spectator layout
    document.getElementById('participant-layout').style.display = 'none';
    document.getElementById('spectator-layout').classList.remove('hidden');
    
    // Set up live indicator
    document.getElementById('live-indicator').classList.remove('hidden');
    
    console.log('üëÄ Spectator mode enabled');
  }

  function setupParticipantMode() {
    // Keep participant layout visible
    console.log('üé§ Participant mode enabled');
    loadParticipantUsageSnapshot();
  }

  function sanitizeFirebaseKey(value, fallbackPrefix = 'key') {
    const sanitized = (value || '').toString().trim().replace(/[.#$/\[\]]/g, '_');
    if (sanitized.length > 0) {
      return sanitized;
    }
    return `${fallbackPrefix}_${Math.random().toString(36).slice(2, 10)}`;
  }

  function getPresenceKey() {
    const tabId = window.__CHATSPHERES_TAB_INSTANCE_ID || Math.random().toString(36).slice(2, 6);
    const runtimeId = window.__CHATSPHERES_RUNTIME_INSTANCE_ID || runtimeInstanceId || Date.now().toString(36);
    const runtimeSegment = runtimeId.replace(/[^a-zA-Z0-9]/g, '').slice(-8) || Math.random().toString(36).slice(2, 10);

    if (isSpectator) {
      return sanitizeFirebaseKey(
        `${userId || 'spectator'}_${tabId}_${runtimeSegment}`,
        'spectator'
      );
    }
    return sanitizeFirebaseKey(
      `${userId || 'participant'}_${runtimeSegment}`,
      'participant'
    );
  }

  let presenceRef = null;
  let presenceListenersBound = false;
  let presenceHeartbeatInterval = null;
  const PRESENCE_STALE_THRESHOLD_MS = 3 * 60 * 1000; // 3 minutes - entries older than this are considered stale
  const PRESENCE_HEARTBEAT_INTERVAL_MS = 60 * 1000; // Update presence every 60 seconds

  async function setupPresence(roomId) {
    await ensureFirebaseAuth();
    const presenceKey = getPresenceKey();
    presenceRef = db.ref(`presence/${roomId}/${presenceKey}`);
    
    // Set user online
    const timestampValue = firebase.database.ServerValue.TIMESTAMP;
    await presenceRef.set({
      name: userName,
      displayName: window.currentUserData?.displayName || userName || null,
      type: isSpectator ? 'spectator' : 'participant',
      mode: isSpectator ? 'spectator' : 'participant',
      status: 'online',
      userId: window.currentUserData?.isAuthenticated && isValidUuid(userId) ? userId : null,
      updatedAt: timestampValue,
      joinedAt: timestampValue,
      source: 'livekit-app'
    });
    
    // Start heartbeat to keep presence fresh
    if (presenceHeartbeatInterval) {
      clearInterval(presenceHeartbeatInterval);
    }
    presenceHeartbeatInterval = setInterval(() => {
      if (presenceRef) {
        presenceRef.update({ updatedAt: firebase.database.ServerValue.TIMESTAMP }).catch((err) => {
          console.warn('‚ö†Ô∏è Failed to update presence heartbeat:', err);
        });
      }
    }, PRESENCE_HEARTBEAT_INTERVAL_MS);
    
    // Listen for viewer count changes (filtering out stale entries)
    if (!presenceListenersBound) {
      const allPresenceRef = db.ref(`presence/${roomId}`);
      allPresenceRef.on('value', (snapshot) => {
        const users = snapshot.val() || {};
        const now = Date.now();
        
        // Filter out stale presence entries (older than threshold)
        const activeUsers = Object.entries(users).filter(([key, user]) => {
          const updatedAt = user.updatedAt || user.joinedAt || 0;
          const isStale = (now - updatedAt) > PRESENCE_STALE_THRESHOLD_MS;
          
          if (isStale) {
            console.log(`üßπ Removing stale presence entry: ${key} (last updated ${Math.round((now - updatedAt) / 1000)}s ago)`);
            // Auto-cleanup stale entries
            db.ref(`presence/${roomId}/${key}`).remove().catch(() => {});
            return false;
          }
          return true;
        }).map(([, user]) => user);
        
        const spectators = activeUsers.filter(user => user.type === 'spectator');
        const participants = activeUsers.filter(user => user.type === 'participant');

        updateViewerCount({
          spectators: spectators.length,
          participants: participants.length
        });

        console.log(`üë• Room stats: ${participants.length} participants, ${spectators.length} spectators (filtered ${Object.keys(users).length - activeUsers.length} stale)`);
      }, (error) => {
        console.error('‚ùå Failed to monitor presence counts:', error);
      });
      presenceListenersBound = true;
    }
    
    // Clean up presence on disconnect
    presenceRef.onDisconnect().remove();
  }

  async function initializeTimerSync() {
    if (timerSyncInitialized || !firebaseRoomId) {
      return;
    }
    await ensureFirebaseAuth();

    timerSyncInitialized = true;
    timerRef = db.ref(`timers/${firebaseRoomId}`);

    timerRef.on('value', (snapshot) => {
      const value = snapshot.val();
      if (value && typeof value.startedAt === 'number' && typeof value.durationSeconds === 'number') {
        timerState.startedAt = value.startedAt;
        timerState.durationSeconds = value.durationSeconds;
        timerState.expiresAt = value.startedAt + value.durationSeconds * 1000;
        timerState.createdBy = value.createdBy || null;
        timerExpiredHandled = timerState.expiresAt <= getServerNow();
      } else {
        timerState.startedAt = null;
        timerState.expiresAt = null;
        timerState.createdBy = null;
      }
      updateTimer();
    });

    if (!isSpectator) {
      // Fetch user's plan to determine timer duration
      const { plan, limitMinutes } = await fetchUserSubscriptionForTimer();
      const timerDurationSeconds = limitMinutes * 60;
      console.log(`‚è±Ô∏è User plan: ${plan}, timer duration: ${limitMinutes} minutes`);
      
      const serverNow = getServerNow();
      await new Promise((resolve) => {
        timerRef.transaction((current) => {
          if (current && typeof current.startedAt === 'number' && typeof current.durationSeconds === 'number') {
            const expiresAt = current.startedAt + current.durationSeconds * 1000;
            if (expiresAt > serverNow + 1000) {
              return current;
            }
          }
          console.log(`‚è±Ô∏è Starting new shared timer for this room (${limitMinutes} min)`);
          return {
            startedAt: firebase.database.ServerValue.TIMESTAMP,
            durationSeconds: timerDurationSeconds,
            createdBy: userId,
            createdAt: firebase.database.ServerValue.TIMESTAMP
          };
        }, (error, committed, snapshot) => {
          if (error) {
            console.error('‚ùå Timer synchronization error:', error);
          } else if (committed) {
            console.log(`‚úÖ Timer synchronized for room (${limitMinutes} min)`);
          } else {
            console.log('‚ÑπÔ∏è Timer already active, using existing value');
          }
          resolve();
        });
      });
    }
  }
  
  // Fetch subscription specifically for timer (called early in flow)
  async function fetchUserSubscriptionForTimer() {
    if (!userId || !isValidUuid(userId)) {
      console.log('‚è±Ô∏è No valid userId for timer, using free plan (60 min)');
      return { plan: 'free', limitMinutes: 60 };
    }
    
    try {
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${userId}`);
      if (!response.ok) {
        return { plan: 'free', limitMinutes: 60 };
      }
      
      const data = await response.json();
      const plan = data.plan || 'free';
      const limitMinutes = PLAN_LIMITS_TIMER[plan] || 60;
      
      return { plan, limitMinutes };
    } catch (error) {
      console.error('‚ùå Error fetching subscription for timer:', error);
      return { plan: 'free', limitMinutes: 60 };
    }
  }
  
  // Plan limits for timer (defined early so it's available)
  const PLAN_LIMITS_TIMER = {
    free: 60,
    host_pro: 180,
    ad_free_plus: 60,
    ad_free_premium: 60,
    pro_bundle: 180
  };

  function updateViewerCount(countOrPayload) {
    const spectatorCount = typeof countOrPayload === 'number'
      ? countOrPayload
      : (countOrPayload?.spectators ?? 0);
    const participantCount = typeof countOrPayload === 'number'
      ? null
      : (countOrPayload?.participants ?? null);

    const viewerCountElements = [
      document.getElementById('viewer-count'),
      document.getElementById('chat-viewer-count'),
      document.getElementById('participant-chat-viewer-count')
    ];
    
    viewerCountElements.forEach(el => {
      if (el) el.textContent = spectatorCount;
    });
    
    // Update participant view when spectators are present
    if (!isSpectator) {
      updateParticipantViewForSpectators(spectatorCount);
    }

    if (viewerCountRef) {
      viewerCountRef.set({
        spectators: spectatorCount,
        participants: participantCount,
        updatedAt: firebase.database.ServerValue.TIMESTAMP
      }).catch((error) => {
        console.error('‚ö†Ô∏è Failed to persist viewer counts:', error);
      });
    }
  }

  function updateParticipantViewForSpectators(spectatorCount) {
    const remotePlaceholder = document.getElementById('remote-placeholder');
    const remoteVideo = document.getElementById('remote-video');
    
    // Only update if no remote video is showing (no other participants)
    if (remotePlaceholder && remoteVideo && remoteVideo.style.display !== 'block') {
      // Check if there are any other participants (not spectators)
      const participants = getParticipantsSnapshot();
      const otherParticipants = Object.values(participants).filter(p => !p.local);
      
      // Only show spectator message if there are NO other participants
      if (otherParticipants.length === 0) {
        const placeholder = remotePlaceholder.querySelector('.text-center.text-white.relative.z-10');
        
        if (placeholder) {
          const icon = placeholder.querySelector('.w-16.h-16');
          const title = placeholder.querySelector('.font-bold.text-lg.text-white');
          const subtitle = placeholder.querySelector('.text-sm.text-gold.mt-1');
          
          if (spectatorCount > 0) {
            // Show that spectators are watching
            if (icon) {
              icon.innerHTML = `
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                  <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                </svg>
              `;
            }
            
            if (title) {
              title.textContent = spectatorCount === 1 
                ? `${spectatorCount} viewer is watching!` 
                : `${spectatorCount} viewers are watching!`;
            }
            
            if (subtitle) {
              subtitle.innerHTML = `üé≠ They're here for the conversation! <br>üé§ Waiting for another participant to join...`;
            }
          } else {
            // Reset to original state when no spectators
            if (icon) {
              icon.innerHTML = `
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                </svg>
              `;
            }
            
            if (title) {
              title.textContent = "Waiting for your chat partner...";
            }
            
            if (subtitle) {
              subtitle.innerHTML = "üê± They might be as curious as a cat about this topic!";
            }
          }
        }
      }
      // If there ARE other participants, don't change anything - let their video show
    }
  }

  let activeChatListener = null;
  let activeChatQuery = null;

  function setupChatListeners() {
    if (!chatRef) {
      console.warn('‚ö†Ô∏è Chat reference missing when attempting to set up listeners');
      return;
    }

    console.log('üí¨ Attaching chat listeners for room:', chatRef.toString());

    // Detach any previous listener to avoid duplicates
    if (activeChatListener && activeChatQuery) {
      activeChatQuery.off('value', activeChatListener);
      activeChatListener = null;
      activeChatQuery = null;
    }

    const chatQuery = chatRef.orderByChild('timestamp').limitToLast(200);
    activeChatQuery = chatQuery;

    activeChatListener = (snapshot) => {
      const messages = [];
      snapshot.forEach((childSnapshot) => {
        const value = childSnapshot.val() || {};
        messages.push({
          key: childSnapshot.key,
          ...value
        });
      });

      messages.sort((a, b) => {
        const aTime = typeof a.timestamp === 'number' ? a.timestamp : (typeof a.createdAt === 'number' ? a.createdAt : 0);
        const bTime = typeof b.timestamp === 'number' ? b.timestamp : (typeof b.createdAt === 'number' ? b.createdAt : 0);
        return aTime - bTime;
      });

      console.log(`üí¨ Chat snapshot received (${messages.length} message${messages.length === 1 ? '' : 's'})`);
      renderChatMessages(messages);
    };

    chatQuery.on('value', activeChatListener, (error) => {
      console.error('‚ùå Failed to listen for chat messages:', error);
    });

    // Set up chat input for spectators
    const chatInput = document.getElementById('chat-input');
    const charCount = document.getElementById('char-count');
    
    if (chatInput && charCount) {
      chatInput.addEventListener('input', () => {
        charCount.textContent = chatInput.value.length;
      });
      
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendChatMessage();
        }
      });
    }

    // Set up chat input for participants
    const participantChatInput = document.getElementById('participant-chat-input');
    const participantCharCount = document.getElementById('participant-char-count');
    
    if (participantChatInput && participantCharCount) {
      participantChatInput.addEventListener('input', () => {
        participantCharCount.textContent = participantChatInput.value.length;
      });
      
      participantChatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendParticipantChatMessage();
        }
      });
    }
  }

  function renderChatMessages(messages = []) {
    const chatContainers = [
      document.getElementById('live-chat-messages'),
      document.getElementById('participant-chat-messages')
    ].filter(Boolean);

    // Cache badges from messages for video overlays
    messages.forEach((message) => {
      if (message.userId && message.badge) {
        updateParticipantBadgeFromMessage(message);
      }
    });

    chatContainers.forEach((chatContainer) => {
      chatContainer.innerHTML = '';

      if (messages.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'text-center text-xs text-gray-500 dark:text-gray-400 py-2';
        placeholder.textContent = 'Welcome to the chat! üëã';
        chatContainer.appendChild(placeholder);
        return;
      }

      const fragment = document.createDocumentFragment();
      messages.forEach((message) => {
        fragment.appendChild(buildChatMessageElement(message));
      });

      chatContainer.appendChild(fragment);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    });
  }

  function buildChatMessageElement(message = {}) {
    const senderName = message.sender || message.userName || 'Guest';
    const senderInitial = senderName.charAt(0).toUpperCase();
    const timestampSource = typeof message.timestamp === 'number'
      ? message.timestamp
      : (typeof message.createdAt === 'number' ? message.createdAt : Date.now());
    const timestamp = new Date(timestampSource).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    // Get badge info from message (set when sending)
    const badge = message.badge || {};
    const badgeEmoji = badge.emoji || '';
    const badgeLabel = badge.label || '';
    const badgeColor = badge.color || '';

    const messageEl = document.createElement('div');
    messageEl.className = 'chat-message p-3 rounded-lg border';

    if (message.userType === 'participant') {
      messageEl.classList.add('bg-light-rose', 'border-rose');
    } else {
      messageEl.classList.add('bg-gray-50', 'dark:bg-gray-700', 'border-gray-200', 'dark:border-gray-600');
    }

    // Build badge HTML if user has one
    let badgeHtml = '';
    if (badgeEmoji && badgeLabel) {
      badgeHtml = `<span class="user-badge text-xs px-1.5 py-0.5 rounded-full font-bold" style="background: ${badgeColor}20; color: ${badgeColor}; border: 1px solid ${badgeColor}40;" title="${badgeLabel}">${badgeEmoji}</span>`;
    }

    // Check if message should be hidden (user is muted)
    const senderId = message.userId;
    if (senderId && mutedChatUserIds.has(senderId)) {
      messageEl.style.display = 'none';
      messageEl.dataset.muted = 'true';
    }
    
    // Mute button (only shown to host for non-host messages)
    let muteButtonHtml = '';
    if (roomHostData.isHost && senderId && senderId !== roomHostData.hostId && message.userType !== 'participant') {
      const isMuted = mutedChatUserIds.has(senderId);
      muteButtonHtml = `
        <button onclick="toggleMuteUser('${senderId}', '${escapeHtml(senderName)}')" 
          class="ml-auto text-xs opacity-50 hover:opacity-100 ${isMuted ? 'text-green-600' : 'text-main-red'}" 
          title="${isMuted ? 'Unmute user' : 'Mute user'}">
          ${isMuted ? 'üîä' : 'üîá'}
        </button>
      `;
    }

    messageEl.innerHTML = `
      <div class="flex items-start space-x-2">
        <div class="flex-shrink-0">
          <div class="w-6 h-6 rounded-full ${message.userType === 'participant' ? 'bg-main-red' : 'bg-gold'} flex items-center justify-center text-white text-xs font-bold">
            ${senderInitial}
          </div>
        </div>
        <div class="flex-1 min-w-0">
          <div class="flex items-center space-x-1.5 mb-1 flex-wrap">
            <span class="font-semibold text-charcoal dark:text-white text-sm">${escapeHtml(senderName)}</span>
            ${badgeHtml}
            ${message.userType === 'participant' ? '<span class="text-xs bg-main-red text-white px-1 rounded">HOST</span>' : ''}
            <span class="text-xs text-gray-500">${timestamp}</span>
            ${muteButtonHtml}
          </div>
          <p class="text-charcoal dark:text-white text-sm break-words">${escapeHtml(message.text)}</p>
        </div>
      </div>
    `;
    
    // Store user ID for mute functionality
    messageEl.dataset.userId = senderId || '';

    return messageEl;
  }

  // Escape HTML to prevent XSS
  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Cache for current user's badge info
  let currentUserBadge = null;

  // Fetch and cache user badge info
  async function fetchUserBadge() {
    const currentUserId = window.currentUserData?.userId || userId;
    if (!currentUserId || !isValidUuid(currentUserId)) {
      currentUserBadge = null;
      return null;
    }

    try {
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
      if (response.ok) {
        const data = await response.json();
        currentUserBadge = data.badge || null;
        window.currentUserBadge = currentUserBadge; // Make available globally
        console.log('üèÜ User badge loaded:', currentUserBadge);
        return currentUserBadge;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not fetch user badge:', error);
    }
    return null;
  }

  async function pushChatMessageToFirebase(text, contextLabel = 'chat') {
    if (!chatRef) {
      throw new Error('Chat reference is not initialized');
    }
    const firebaseUser = await ensureFirebaseAuth();
    const firebaseUid = firebaseUser?.uid || null;
    const userDisplayInfo = getCurrentUserDisplayInfo();
    const senderName = userDisplayInfo.displayName || userName || 'Guest';
    const serverTimestamp = firebase.database.ServerValue.TIMESTAMP;

    // Include badge info if available
    const badge = currentUserBadge || window.currentUserBadge || null;

    const message = {
      sender: senderName,
      text,
      createdAt: serverTimestamp,
      timestamp: serverTimestamp,
      userType: isSpectator ? 'spectator' : 'participant',
      userId: userId,
      externalUserId: userId,
      firebaseUid: firebaseUid,
      authUid: firebaseUid,
      clientContext: contextLabel,
      badge: badge ? {
        type: badge.type,
        emoji: badge.emoji,
        label: badge.label,
        color: badge.color
      } : null
    };
    
    console.log('üí¨ Sending chat message:', {
      roomPath: chatRef.toString(),
      contextLabel,
      senderName,
      firebaseUid,
      preview: text.slice(0, 50)
    });
    
    return chatRef.push(message)
      .then((ref) => {
        console.log('‚úÖ Chat message stored with key:', ref.key);
        return ref;
      })
      .catch((error) => {
        console.error('‚ùå Failed to push chat message:', error);
        throw error;
      });
  }

  async function sendChatMessage() {
    const chatInput = document.getElementById('chat-input');
    if (!chatInput || !chatRef) return;
    
    const text = chatInput.value.trim();
    if (!text) return;
    
    // Spam prevention check
    if (!validateChatMessage(text)) {
      return;
    }
    
    try {
      await pushChatMessageToFirebase(text, 'spectator-chat');
      chatInput.value = '';
      const charCount = document.getElementById('char-count');
      if (charCount) {
        charCount.textContent = '0';
      }
    } catch (error) {
      console.error('‚ùå Failed to send spectator chat message:', error);
      showToast('‚ùå Unable to send chat message. Please try again.');
    }
  }

  async function sendParticipantChatMessage() {
    const chatInput = document.getElementById('participant-chat-input');
    if (!chatInput || !chatRef) return;
    
    const text = chatInput.value.trim();
    if (!text) return;
    
    // Spam prevention check
    if (!validateChatMessage(text)) {
      return;
    }
    
    try {
      await pushChatMessageToFirebase(text, 'participant-chat');
      chatInput.value = '';
      const charCount = document.getElementById('participant-char-count');
      if (charCount) {
        charCount.textContent = '0';
      }
    } catch (error) {
      console.error('‚ùå Failed to send participant chat message:', error);
      showToast('‚ùå Chat failed to send. Please retry.');
    }
  }

    async function handleJoinedMeeting(event = {}) {
      console.log('‚úÖ Joined LiveKit room successfully');
      
      // Update room counts in database
      setTimeout(() => updateRoomCounts(), 1000);
      
      // Track when THIS user joined (for accurate minute calculation)
      userJoinedAtTimestamp = getServerNow();
      latestSessionMinutesUsed = 0; // Reset minutes counter on join
      console.log(`‚è±Ô∏è User joined at timestamp: ${userJoinedAtTimestamp}`);
      
      const localParticipant = livekitRoom?.localParticipant || event?.participant;
      
      if (!isSpectator && localParticipant) {
        isMicOn = !!localParticipant.isMicrophoneEnabled;
        isCameraOn = !!localParticipant.isCameraEnabled;
        
        const micBtn = document.getElementById('mic-btn');
        const cameraBtn = document.getElementById('camera-btn');
        
        if (micBtn) {
          micBtn.classList.toggle('active', !isMicOn);
        }
        if (cameraBtn) {
          cameraBtn.classList.toggle('active', !isCameraOn);
        }
        
        setupLocalVideo();
        
        if (isMicOn) {
          startAudioLevelMonitoring();
        }
        
        requestPermissionsAndSetupDevices();
        initializeSparks();

        try {
          await ensureConversationSessionStarted('joined-meeting');
        } catch (error) {
          console.error('‚ùå Failed to ensure Supabase session on join:', error);
        }
        
        // Set up existing participants with multiple attempts for reliability
        setupExistingParticipantsForParticipant(0);
        
        // Retry multiple times with increasing delays to catch late tracks
        setTimeout(() => setupExistingParticipantsForParticipant(1), 1000);
        setTimeout(() => setupExistingParticipantsForParticipant(2), 3000);
        setTimeout(() => setupExistingParticipantsForParticipant(3), 6000);
        
        // Start the video recovery watcher
        startVideoRecoveryWatcher();
      } else {
        setTimeout(() => {
          setupExistingParticipants();
          hydrateSpectatorTracksFromLiveKit();
        }, 3000);
      }
      
      hideWaitingOverlay();
      
      startTimer();
      
      // Initialize session limits (plan-based time limits)
      initializeSessionLimits();
      
      // Initialize recording permissions (plan-based)
      initializeRecordingPermissions();
      
      // Fetch user badge for chat messages
      fetchUserBadge();
      
      // Note: Host tracking is initialized AFTER setupPresence() so our presence is set first
      
      showToast(isSpectator ? 'üëÄ Welcome to the live chat!' : 'üéâ Welcome to your ChatSpheres room!');
    }

  function handleLeftMeeting() {
    console.log('üëã Local participant left the meeting');
    
    // Show rating modal if there was another participant
    if (otherParticipantId && !isSpectator) {
      setTimeout(() => {
        showRatingModal(otherParticipantId, otherParticipantName);
      }, 500);
    }
    
    executeComprehensiveCleanup('left-meeting');
  }

  async function handleParticipantJoined(event) {
    const participantId = event.participant.session_id;
    const participantName = event.participant.user_name || 'Guest';
    const localUserName = userName || window.currentUserData?.username;
    const localSid = livekitRoom?.localParticipant?.sid;
    
    // Skip if this is our own participant (shouldn't happen, but safety check)
    if (event.participant.local === true) {
      console.log('‚ÑπÔ∏è Ignoring local participant join event');
      return;
    }
    
    // Additional check: compare session IDs
    if (localSid && participantId === localSid) {
      console.log('‚ÑπÔ∏è Ignoring participant join event for local participant (sid match)');
      return;
    }
    
    // Check if this is a stale version of ourselves (same username, different session ID)
    const isStaleSelfSession = localUserName && participantName === localUserName;
    if (isStaleSelfSession) {
      console.log('‚ÑπÔ∏è Ignoring stale self-session join event (old session with same username):', participantName);
      return;
    }
    
    const participantData = getParticipantUserData(event.participant);
    const participantDisplayName = participantData?.displayName || participantName;
    const participantRole = getParticipantRole(event.participant);
    const isSpectatorParticipant = participantRole === 'spectator';
    
    console.log('üëã Participant joined:', participantDisplayName, isSpectatorParticipant ? '(spectator)' : '(participant)', 
      'session_id:', participantId?.substring(0, 12));
    
    if (!isSpectator) {
      if (!isSpectatorParticipant) {
        console.log('üéØ Remote participant joined - setting up video...');
        
        const remoteUserId = getParticipantUserId(event.participant);
        if (remoteUserId) {
          // Track other participant for rating
          updateOtherParticipant(remoteUserId, participantDisplayName);
          try {
            await updatePartnerUserId(remoteUserId, 'participant-joined');
          } catch (error) {
            console.error('‚ùå Failed to link partner on join:', error);
          }
        }
        
        // CRITICAL: Hide waiting overlay immediately
        hideWaitingOverlay();
        updateRemoteInfo(participantDisplayName);
        
        // Check if participant has video track and set it up
        // Try multiple methods to find the track
        let videoTrack = null;
        
        if (event.participant.tracks) {
          videoTrack = event.participant.tracks.video?.persistentTrack || 
                       event.participant.tracks.camera?.persistentTrack;
        }
        
        // Also try getting from LiveKit directly (more reliable)
        if (!videoTrack && livekitRoom) {
          const lkParticipant = livekitRoom.remoteParticipants.get(event.participant.session_id);
          if (lkParticipant) {
            const cameraPub = lkParticipant.getTrackPublication('camera');
            const videoPub = cameraPub || Array.from(lkParticipant.videoTrackPublications.values())[0];
            if (videoPub?.track?.mediaStreamTrack) {
              videoTrack = videoPub.track.mediaStreamTrack;
            } else if (videoPub?.track) {
              videoTrack = videoPub.track;
            }
          }
        }
        
        if (videoTrack && videoTrack.readyState === 'live') {
          console.log('üé• Found video track on join, setting up...');
          setupRemoteVideo(videoTrack);
        } else {
          console.log('üì∑ No video track found on join, showing placeholder and scheduling retries');
          updateRemotePlaceholderForCameraOff(event.participant);
          
          // Schedule retries to catch tracks that arrive late
          const participantId = event.participant.session_id;
          setTimeout(() => retrySetupRemoteVideoForParticipant(participantId, 1), 500);
          setTimeout(() => retrySetupRemoteVideoForParticipant(participantId, 2), 1500);
          setTimeout(() => retrySetupRemoteVideoForParticipant(participantId, 3), 3000);
        }
        
        showToast(`üëã ${participantDisplayName} joined the call!`);
        
        // Update Red Room pot targets with new participant
        if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
          updatePotTargets();
          listenForPotUpdates();
          // Cancel any pending auto-end timer since a participant returned
          if (typeof cancelAutoEndTimer === 'function') {
            cancelAutoEndTimer();
          }
        }
        
        // Update room counts
        setTimeout(() => updateRoomCounts(), 500);
      } else {
        console.log('üîí Ignoring spectator join event to prevent participant disruption');
      }
    } else {
      updateSpectatorParticipants();
      // Update room counts for spectator join
      setTimeout(() => updateRoomCounts(), 500);
    }
  }

  function handleParticipantLeft(event) {
    const participantId = event.participant.session_id;
    const participantName = event.participant.user_name || 'Guest';
    const participantData = getParticipantUserData(event.participant);
    const participantDisplayName = participantData?.displayName || participantName;
    const participantRole = getParticipantRole(event.participant);
    const isSpectatorParticipant = participantRole === 'spectator';
    
    // Determine if this is the local participant (possibly from a stale session)
    const localSid = livekitRoom?.localParticipant?.sid;
    const localUserName = userName || window.currentUserData?.username;
    const isLocalParticipant = 
      event.participant?.local === true || 
      (localSid && participantId === localSid);
    
    // Also check if this is a stale version of ourselves (same username, different session)
    const isStaleSelfSession = localUserName && participantName === localUserName && !isLocalParticipant;
    
    console.log('üëã Participant left:', participantDisplayName, {
      participantId: participantId?.substring(0, 12),
      localSid: localSid?.substring(0, 12),
      isSpectatorParticipant,
      isLocalParticipant,
      isStaleSelfSession
    });
    
    // Ignore if this is ourselves or a stale version of ourselves
    if (isLocalParticipant) {
      console.log('‚ÑπÔ∏è Ignoring local participant leave event');
      return;
    }
    
    if (isStaleSelfSession) {
      console.log('‚ÑπÔ∏è Ignoring stale self-session leave event (old session cleanup)');
      return;
    }
    
    if (!isSpectator) {
      if (!isSpectatorParticipant) {
        hideRemoteVideo();
        showToast(`üëã ${participantDisplayName} left the call`);
        
        // Update pot targets and scoreboard when opponent leaves
        if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
          setTimeout(() => {
            updatePotTargets();
            updateDebateScoreboard();
            // Check if we should auto-end the debate
            checkAutoEndDebate();
          }, 500);
        }
        
        // Update room counts
        setTimeout(() => updateRoomCounts(), 500);
      } else {
        console.log('üîí Ignoring spectator leave event to prevent participant disruption');
      }
    } else {
      // Spectator viewing - someone else left
      // Update counts immediately for all room types
      setTimeout(() => updateRoomCounts(), 300);
      
      if (!isSpectatorParticipant) {
        // A debater left - update spectator view
        removeSpectatorParticipant(participantId);
        updateSpectatorParticipants();
        showToast(`üëã ${participantDisplayName} left the conversation`);
        
        // Check for auto-end if Red Room
        if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
          checkAutoEndDebate();
        }
      } else {
        // Another spectator left - just update counts, no video change needed
        console.log(`üëÅÔ∏è Spectator left: ${participantDisplayName}`);
      }
    }
  }

  function handleParticipantUpdated(event) {
    // Only log when there are meaningful changes, not constant updates
    const participantId = event.participant.session_id;
    const participantName = event.participant?.user_name || 'Guest';
    const localUserName = userName || window.currentUserData?.username;
    
    // Determine if this is truly a local participant - use multiple checks
    const localSid = livekitRoom?.localParticipant?.sid;
    const isLocalParticipant = 
      event.participant?.local === true || 
      (localSid && participantId === localSid);
    
    // Check if this is a stale version of ourselves (same username, different session ID)
    const isStaleSelfSession = localUserName && participantName === localUserName && !isLocalParticipant;
    
    const participantRole = getParticipantRole(event.participant);
    
    // Skip logging and processing for local participant updates
    if (isLocalParticipant) return;
    
    // Skip stale self-session updates
    if (isStaleSelfSession) {
      console.log('‚ÑπÔ∏è Ignoring stale self-session update');
      return;
    }

    if (participantRole === 'spectator') {
      console.log('üîí Ignoring spectator participant update to prevent disruption');
      return;
    }
    
    console.log(`üîÑ Remote participant updated: ${participantName || participantId?.slice(0,8)}`);
    
    const tracks = event.participant.tracks;
    
    // For non-local participants only
    if (tracks) {
      if (tracks.video && tracks.video.persistentTrack) {
        if (isSpectator) {
          setupSpectatorVideo(tracks.video.persistentTrack, participantId);
        } else {
          // For participants: NEVER overwrite existing video connections from spectator events
          const remoteVideo = document.getElementById('remote-video');
          const hasActiveRemoteVideo = remoteVideo && remoteVideo.srcObject && remoteVideo.style.display === 'block';
          
          // Only set up if we truly don't have a remote connection
          if (!hasActiveRemoteVideo) {
            console.log('‚úÖ Setting up remote video for participant');
            setupRemoteVideo(tracks.video.persistentTrack);
            updateRemoteInfo(event.participant.user_name || 'Guest');
          } else {
            console.log('üîí Remote video already active, ignoring update to prevent disruption');
          }
        }
      }
      if (tracks.screenVideo && tracks.screenVideo.persistentTrack) {
        if (isSpectator) {
          setupSpectatorScreenShare(tracks.screenVideo.persistentTrack);
        } else {
          setupScreenShareVideo(tracks.screenVideo.persistentTrack);
        }
      }
    }

    if (!isSpectator && !participantHasActiveCamera(event.participant)) {
      console.log('üì∑ Remote participant camera still off, keeping placeholder visible.');
      updateRemotePlaceholderForCameraOff(event.participant);
      hideWaitingOverlay();
    }
  }

  function handleTrackStarted(event) {
    console.log('üé• TRACK STARTED EVENT');
    
    // Determine if this is truly a local participant - use multiple checks
    const localSid = livekitRoom?.localParticipant?.sid;
    const participantId = event.participant?.session_id;
    const participantName = event.participant?.user_name || 'Guest';
    const localUserName = userName || window.currentUserData?.username;
    
    const isLocalParticipant = 
      event.participant?.local === true || 
      (localSid && participantId === localSid);
    
    // Check if this is a stale version of ourselves (same username, different session ID)
    const isStaleSelfSession = localUserName && participantName === localUserName && !isLocalParticipant;
    
    console.log('üé• Track details:', {
      kind: event.track?.kind,
      label: event.track?.label,
      id: event.track?.id,
      readyState: event.track?.readyState,
      enabled: event.track?.enabled,
      participantLocal: event.participant?.local,
      isLocalParticipant: isLocalParticipant,
      isStaleSelfSession: isStaleSelfSession,
      participantId: participantId?.substring(0, 12),
      participantName: event.participant?.user_name,
      localSid: localSid,
      isSpectator: isSpectator,
      isSafari: isSafari
    });

    // Validate track
    if (!event.track) {
      console.error('‚ùå handleTrackStarted called with no track!');
      return;
    }

    // Ignore stale self-session track events (old session cleanup)
    if (isStaleSelfSession) {
      console.log('‚ÑπÔ∏è Ignoring stale self-session track start (old session with same username)');
      return;
    }

    if (!isLocalParticipant && getParticipantRole(event.participant) === 'spectator') {
      console.log('üîí Ignoring spectator track start to protect participant streams');
      return;
    }
    
    if (isLocalParticipant && !isSpectator) {
      if (event.track.kind === 'video') {
        console.log('üìπ Setting up LOCAL video track');
        setupLocalVideo(event.track);
      } else if (event.track.kind === 'audio') {
        console.log('üé§ Local audio track started (not setting up - already handled)');
      }
    } else if (!isLocalParticipant) {
      // Handle remote participant tracks
      const participantId = event.participant.session_id;
      const participantName = event.participant.user_name || 'Guest';
      
      if (event.track.kind === 'video') {
        // Enhanced screen share detection - check multiple indicators
        const trackLabel = (event.track.label || '').toLowerCase();
        const isScreenShareTrack = 
          trackLabel.includes('screen') || 
          trackLabel.includes('display') || 
          trackLabel.includes('window') ||
          trackLabel.includes('monitor') ||
          trackLabel.includes('web-contents-media-stream') ||
          trackLabel.includes('entire screen') ||
          trackLabel.includes('application');
        
        console.log(`üé• Video track analysis: isScreenShare=${isScreenShareTrack}, label="${event.track.label}"`);
        
        if (isScreenShareTrack) {
          console.log('üì∫ SCREEN SHARE DETECTED for participant:', participantName, participantId);
          if (isSpectator) {
            setupSpectatorScreenShare(event.track);
          } else {
            setupScreenShareVideo(event.track);
          }
        } else {
          console.log('üé• CAMERA VIDEO DETECTED for participant:', participantName, participantId);
          if (isSpectator) {
            setupSpectatorVideo(event.track, participantId);
          } else {
            // Set up remote video
            console.log('üîÑ Setting up remote video for:', participantName);
            setupRemoteVideo(event.track);
            updateRemoteInfo(participantName);
            hideWaitingOverlay();
            
            // CRITICAL: Force the video element to be visible
            const remoteVideoEl = document.getElementById('remote-video');
            const placeholder = document.getElementById('remote-placeholder');
            if (remoteVideoEl && placeholder) {
              // Remove hidden class and force display
              remoteVideoEl.classList.remove('hidden');
              remoteVideoEl.style.display = 'block';
              remoteVideoEl.style.visibility = 'visible';
              remoteVideoEl.style.opacity = '1';
              
              placeholder.style.display = 'none';
              placeholder.classList.add('hidden');
              
              console.log('‚úÖ Remote video element forced visible:', {
                hidden: remoteVideoEl.classList.contains('hidden'),
                display: remoteVideoEl.style.display,
                hasSrcObject: !!remoteVideoEl.srcObject,
                paused: remoteVideoEl.paused
              });
              
              // Try to play immediately
              if (remoteVideoEl.srcObject && remoteVideoEl.paused) {
                remoteVideoEl.play().then(() => {
                  console.log('‚úÖ Remote video playing from handleTrackStarted');
                }).catch(e => console.log('Play in handleTrackStarted:', e.message));
              }
            }
          }
        }
      } else if (event.track.kind === 'audio') {
        console.log('üîä AUDIO TRACK for participant:', participantName);
        setupRemoteAudio(event.track);
      }
    }
  }

  function handleTrackStopped(event) {
    console.log('üõë Track stopped:', event);
    
    // Determine if this is truly a local participant - use multiple checks
    const localSid = livekitRoom?.localParticipant?.sid;
    const participantId = event.participant?.session_id;
    const participantName = event.participant?.user_name || 'Guest';
    const localUserName = userName || window.currentUserData?.username;
    
    const isLocalParticipant = 
      event.participant?.local === true || 
      (localSid && participantId === localSid);
    
    // Check if this is a stale version of ourselves (same username, different session ID)
    const isStaleSelfSession = localUserName && participantName === localUserName && !isLocalParticipant;
    
    console.log('üõë Track details:', {
      kind: event.track.kind,
      label: event.track.label,
      participantLocal: event.participant.local,
      isLocalParticipant: isLocalParticipant,
      isStaleSelfSession: isStaleSelfSession,
      participantId: participantId?.substring(0, 12),
      participantName: participantName,
      localSid: localSid?.substring(0, 12),
      isSpectator: isSpectator
    });

    // Ignore stale self-session track events (old session cleanup)
    if (isStaleSelfSession) {
      console.log('‚ÑπÔ∏è Ignoring stale self-session track stop (old session cleanup)');
      return;
    }

    if (!isLocalParticipant && getParticipantRole(event.participant) === 'spectator') {
      console.log('üîí Ignoring spectator track stop to protect participant streams');
      return;
    }
    
    // Handle LOCAL participant tracks (when they stop their own camera/screen)
    if (isLocalParticipant && event.track.kind === 'video') {
      console.log('üîÑ Local participant stopped their own video track');
      
      // Check if it's the local user's screen share stopping
      const isLocalScreenShare = event.track.label && (
        event.track.label.includes('screen') || 
        event.track.label.includes('Screen') ||
        event.track.label.includes('display') ||
        event.track.label.includes('Display') ||
        event.track.label.includes('web-contents-media-stream')
      );
      
      if (isLocalScreenShare) {
        console.log('üì∫ Local screen share stopped');
        isScreenSharing = false;
        const screenShareBtn = document.getElementById('screen-share-btn');
        if (screenShareBtn) {
          screenShareBtn.classList.remove('active');
        }
        
        // CRITICAL: Restore local video display and remove screen-sharing class
        const localVideo = document.getElementById('local-video');
        const localPlaceholder = document.getElementById('local-placeholder');
        if (localVideo && localPlaceholder) {
          // Remove screen-sharing class to restore mirror effect
          localVideo.classList.remove('screen-sharing');
          console.log('üìπ Restored mirror transform for local video after screen share stopped');
          
          if (isCameraOn) {
            localVideo.style.display = 'block';
            localPlaceholder.style.display = 'none';
          } else {
            localVideo.style.display = 'none';
            localPlaceholder.style.display = 'flex';
          }
        }
      }
      return; // Don't process further for local tracks
    }
    
    // Handle REMOTE participant tracks only
    if (!isLocalParticipant && event.track.kind === 'video') {
      const participantId = event.participant.session_id;
      const participantName = event.participant.user_name || 'Participant';
      
      console.log(`üé• Remote video track stopped for: ${participantName} (${participantId})`);
      
      // IMPROVED: Better screen share detection
      const screenShareVideo = document.getElementById('screen-share-video');
      const spectatorScreenShare = document.getElementById('spectator-screen-share');
      
      const isCurrentlyScreenSharing = isSpectator ? 
        (spectatorScreenShare && !spectatorScreenShare.classList.contains('hidden')) :
        (screenShareVideo && screenShareVideo.style.display === 'block');
      
      // Enhanced screen share detection - check label OR if we're currently showing screen share
      const isScreenShareTrack = isCurrentlyScreenSharing || (event.track.label && (
        event.track.label.includes('screen') || 
        event.track.label.includes('Screen') ||
        event.track.label.includes('display') ||
        event.track.label.includes('Display') ||
        event.track.label.includes('web-contents-media-stream')
      ));
      
      if (isScreenShareTrack) {
        console.log('üì∫ Remote screen share track stopped - restoring camera feed');
        if (isSpectator) {
          hideSpectatorScreenShare();
        } else {
          hideScreenShareVideo();
          // CRITICAL: Restore the camera feed after screen share stops
          restoreParticipantCameraFeed();
        }
      } else {
        console.log(`üì∑ ${participantName} turned off their camera - showing placeholder`);
        
        if (!isSpectator) {
          // Show placeholder but keep participant info
          const remoteVideo = document.getElementById('remote-video');
          const placeholder = document.getElementById('remote-placeholder');
          if (remoteVideo && placeholder) {
            remoteVideo.style.display = 'none';
            placeholder.style.display = 'flex';
            // Update placeholder to show it's just camera off, not disconnected
            updateRemotePlaceholderForCameraOff(event.participant);
          }
        } else {
          // CRITICAL FIX: For spectators, show proper camera-off placeholder AND force overlay
          console.log(`üé≠ SPECTATOR: Showing camera-off placeholder for ${participantName}`);
          updateSpectatorPlaceholderForCameraOff(participantId, event.participant);
          
          // CRITICAL: Force overlay to show when camera turns off
          setTimeout(() => {
            forceSpectatorOverlayVisible('camera-off');
          }, 100);
        }
      }
    }
  }
  
  // CRITICAL: New function to force overlay visibility when cameras turn off
  function forceSpectatorOverlayVisible(reason = 'general') {
    if (!isSpectator) return;
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    if (!clickOverlay) return;
    
    console.log(`üé≠ FORCING OVERLAY VISIBLE - Reason: ${reason}`);
    
    // Force overlay to be visible with maximum priority
    clickOverlay.classList.add('spectator-overlay-force-visible');
    clickOverlay.style.setProperty('display', 'flex', 'important');
    clickOverlay.style.setProperty('opacity', '1', 'important');
    clickOverlay.style.setProperty('visibility', 'visible', 'important');
    clickOverlay.style.setProperty('pointer-events', 'auto', 'important');
    clickOverlay.style.setProperty('z-index', '9999', 'important');
    clickOverlay.classList.remove('hidden');
    
    // Update overlay content based on reason
    const overlayText = clickOverlay.querySelector('.text-center.text-white');
    if (overlayText) {
      const participantCount = (spectatorParticipant1 ? 1 : 0) + (spectatorParticipant2 ? 1 : 0);
      
      if (reason === 'camera-off' && participantCount > 0) {
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path d="M4 6a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM6 8a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1z"/>
              <path d="M2.5 8.5l2-2 2 2M15.5 11.5l-2 2-2-2"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üì∑ Camera Turned Off</p>
          <p class="text-lg text-gold mt-2">${participantCount} participant${participantCount > 1 ? 's' : ''} present, camera disabled</p>
          <div class="mt-6 px-8 py-4 bg-yellow-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK TO WATCH WHEN CAMERA TURNS ON
          </div>
        `;
      } else {
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
          <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
          <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
            üëÜ Click Here to Enable Video
          </div>
        `;
      }
    }
    
    console.log('‚úÖ OVERLAY NOW FORCIBLY VISIBLE FOR SPECTATOR');
  }
  
  // CRITICAL: Restore camera feed after screen share stops
  function restoreParticipantCameraFeed() {
    console.log('üîÑ Restoring participant camera feed after screen share');
    
    // Get the current participant's camera track
    const participants = getParticipantsSnapshot();
    const remoteParticipants = Object.values(participants).filter(p => !p.local);
    
    remoteParticipants.forEach(participant => {
      if (participant.tracks && participant.tracks.video && participant.tracks.video.persistentTrack) {
        const cameraTrack = participant.tracks.video.persistentTrack;
        // Only restore if it's not a screen share track
        if (!cameraTrack.label.includes('screen') && !cameraTrack.label.includes('web-contents-media-stream')) {
          console.log('‚úÖ Restoring camera track for participant:', participant.user_name);
          setupRemoteVideo(cameraTrack);
        }
      }
    });
  }

  function handleAppMessage(event) {
    console.log('üì® App message received:', event);
    
    if (event.data.type === 'spark-selected') {
      currentSparkIndex = event.data.sparkIndex;
      sparkIsSelected = event.data.isSelected;
      updateSparkDisplay();
      if (sparkIsSelected) {
        const currentSparkEl = document.getElementById('currentSpark');
        currentSparkEl.classList.add('ring-4', 'ring-gold');
        currentSparkEl.style.background = 'linear-gradient(135deg, #FFD166 0%, #FFB6B9 100%)';
      }
    } else if (event.data.type === 'sparks-updated') {
      console.log("üì® Receiving updated sparks from other participant");
      currentSparks = event.data.sparks;
      currentSparkIndex = 0;
      updateSparkDisplay();
      showToast(`‚ú® Partner generated new sparks for "${event.data.topic}"!`);
    } else if (event.data.type === 'tip-celebration') {
      // Received a tip celebration from another participant!
      console.log('üéâ Tip celebration received via LiveKit:', event.data.tipData);
      const tipData = event.data.tipData;
      if (tipData) {
        // Check if this is from someone else (not ourselves)
        const myName = window.currentUserData?.username || window.currentUserData?.displayName || userName;
        if (tipData.senderName !== myName) {
          console.log('üéâ Playing tip celebration from:', tipData.senderName);
          playTipCelebration(tipData);
        } else {
          console.log('üîî Skipping our own tip celebration (already played locally)');
        }
      }
    } else if (event.data.type === 'pot-update') {
      // Received a pot update from another spectator's tip
      console.log('üî¥ Pot update received via LiveKit:', event.data);
      if (typeof handlePotUpdate === 'function') {
        handlePotUpdate(event.data);
      }
    } else if (event.data.type === 'debate-ended') {
      // Host ended the debate - show notification to all users
      console.log('üèÅ Debate ended notification received via LiveKit:', event.data);
      if (typeof handleDebateEnded === 'function') {
        handleDebateEnded(event.data);
      }
    } else if (event.data.type === 'room-ended') {
      // Host ended a green room - show notification to all users
      console.log('üü¢ Room ended notification received via LiveKit:', event.data);
      if (typeof handleGreenRoomEnded === 'function') {
        handleGreenRoomEnded(event.data);
      }
    }
  }

  function handleError(event) {
    console.error('‚ùå Daily.co error:', event);
    showToast('Video call error: ' + event.errorMsg);
  }

  function handleCameraError(event) {
    console.error('üé•‚ùå Camera/Microphone error:', event);
    
    const { error } = event;
    
    switch (error.type) {
      case 'permissions':
        if (error.blockedMedia.includes('audio')) {
          console.error('üé§‚ùå Microphone permissions denied!');
          showToast('‚ùå Microphone access denied. Please allow microphone access and reload.');
        }
        if (error.blockedMedia.includes('video')) {
          console.error('üìπ‚ùå Camera permissions denied!');
          showToast('‚ùå Camera access denied. Please allow camera access and reload.');
        }
        break;
        
      case 'cam-in-use':
      case 'mic-in-use':
      case 'cam-mic-in-use':
        console.error('üîí Device in use by another application');
        showToast('‚ùå Camera or microphone is being used by another app. Please close other apps and try again.');
        break;
        
      case 'not-found':
        if (error.missingMedia.includes('audio')) {
          console.error('üé§‚ùå No microphone found!');
          showToast('‚ùå No microphone detected. Please check your device.');
        }
        if (error.missingMedia.includes('video')) {
          console.error('üìπ‚ùå No camera found!');
          showToast('‚ùå No camera detected. Please check your device.');
        }
        break;
        
      default:
        console.error('‚ùå Unknown camera error:', error);
        showToast('‚ùå Device error: ' + error.msg);
    }
  }

  function updateRecordingStatusIndicator(mode, progress = 0) {
    const statusEl = document.getElementById('recording-status');
    const uploadStatusEl = document.getElementById('recording-upload-status');
    const uploadPercentEl = document.getElementById('recording-upload-percent');
    const uploadBarEl = document.getElementById('recording-upload-bar');
    const uploadFillEl = document.getElementById('recording-upload-bar-fill');
    const modeLabelEl = document.getElementById('recording-mode-label');
    const recordingDotEl = statusEl ? statusEl.querySelector('.recording-dot') : null;

    if (!statusEl || !uploadStatusEl || !uploadPercentEl || !uploadBarEl || !uploadFillEl || !modeLabelEl || !recordingDotEl) {
      return;
    }

    if (mode === 'recording') {
      statusEl.classList.remove('hidden');
      statusEl.classList.add('recording-indicator');
      uploadStatusEl.classList.add('hidden');
      uploadBarEl.classList.add('hidden');
      uploadFillEl.style.width = '0%';
      uploadPercentEl.textContent = '0%';
      recordingDotEl.classList.remove('opacity-75');
    } else if (mode === 'uploading') {
      statusEl.classList.remove('hidden');
      statusEl.classList.remove('recording-indicator');
      uploadStatusEl.classList.remove('hidden');
      uploadBarEl.classList.remove('hidden');
      const boundedProgress = Math.max(0, Math.min(100, Math.round(progress || 0)));
      uploadPercentEl.textContent = `${boundedProgress}%`;
      uploadFillEl.style.width = `${boundedProgress}%`;
      recordingDotEl.classList.add('opacity-75');
    } else {
      statusEl.classList.add('hidden');
      statusEl.classList.remove('recording-indicator');
      uploadStatusEl.classList.add('hidden');
      uploadBarEl.classList.add('hidden');
      uploadFillEl.style.width = '0%';
      recordingDotEl.classList.remove('opacity-75');
    }
  }

  function resetRecordingUploadState() {
    recordingUploadState.isUploading = false;
    recordingUploadState.progress = 0;
    recordingUploadState.pendingPayloadString = null;
    recordingUploadState.pendingEndpoint = null;
    recordingUploadState.dbPath = null;
    if (recordingUploadState.hideTimeout) {
      clearTimeout(recordingUploadState.hideTimeout);
      recordingUploadState.hideTimeout = null;
    }
  }

  function clearRecordingDownloadWatcher() {
    if (recordingDownloadWatcher.timeoutId) {
      clearTimeout(recordingDownloadWatcher.timeoutId);
      recordingDownloadWatcher.timeoutId = null;
    }
    if (recordingDownloadWatcher.dbRef) {
      recordingDownloadWatcher.dbRef.off('value');
      recordingDownloadWatcher.dbRef = null;
    }
  }

  function updateRecordingDownloadUi({ show = false, message = '', url = null, ready = false } = {}) {
    if (isSpectator) return;
    const container = document.getElementById('recording-download-container');
    const statusText = document.getElementById('recording-download-status-text');
    const linkEl = document.getElementById('recording-download-link');
    const copyBtn = document.getElementById('copy-recording-link');
    if (!container || !statusText || !linkEl || !copyBtn) {
      return;
    }

    if (show) {
      container.classList.remove('hidden');
    } else {
      container.classList.add('hidden');
    }

    statusText.textContent = message || '';

    if (ready && url) {
      linkEl.href = url;
      linkEl.classList.remove('pointer-events-none', 'opacity-50');
      linkEl.removeAttribute('aria-disabled');
      linkEl.dataset.recordingUrl = url;
      copyBtn.disabled = false;
      copyBtn.dataset.recordingUrl = url;
    } else {
      linkEl.href = '#';
      linkEl.classList.add('pointer-events-none', 'opacity-50');
      linkEl.setAttribute('aria-disabled', 'true');
      delete linkEl.dataset.recordingUrl;
      copyBtn.disabled = true;
      delete copyBtn.dataset.recordingUrl;
    }
  }

  function hideRecordingDownloadUi() {
    clearRecordingDownloadWatcher();
    recordingDownloadWatcher.currentRecordingId = null;
    updateRecordingDownloadUi({ show: false, message: '' });
  console.log('üìº Recording download UI hidden/reset');
  }

  function showRecordingDownloadPending() {
  console.log('üìº Recording link pending...');
    updateRecordingDownloadUi({
      show: true,
      message: 'Preparing download link...',
      ready: false
    });
  }

  function showRecordingDownloadReady(url) {
  console.log('üìº Recording link ready:', url);
    updateRecordingDownloadUi({
      show: true,
      message: 'Ready to download',
      ready: true,
      url
    });
    finalizeRecordingUpload('download-ready');
  }

  function showRecordingDownloadError() {
  console.warn('‚ö†Ô∏è Recording link not available yet.');
    updateRecordingDownloadUi({
      show: true,
      message: 'Link not ready yet. Check the recordings list shortly.',
      ready: false
    });
  }

  async function pollRecordingDownloadUrl(recordingId, attempt = 0) {
    if (isSpectator || !recordingId || recordingDownloadWatcher.currentRecordingId !== recordingId) {
      return;
    }
    if (!roomUrl || !firebaseConfig?.databaseURL) {
      showRecordingDownloadError();
      return;
    }

    try {
    console.log(`üìº Polling recording link (attempt ${attempt + 1}/${RECORDING_DOWNLOAD_MAX_ATTEMPTS}) for ${recordingId}`);
      const roomKey = btoa(roomUrl);
      const path = `recordings/${roomKey}/${recordingId}`;
      const endpoint = await getAuthedRealtimeUrl(firebaseConfig.databaseURL, path);
      const response = await fetch(endpoint);
      if (!response.ok) {
        throw new Error(`Failed to fetch recording entry: ${response.status}`);
      }
      const data = await response.json();

      if (recordingDownloadWatcher.currentRecordingId !== recordingId) {
        return;
      }

      const downloadUrl = data?.downloadUrl;
      if (downloadUrl) {
        showRecordingDownloadReady(downloadUrl);
        clearRecordingDownloadWatcher();
        return;
      }

      if (attempt + 1 < RECORDING_DOWNLOAD_MAX_ATTEMPTS) {
        recordingDownloadWatcher.timeoutId = setTimeout(() => {
          recordingDownloadWatcher.timeoutId = null;
          pollRecordingDownloadUrl(recordingId, attempt + 1);
        }, RECORDING_DOWNLOAD_POLL_INTERVAL_MS);
      } else {
        showRecordingDownloadError();
      }
    } catch (error) {
    console.warn('‚ö†Ô∏è Unable to fetch recording download data:', error);
      if (attempt + 1 < RECORDING_DOWNLOAD_MAX_ATTEMPTS) {
        recordingDownloadWatcher.timeoutId = setTimeout(() => {
          recordingDownloadWatcher.timeoutId = null;
          pollRecordingDownloadUrl(recordingId, attempt + 1);
        }, RECORDING_DOWNLOAD_POLL_INTERVAL_MS);
      } else {
        showRecordingDownloadError();
      }
    }
  }

  function startRecordingDownloadWatcher(recordingId) {
    if (isSpectator || !recordingId) return;
    clearRecordingDownloadWatcher();
    recordingDownloadWatcher.currentRecordingId = recordingId;
    showRecordingDownloadPending();
  console.log('üìº Starting recording download watcher for', recordingId);
    if (db && firebase?.auth()?.currentUser && firebaseConfig?.databaseURL) {
      try {
        const roomKey = btoa(roomUrl);
        const path = `recordings/${roomKey}/${recordingId}`;
        const ref = db.ref(path);
        recordingDownloadWatcher.dbRef = ref;
        ref.on('value', (snapshot) => {
          if (recordingDownloadWatcher.currentRecordingId !== recordingId) {
            return;
          }
          const data = snapshot.val();
          const downloadUrl = data?.downloadUrl;
        console.log('üìº Realtime watcher value for', recordingId, data);
        if (downloadUrl) {
            showRecordingDownloadReady(downloadUrl);
            clearRecordingDownloadWatcher();
          }
        });
        // Fallback safety timeout in case realtime listener never fires
        recordingDownloadWatcher.timeoutId = setTimeout(() => {
          recordingDownloadWatcher.timeoutId = null;
          if (recordingDownloadWatcher.currentRecordingId === recordingId) {
            pollRecordingDownloadUrl(recordingId, 0);
          }
        }, RECORDING_DOWNLOAD_POLL_INTERVAL_MS * 2);
      } catch (err) {
        console.warn('‚ö†Ô∏è Unable to start realtime recording watcher:', err);
        pollRecordingDownloadUrl(recordingId, 0);
      }
    } else {
      pollRecordingDownloadUrl(recordingId, 0);
    }
  }

  async function copyRecordingDownloadLink() {
    if (isSpectator) return;
    const linkEl = document.getElementById('recording-download-link');
    const copyBtn = document.getElementById('copy-recording-link');
    if (!linkEl || !copyBtn) {
      return;
    }
    const url = linkEl.dataset.recordingUrl || copyBtn.dataset.recordingUrl || linkEl.href;
    if (!url || url === '#' || linkEl.classList.contains('pointer-events-none')) {
      showToast('‚ö†Ô∏è Recording link not ready yet');
      return;
    }
    try {
      await navigator.clipboard.writeText(url);
      showToast('üìã Recording link copied');
    } catch (err) {
      console.error('‚ùå Unable to copy recording link:', err);
      showToast('‚ùå Unable to copy recording link');
    }
  }

  function finalizeRecordingUpload(source = 'unknown') {
    console.log(`‚úÖ Recording upload finalized via ${source}`);
    recordingUploadState.isUploading = false;
    recordingUploadState.progress = 100;
    updateRecordingStatusIndicator('uploading', 100);
    if (recordingUploadState.hideTimeout) {
      clearTimeout(recordingUploadState.hideTimeout);
    }
    recordingUploadState.hideTimeout = setTimeout(() => {
      updateRecordingStatusIndicator('idle');
      resetRecordingUploadState();
    }, 1500);
  }

  async function markRecordingUploadCompleteInDatabase() {
    if (!recordingUploadState.dbPath) {
      return;
    }
    try {
      await db.ref(recordingUploadState.dbPath).update({
        status: 'uploaded',
        uploadProgress: 100,
        uploadCompletedAt: firebase.database.ServerValue.TIMESTAMP
      });
    } catch (error) {
      console.error('‚ùå Failed to mark recording as uploaded:', error);
    }
  }

  // Recording event handlers
    function handleRecordingStarted(event) {
      console.log('üé• Recording started:', event);
      isRecording = true;
      recordingId = event?.recordingId || recordingId || `recording_${Date.now()}`;
    
    hideRecordingDownloadUi();
    resetRecordingUploadState();
    updateRecordingStatusIndicator('recording');
    
    // Update record button
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.add('active');
    }
    
    showToast('üé¨ Recording started!');
  }

    async function handleRecordingStopped(event) {
      console.log('üõë Recording stopped:', event);
      isRecording = false;
      recordingId = event?.recordingId || recordingId;
    
    recordingUploadState.isUploading = true;
    recordingUploadState.progress = 0;
    updateRecordingStatusIndicator('uploading', 0);
    if (roomUrl && recordingId && firebaseConfig?.databaseURL) {
      const prospectiveRoomId = btoa(roomUrl);
      const prospectivePath = `recordings/${prospectiveRoomId}/${recordingId}`;
      recordingUploadState.dbPath = prospectivePath;
      try {
        recordingUploadState.pendingEndpoint = getRealtimeDatabaseRestUrl(firebaseConfig.databaseURL, prospectivePath);
      } catch (endpointError) {
        console.warn('‚ö†Ô∏è Unable to precompute recording endpoint:', endpointError);
      }
    }
    
    // Update record button
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.remove('active');
    }
    
    // Save recording metadata to Firebase
    if (recordingId) {
      try {
        await saveRecordingMetadata(event);
        showToast('üé¨ Recording stopped. Uploading in background...');
        startRecordingDownloadWatcher(recordingId);
      } catch (error) {
        console.error('‚ùå Failed to persist recording metadata:', error);
        showToast('‚ùå Failed to save recording data');
        updateRecordingStatusIndicator('idle');
        recordingUploadState.isUploading = false;
        hideRecordingDownloadUi();
      }
    } else {
      console.warn('‚ö†Ô∏è Recording stopped without an ID. Skipping metadata save.');
      updateRecordingStatusIndicator('idle');
      recordingUploadState.isUploading = false;
      hideRecordingDownloadUi();
    }
  }

  function handleRecordingUploadProgress(event) {
    const percentValue = typeof event?.percent === 'number'
      ? event.percent
      : (typeof event?.progress === 'number' ? event.progress : 0);
    const percent = Math.max(0, Math.min(100, Math.round(percentValue)));
    
    recordingUploadState.isUploading = true;
    recordingUploadState.progress = percent;
    updateRecordingStatusIndicator('uploading', percent);
    
    if (percent >= 100) {
      markRecordingUploadCompleteInDatabase();
      finalizeRecordingUpload('progress-event');
    }
  }

  async function handleRecordingUploadCompleted(event) {
    console.log('‚úÖ Recording upload completed:', event);
    await markRecordingUploadCompleteInDatabase();
    finalizeRecordingUpload('upload-completed-event');
    showToast('‚úÖ Recording uploaded!');
  }

  function handleRecordingError(event) {
    console.error('‚ùå Recording error:', event);
    showToast('‚ùå Recording error: ' + (event?.errorMsg || event?.message || 'unknown error'));
    updateRecordingStatusIndicator('idle');
    resetRecordingUploadState();
  }

  // Video setup functions
  function setupLocalVideo(track) {
    if (isSpectator) return; // Spectators don't have local video
    
    localVideo = document.getElementById('local-video');
    const placeholder = document.getElementById('local-placeholder');
    
    try {
      if (track && track instanceof MediaStreamTrack) {
        localVideo.srcObject = new MediaStream([track]);
        } else {
          const localParticipant = getParticipantsSnapshot().local;
        if (localParticipant && localParticipant.tracks && localParticipant.tracks.video) {
          const videoTrack = localParticipant.tracks.video.track || localParticipant.tracks.video.persistentTrack;
          if (videoTrack && videoTrack instanceof MediaStreamTrack) {
            localVideo.srcObject = new MediaStream([videoTrack]);
          }
        }
      }
      
      if (isCameraOn && localVideo.srcObject) {
        localVideo.style.display = 'block';
        placeholder.style.display = 'none';
      } else {
        localVideo.style.display = 'none';
        placeholder.style.display = 'flex';
      }
    } catch (error) {
      console.error("‚ùå Error setting up local video:", error);
      localVideo.style.display = 'none';
      placeholder.style.display = 'flex';
    }
  }

  function setupRemoteVideo(track) {
    console.log('üìπ setupRemoteVideo called', {
      hasTrack: !!track,
      trackKind: track?.kind,
      trackLabel: track?.label,
      trackReadyState: track?.readyState,
      isSpectator,
      isSafari
    });
    
    if (isSpectator) {
      console.log('üìπ Spectator mode - using spectator video setup instead');
      return;
    }
    
    remoteVideo = document.getElementById('remote-video');
    const placeholder = document.getElementById('remote-placeholder');
    
    if (!remoteVideo) {
      console.error('‚ùå Remote video element not found!');
      return;
    }
    
    if (!track) {
      console.error('‚ùå setupRemoteVideo called with no track!');
      return;
    }
    
    // Log current state for debugging
    console.log('üìπ Remote video current state:', {
      hasExistingStream: !!remoteVideo.srcObject,
      display: remoteVideo.style.display,
      hidden: remoteVideo.classList.contains('hidden'),
      paused: remoteVideo.paused
    });
    
    // SIMPLIFIED: Always set up the video - don't block
    console.log('üìπ Setting up remote video stream...');
    
    try {
      // Create new stream with the track
      remoteVideo.srcObject = new MediaStream([track]);
      
      // Force visibility
      remoteVideo.style.display = 'block';
      remoteVideo.style.visibility = 'visible';
      remoteVideo.style.opacity = '1';
      remoteVideo.classList.remove('hidden');
      
      // Hide placeholder
      if (placeholder) {
        placeholder.style.display = 'none';
        placeholder.classList.add('hidden');
      }
      
      // Hide waiting overlay
      hideWaitingOverlay();
      
      // Set video attributes for Safari compatibility
      remoteVideo.setAttribute('autoplay', '');
      remoteVideo.setAttribute('playsinline', '');
      remoteVideo.setAttribute('webkit-playsinline', '');
      remoteVideo.muted = false;
      
      // CRITICAL: Always attempt to play the video
      console.log('‚ñ∂Ô∏è Attempting to play remote video...');
      
      const playVideo = () => {
        remoteVideo.play().then(() => {
          console.log('‚úÖ Remote video now playing!');
        }).catch(err => {
          console.warn('‚ö†Ô∏è Remote video autoplay blocked:', err.message);
          // Set up click handler to play on user interaction
          const playOnInteraction = () => {
            if (remoteVideo && remoteVideo.srcObject) {
              remoteVideo.play().then(() => {
                console.log('‚úÖ Remote video playing after user interaction');
              }).catch(e => console.log('Play retry failed:', e.message));
            }
            document.removeEventListener('click', playOnInteraction);
            document.removeEventListener('touchstart', playOnInteraction);
          };
          document.addEventListener('click', playOnInteraction, { once: true });
          document.addEventListener('touchstart', playOnInteraction, { once: true });
          showToast('üëÜ Tap anywhere to start video');
        });
      };
      
      // Try to play immediately
      playVideo();
      
      // Also try after a short delay (helps with Safari)
      setTimeout(playVideo, 500);
      setTimeout(playVideo, 1500);
      
      // Double-check visibility after delays
      setTimeout(() => {
        if (remoteVideo && remoteVideo.srcObject) {
          console.log('üìπ Video status check:', {
            paused: remoteVideo.paused,
            readyState: remoteVideo.readyState,
            videoWidth: remoteVideo.videoWidth,
            videoHeight: remoteVideo.videoHeight
          });
          
          // Force play again if paused
          if (remoteVideo.paused) {
            console.log('üìπ Video still paused, attempting play...');
            playVideo();
          }
        }
      }, 2000);
      
      console.log('‚úÖ Remote video set up successfully', {
        srcObjectSet: !!remoteVideo.srcObject,
        display: remoteVideo.style.display,
        trackId: track.id
      });
      
      // Hide the reload hint since video is working
      const reloadHint = document.getElementById('video-reload-hint');
      if (reloadHint) {
        reloadHint.classList.add('hidden');
      }
    } catch (error) {
      console.error('‚ùå Failed to set up remote video:', error);
    }
  }

  // Retry setting up remote video for a specific participant
  function retrySetupRemoteVideoForParticipant(participantId, attemptNum) {
    // Check if video is already working
    const remoteVideoEl = document.getElementById('remote-video');
    if (remoteVideoEl && remoteVideoEl.srcObject && remoteVideoEl.style.display === 'block') {
      console.log(`‚úÖ Remote video already working, skipping retry ${attemptNum}`);
      return;
    }
    
    console.log(`üîÑ Retry ${attemptNum}: looking for video track for participant ${participantId?.substring(0, 12)}`);
    
    if (!livekitRoom) {
      console.log('‚ö†Ô∏è LiveKit room not available for retry');
      return;
    }
    
    const lkParticipant = livekitRoom.remoteParticipants.get(participantId);
    if (!lkParticipant) {
      console.log('‚ö†Ô∏è Participant not found in LiveKit room');
      return;
    }
    
    // Try to find video track
    let videoTrack = null;
    
    // Method 1: Get camera publication
    const cameraPub = lkParticipant.getTrackPublication('camera');
    if (cameraPub) {
      // Try to subscribe if not subscribed
      if (cameraPub.isSubscribed === false && typeof cameraPub.setSubscribed === 'function') {
        console.log(`üì° Retry ${attemptNum}: subscribing to camera track`);
        try {
          cameraPub.setSubscribed(true);
        } catch (e) {
          console.log('‚ö†Ô∏è Could not subscribe:', e.message);
        }
      }
      
      if (cameraPub.track?.mediaStreamTrack?.readyState === 'live') {
        videoTrack = cameraPub.track.mediaStreamTrack;
        console.log('üé• Retry: found track via camera publication');
      } else if (cameraPub.track?.readyState === 'live') {
        videoTrack = cameraPub.track;
        console.log('üé• Retry: found track via camera publication (direct)');
      }
    }
    
    // Method 2: Search all video publications
    if (!videoTrack) {
      for (const pub of lkParticipant.videoTrackPublications.values()) {
        if (pub.source === 'camera' || !pub.source?.includes('screen')) {
          // Try to subscribe if not subscribed
          if (pub.isSubscribed === false && typeof pub.setSubscribed === 'function') {
            console.log(`üì° Retry ${attemptNum}: subscribing to video track`);
            try {
              pub.setSubscribed(true);
            } catch (e) {
              console.log('‚ö†Ô∏è Could not subscribe:', e.message);
            }
          }
          
          if (pub.track?.mediaStreamTrack?.readyState === 'live') {
            videoTrack = pub.track.mediaStreamTrack;
            console.log('üé• Retry: found track via video publications');
            break;
          } else if (pub.track?.readyState === 'live') {
            videoTrack = pub.track;
            console.log('üé• Retry: found track via video publications (direct)');
            break;
          }
        }
      }
    }
    
    if (videoTrack) {
      console.log(`‚úÖ Retry ${attemptNum}: found video track, setting up...`);
      setupRemoteVideo(videoTrack);
      updateRemoteInfo(lkParticipant.identity || 'Guest');
      hideWaitingOverlay();
    } else {
      console.log(`‚ö†Ô∏è Retry ${attemptNum}: no video track found yet`);
    }
  }

  // Track which participant slots are used (only 2 participants max)
  let spectatorParticipant1 = null; // { participantId, participantName }
  let spectatorParticipant2 = null; // { participantId, participantName }

  // Cache for participant badges (populated from chat messages)
  const participantBadgeCache = new Map();

  function cacheParticipantBadge(participantId, badge) {
    if (participantId && badge) {
      participantBadgeCache.set(participantId, badge);
    }
  }

  function getParticipantBadgeFromCache(participantId) {
    return participantBadgeCache.get(participantId) || null;
  }

  // Update badge display when chat message reveals a user's badge
  function updateParticipantBadgeFromMessage(message) {
    if (message.userId && message.badge) {
      cacheParticipantBadge(message.userId, message.badge);
      
      // Update displayed badges if this user is visible
      if (spectatorParticipant1 && participantBadgeCache.has(message.userId)) {
        const p1 = getParticipantsSnapshot()[Object.keys(getParticipantsSnapshot()).find(k => 
          getParticipantsSnapshot()[k].session_id === spectatorParticipant1.participantId)];
        if (p1 && getParticipantUserId(p1) === message.userId) {
          const badgeEl = document.getElementById('spectator-badge-1');
          if (badgeEl && message.badge.emoji) {
            badgeEl.textContent = message.badge.emoji;
            badgeEl.title = message.badge.label || '';
            badgeEl.classList.remove('hidden');
          }
        }
      }
      if (spectatorParticipant2 && participantBadgeCache.has(message.userId)) {
        const p2 = getParticipantsSnapshot()[Object.keys(getParticipantsSnapshot()).find(k => 
          getParticipantsSnapshot()[k].session_id === spectatorParticipant2.participantId)];
        if (p2 && getParticipantUserId(p2) === message.userId) {
          const badgeEl = document.getElementById('spectator-badge-2');
          if (badgeEl && message.badge.emoji) {
            badgeEl.textContent = message.badge.emoji;
            badgeEl.title = message.badge.label || '';
            badgeEl.classList.remove('hidden');
          }
        }
      }
      
      // Update remote participant badge (for participants)
      if (!isSpectator) {
        const remoteBadgeEl = document.getElementById('remote-badge');
        if (remoteBadgeEl && message.badge.emoji) {
          remoteBadgeEl.textContent = message.badge.emoji;
          remoteBadgeEl.classList.remove('hidden');
        }
      }
    }
  }

  function setupSpectatorVideo(track, participantId) {
    console.log('üé¨ setupSpectatorVideo called', {
      hasTrack: !!track,
      trackKind: track?.kind,
      trackLabel: track?.label,
      trackReadyState: track?.readyState,
      participantId,
      isSafari,
      userHasInteracted,
      currentSlots: {
        slot1: spectatorParticipant1?.participantId,
        slot2: spectatorParticipant2?.participantId
      }
    });
    
    if (!track) {
      console.error('‚ùå setupSpectatorVideo called with no track!');
      return;
    }
    
    // Check if this participant already has a video set up to prevent duplicates
    if ((spectatorParticipant1 && spectatorParticipant1.participantId === participantId) ||
        (spectatorParticipant2 && spectatorParticipant2.participantId === participantId)) {
      const existingSlot = spectatorParticipant1?.participantId === participantId ? 1 : 2;
      const videoElement = document.getElementById(`spectator-participant-${existingSlot}`);
      const placeholder = document.getElementById(`spectator-placeholder-${existingSlot}`);
      
      // CRITICAL: Always update when camera turns back on (even if same track)
      console.log(`üîÑ Camera turned back on for participant ${participantId} in slot ${existingSlot}`);
      
      try {
        videoElement.srcObject = new MediaStream([track]);
        
        // CRITICAL: Hide placeholder and show video when camera turns back on
        placeholder.style.display = 'none';
        placeholder.classList.add('hidden');
        videoElement.classList.remove('hidden');
        videoElement.style.display = 'block';
        
        // Force video visibility styles
        videoElement.style.visibility = 'visible';
        videoElement.style.opacity = '1';
        hideWaitingOverlay();
        
        console.log(`‚úÖ Spectator video restored for participant ${participantId} - camera back on`);
        
        // Try to play - Safari and other browsers
        const attemptPlay = () => {
          videoElement.play().then(() => {
            console.log(`‚úÖ Participant ${participantId} video now playing after camera restoration`);
          }).catch(err => {
            console.log(`üé• Video play failed for participant ${participantId}:`, err.message);
            if (isSafari) {
              console.log('üçé Safari: Video will play after user interaction');
            }
          });
        };
        
        if (userHasInteracted) {
          attemptPlay();
        } else if (isSafari) {
          console.log('üçé Safari: Waiting for user interaction to play video');
        }
        
        // CRITICAL: Hide overlay when camera turns back on
        setTimeout(() => {
          checkAndHideClickOverlay();
        }, 100);
      } catch (error) {
        console.error(`‚ùå Failed to update spectator video for slot ${existingSlot}:`, error);
      }
      
      return;
    }
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    // Assign participant to available slot (max 2 participants)
    let participantSlot = null;
    let participantName = getParticipantName(participantId);
    
    // Try to get the user ID from LiveKit participant metadata
    // Note: remoteParticipants is keyed by identity, not SID, so we need to iterate
    let participantUserId = null;
    if (livekitRoom && livekitRoom.remoteParticipants) {
      // First try direct lookup by participantId (in case it's the identity)
      let lkParticipant = livekitRoom.remoteParticipants.get(participantId);
      
      // If not found, iterate to find by SID
      if (!lkParticipant) {
        for (const [identity, p] of livekitRoom.remoteParticipants) {
          if (p.sid === participantId) {
            lkParticipant = p;
            break;
          }
        }
      }
      
      if (lkParticipant) {
        const metadata = parseLiveKitMetadata(lkParticipant.metadata);
        participantUserId = metadata?.userId || metadata?.user_id || null;
        // Also get the name from metadata if available
        if (metadata?.displayName) {
          participantName = metadata.displayName;
        } else if (metadata?.username) {
          participantName = metadata.username;
        }
        console.log('üÜî Extracted userId from participant metadata:', participantUserId, 'for SID:', participantId);
      } else {
        console.log('‚ö†Ô∏è Could not find LiveKit participant for SID:', participantId);
      }
    }
    
    if (!spectatorParticipant1) {
      spectatorParticipant1 = { participantId, participantName, userId: participantUserId };
      participantSlot = 1;
      console.log('üìç Assigned to slot 1:', { participantId: participantId?.substring(0, 15), participantName, userId: participantUserId?.substring(0, 15) || 'null' });
    } else if (!spectatorParticipant2) {
      spectatorParticipant2 = { participantId, participantName, userId: participantUserId };
      participantSlot = 2;
      console.log('üìç Assigned to slot 2:', { participantId: participantId?.substring(0, 15), participantName, userId: participantUserId?.substring(0, 15) || 'null' });
    } else {
      console.log('‚ö†Ô∏è Already have 2 participants, ignoring additional participant:', participantId);
      return;
    }
    
    // Get the video element and placeholder for this slot
    const videoElement = document.getElementById(`spectator-participant-${participantSlot}`);
    const placeholder = document.getElementById(`spectator-placeholder-${participantSlot}`);
    const nameElement = document.getElementById(`spectator-name-${participantSlot}`);
    
    if (!videoElement || !placeholder || !nameElement) {
      console.error(`‚ùå Spectator elements not found for slot ${participantSlot}`);
      return;
    }
    
    try {
      // Set up video stream
      videoElement.srcObject = new MediaStream([track]);
      
      // Update participant name - check for new text span structure
      const nameTextEl = document.getElementById(`spectator-name-text-${participantSlot}`);
      if (nameTextEl) {
        nameTextEl.textContent = participantName;
      } else {
        nameElement.textContent = participantName;
      }
      nameElement.classList.remove('hidden');
      
      // Show badge if available in cache
      const badgeEl = document.getElementById(`spectator-badge-${participantSlot}`);
      const participantBadge = getParticipantBadgeFromCache(participantId);
      if (badgeEl && participantBadge?.emoji) {
        badgeEl.textContent = participantBadge.emoji;
        badgeEl.title = participantBadge.label || '';
        badgeEl.classList.remove('hidden');
      }
      
      // Force hide placeholder and show video element
      placeholder.style.display = 'none';
      placeholder.classList.add('hidden');
      videoElement.classList.remove('hidden');
      videoElement.style.display = 'block';
      
      console.log(`‚úÖ Spectator video set up for participant ${participantId} in slot ${participantSlot}`);
      
      // Force styles to ensure visibility
      videoElement.style.display = 'block';
      videoElement.style.visibility = 'visible';
      videoElement.style.opacity = '1';
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      
      // Force placeholder to hide
      placeholder.style.display = 'none';
      placeholder.classList.add('hidden');
      hideWaitingOverlay();
      
      // Get comprehensive debugging info
      const debugInfo = {
        participantId: participantId,
        slot: participantSlot,
        videoElement: {
          hidden: videoElement.classList.contains('hidden'),
          display: videoElement.style.display,
          computedDisplay: window.getComputedStyle(videoElement).display,
          visibility: videoElement.style.visibility,
          opacity: videoElement.style.opacity,
          srcObject: !!videoElement.srcObject,
          videoWidth: videoElement.videoWidth,
          videoHeight: videoElement.videoHeight,
          readyState: videoElement.readyState,
          classList: videoElement.classList.toString(),
          bounds: videoElement.getBoundingClientRect(),
          hasVideoTracks: videoElement.srcObject ? videoElement.srcObject.getVideoTracks().length : 0
        },
        placeholder: {
          hidden: placeholder.classList.contains('hidden'),
          display: placeholder.style.display,
          computedDisplay: window.getComputedStyle(placeholder).display
        },
        parent: {
          classList: videoElement.parentElement.classList.toString(),
          display: videoElement.parentElement.style.display,
          computedDisplay: window.getComputedStyle(videoElement.parentElement).display,
          bounds: videoElement.parentElement.getBoundingClientRect()
        }
      };
      
      console.log(`üì∫ COMPREHENSIVE DEBUG - Slot ${participantSlot}:`, debugInfo);
      
      // Special debugging for slot 2
      if (participantSlot === 2) {
        console.log(`üî¥ SLOT 2 SPECIAL DEBUG:`);
        console.log(`üî¥ Video element:`, videoElement);
        console.log(`üî¥ Video bounds:`, videoElement.getBoundingClientRect());
        console.log(`üî¥ Video computed styles:`, {
          display: window.getComputedStyle(videoElement).display,
          visibility: window.getComputedStyle(videoElement).visibility,
          opacity: window.getComputedStyle(videoElement).opacity,
          position: window.getComputedStyle(videoElement).position,
          zIndex: window.getComputedStyle(videoElement).zIndex,
          transform: window.getComputedStyle(videoElement).transform
        });
        console.log(`üî¥ Parent element:`, videoElement.parentElement);
        console.log(`üî¥ Parent bounds:`, videoElement.parentElement.getBoundingClientRect());
        
        // Clear any debug styles
        videoElement.style.backgroundColor = '';
        videoElement.style.border = '';
        
        console.log(`üî¥ Applied debug styles to slot 2`);
      
      // Check click overlay state
      const clickOverlay = document.getElementById('spectator-click-overlay');
      console.log(`üî¥ Click overlay state:`, {
        exists: !!clickOverlay,
        display: clickOverlay ? clickOverlay.style.display : 'N/A',
        computedDisplay: clickOverlay ? window.getComputedStyle(clickOverlay).display : 'N/A',
        opacity: clickOverlay ? clickOverlay.style.opacity : 'N/A',
        classList: clickOverlay ? clickOverlay.classList.toString() : 'N/A'
      });
      }
      
      // Check if we should auto-hide the click overlay
      checkAndHideClickOverlay();
      
      // Update expand buttons availability
      updateSpectatorExpandButtons();
      
      // Ensure video plays - auto-play if user has already interacted
      if (userHasInteracted) {
        videoElement.play().then(() => {
          console.log(`‚úÖ Spectator video playing for participant ${participantId}`);
        }).catch(err => {
          console.log(`üé• Video will auto-play after interaction for participant ${participantId}`);
        });
      } else {
        console.log(`üé• Video ready to play after user interaction for participant ${participantId}`);
      }
      
      // Update Red Room pot targets when spectators see participants
      if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
        setTimeout(() => {
          updatePotTargets();
          // Reload pot state from Supabase to get accurate tip amounts
          if (typeof loadPotStateFromSupabase === 'function') {
            loadPotStateFromSupabase();
          }
        }, 500);
      }
      
    } catch (error) {
      console.error('‚ùå Error setting up spectator video:', error);
    }
  }

// Global flag to track if user has interacted
let userHasInteracted = false;

function shouldTreatParticipantAsSpectator(participant) {
  if (!participant) return false;
  const metadata = parseLiveKitMetadata(participant.metadata);
  if (metadata?.role === 'spectator') return true;
  const identity = participant.identity || participant.sid || '';
  return typeof identity === 'string' && identity.startsWith('Viewer_');
}

function ensureSpectatorTracksForParticipant(participant) {
  if (!isSpectator || !participant || shouldTreatParticipantAsSpectator(participant)) return;
  try {
    const publications = participant.trackPublications || participant.tracks;
    if (!publications) return;
    const iteratePublications = (callback) => {
      if (typeof publications.forEach === 'function') {
        publications.forEach(callback);
      } else if (Array.isArray(publications)) {
        publications.forEach(callback);
      } else if (publications && typeof publications.values === 'function') {
        for (const publication of publications.values()) {
          callback(publication);
        }
      }
    };
    iteratePublications((publication) => {
      if (!publication) return;
      if (!publication.isSubscribed && typeof publication.setSubscribed === 'function') {
        publication.setSubscribed(true).catch((error) => {
          console.warn('‚ö†Ô∏è Spectator subscription request failed:', error);
        });
      }
      const mediaTrack = buildLiveKitTrackForEvents(publication.track, publication);
      if (!mediaTrack) return;
      if (publication.source === LiveKitTrackSource?.ScreenShare) {
        setupSpectatorScreenShare(mediaTrack);
      } else if (publication.kind === 'video' || publication.source === LiveKitTrackSource?.Camera) {
        setupSpectatorVideo(mediaTrack, participant.sid || participant.identity || participant.participantSid);
      } else if (publication.kind === 'audio' || publication.source === LiveKitTrackSource?.Microphone) {
        setupRemoteAudio(mediaTrack);
      }
    });
  } catch (error) {
    console.error('‚ùå Failed to hydrate spectator tracks:', error);
  }
}

    function hydrateSpectatorTracksFromLiveKit(delay = 0) {
      if (!isSpectator || !livekitRoom) return;
      const hydrate = () => {
        try {
          forEachRemoteLiveKitParticipant((participant) => {
            ensureSpectatorTracksForParticipant(participant);
          });
        } catch (error) {
          console.error('‚ùå Unable to hydrate spectator participants:', error);
        }
      };
      if (delay > 0) {
        setTimeout(hydrate, delay);
      } else {
        hydrate();
      }
    }
  
  // FIXED: Ensure click overlay shows/hides properly based on camera status
  function checkAndHideClickOverlay() {
    const clickOverlay = document.getElementById('spectator-click-overlay');
    if (!clickOverlay) {
      console.error('‚ùå Click overlay element not found!');
      return;
    }
    
    // Count participants with video streams
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    
    // CRITICAL: Check for active videos (cameras ON, not just participants present)
    const hasActiveVideo1 = video1 && video1.srcObject && !video1.classList.contains('hidden') && 
                           video1.style.display !== 'none' && 
                           (!placeholder1 || placeholder1.style.display === 'none');
    const hasActiveVideo2 = video2 && video2.srcObject && !video2.classList.contains('hidden') && 
                           video2.style.display !== 'none' && 
                           (!placeholder2 || placeholder2.style.display === 'none');
    
    console.log(`üé¨ OVERLAY CHECK - ActiveVideo1: ${hasActiveVideo1}, ActiveVideo2: ${hasActiveVideo2}, UserInteracted: ${userHasInteracted}`);
    
    // CRITICAL: Check if participants exist but cameras are off
    const hasParticipants = (spectatorParticipant1 !== null) || (spectatorParticipant2 !== null);
    const camerasOff = hasParticipants && !hasActiveVideo1 && !hasActiveVideo2;
    
    // ONLY hide overlay if user has clicked AND videos are actually playing with cameras on
    if (userHasInteracted && areVideosPlaying() && (hasActiveVideo1 || hasActiveVideo2)) {
      console.log('üé¨ Hiding overlay - user interacted and videos playing with cameras on');
      clickOverlay.classList.remove('spectator-overlay-force-visible');
      clickOverlay.style.display = 'none';
      clickOverlay.style.opacity = '0';
      clickOverlay.style.visibility = 'hidden';
      clickOverlay.style.pointerEvents = 'none';
      return;
    }
    
    // ALWAYS show the overlay if cameras are off OR user hasn't interacted
    console.log('üé¨ FORCING overlay to be visible');
    
    // FORCE the overlay to be visible
    clickOverlay.classList.add('spectator-overlay-force-visible');
    clickOverlay.style.setProperty('display', 'flex', 'important');
    clickOverlay.style.setProperty('opacity', '1', 'important');
    clickOverlay.style.setProperty('visibility', 'visible', 'important');
    clickOverlay.style.setProperty('pointer-events', 'auto', 'important');
    clickOverlay.style.setProperty('z-index', '9999', 'important');
    clickOverlay.classList.remove('hidden');
    
    // Update overlay content based on camera status
    const overlayText = clickOverlay.querySelector('.text-center.text-white');
    if (overlayText) {
      if (camerasOff) {
        // Participants exist but cameras are off
        const participantCount = (spectatorParticipant1 ? 1 : 0) + (spectatorParticipant2 ? 1 : 0);
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path d="M4 6a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM6 8a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1z"/>
              <path d="M2.5 8.5l2-2 2 2M15.5 11.5l-2 2-2-2"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üì∑ Cameras Are Off</p>
          <p class="text-lg text-gold mt-2">${participantCount} participant${participantCount > 1 ? 's' : ''} present, cameras disabled</p>
          <div class="mt-6 px-8 py-4 bg-yellow-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK TO WATCH WHEN CAMERAS TURN ON
          </div>
        `;
      } else if (hasActiveVideo1 || hasActiveVideo2) {
        // Cameras are on - ready to watch
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-green-500 rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-2xl text-white mb-2">üé¨ Ready to Watch!</p>
          <p class="text-lg text-gold mt-2">${hasActiveVideo1 && hasActiveVideo2 ? '2 participants' : '1 participant'} ready for viewing</p>
          <div class="mt-6 px-8 py-4 bg-green-500 rounded-full text-white text-lg font-bold animate-bounce">
            üëÜ CLICK HERE TO START WATCHING
          </div>
        `;
      } else {
        // No participants yet
        overlayText.innerHTML = `
          <div class="w-20 h-20 mx-auto mb-4 bg-main-red rounded-full flex items-center justify-center shadow-lg animate-pulse">
            <svg class="w-10 h-10 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
            </svg>
          </div>
          <p class="font-bold text-xl text-white mb-2">üé¨ Click to Watch Conversation</p>
          <p class="text-sm text-gold mt-2">Tap anywhere to start watching when participants join!</p>
          <div class="mt-4 px-4 py-2 bg-main-red rounded-full text-sm font-bold animate-bounce">
            üëÜ Click Here to Enable Video
          </div>
        `;
      }
    }
    
    console.log('‚úÖ Overlay is now properly configured');
  }
  
  // Check if videos are actually playing (cameras must be on, not just participants present)
  function areVideosPlaying() {
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    
    // SIMPLIFIED: Just check if videos have sources and placeholders are hidden (cameras on)
    // Don't check paused/readyState as these can be unreliable due to autoplay restrictions
    const video1Active = video1 && video1.srcObject && video1.style.display !== 'none' &&
                         (!placeholder1 || placeholder1.style.display === 'none' || placeholder1.classList.contains('hidden'));
    const video2Active = video2 && video2.srcObject && video2.style.display !== 'none' &&
                         (!placeholder2 || placeholder2.style.display === 'none' || placeholder2.classList.contains('hidden'));
    
    console.log(`üé• Video Status Check - Video1: ${video1Active}, Video2: ${video2Active}`);
    
    return video1Active || video2Active;
  }

  function getParticipantName(participantId) {
    const participants = getParticipantsSnapshot();
    for (const [id, participant] of Object.entries(participants)) {
      if (id === participantId) {
        return participant.user_name || 'Participant';
      }
    }
    return 'Participant';
  }

  function removeSpectatorParticipant(participantId) {
    console.log('üóëÔ∏è Removing spectator participant:', participantId);
    
    let participantSlot = null;
    
    // Find which slot this participant was in
    if (spectatorParticipant1 && spectatorParticipant1.participantId === participantId) {
      spectatorParticipant1 = null;
      participantSlot = 1;
    } else if (spectatorParticipant2 && spectatorParticipant2.participantId === participantId) {
      spectatorParticipant2 = null;
      participantSlot = 2;
    } else {
      console.log('‚ö†Ô∏è Participant not found in any slot:', participantId);
      return;
    }
    
    console.log(`üìç Removing participant from slot ${participantSlot}`);
    
    // Get elements for this slot
    const videoElement = document.getElementById(`spectator-participant-${participantSlot}`);
    const placeholder = document.getElementById(`spectator-placeholder-${participantSlot}`);
    const nameElement = document.getElementById(`spectator-name-${participantSlot}`);
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    if (videoElement && placeholder && nameElement) {
      // Hide video and show placeholder
      videoElement.classList.add('hidden');
      videoElement.srcObject = null;
      placeholder.style.display = 'flex';
      nameElement.classList.add('hidden');
      
      console.log(`‚úÖ Cleaned up slot ${participantSlot}`);
    }
    
    // Show click overlay if no participants remain
    if (!spectatorParticipant1 && !spectatorParticipant2) {
      forceSpectatorOverlayVisible('no-participants');
      console.log('üì∫ All participants left, showing click overlay');
    }
  }

  function setupScreenShareVideo(track) {
    console.log('üì∫ setupScreenShareVideo called', {
      hasTrack: !!track,
      trackLabel: track?.label,
      trackReadyState: track?.readyState,
      isSpectator
    });
    
    if (isSpectator) {
      setupSpectatorScreenShare(track);
      return;
    }
    
    screenShareVideo = document.getElementById('screen-share-video');
    const remoteVideoEl = document.getElementById('remote-video');
    
    if (!screenShareVideo) {
      console.error('‚ùå Screen share video element not found!');
      return;
    }
    
    if (!track) {
      console.error('‚ùå setupScreenShareVideo called with no track!');
      return;
    }
    
    try {
      console.log('üì∫ Setting up screen share stream...');
      screenShareVideo.srcObject = new MediaStream([track]);
      screenShareVideo.style.display = 'block';
      screenShareVideo.classList.remove('hidden');
      
      // Hide remote camera video when screen share is active
      if (remoteVideoEl) {
        remoteVideoEl.style.display = 'none';
        console.log('üìπ Remote camera hidden for screen share');
      }
      
      // Safari-specific: force play attempt
      if (isSafari) {
        console.log('üçé Safari: Attempting to play screen share...');
        screenShareVideo.play().then(() => {
          console.log('‚úÖ Safari: Screen share playing successfully');
        }).catch(err => {
          console.warn('‚ö†Ô∏è Safari: Screen share play failed:', err.message);
          showToast('üëÜ Tap screen to view screen share');
        });
      }
      
      console.log('‚úÖ Screen share video set up successfully');
      showToast('üì∫ Screen share started');
    } catch (error) {
      console.error('‚ùå Failed to set up screen share:', error);
    }
  }

  function setupSpectatorScreenShare(track) {
    console.log('üì∫ setupSpectatorScreenShare called', {
      hasTrack: !!track,
      trackLabel: track?.label
    });
    
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const participantsContainer = document.getElementById('spectator-participants-container');
    
    if (!spectatorScreenShare || !participantsContainer) {
      console.error('‚ùå Screen share elements not found for spectator');
      return;
    }
    
    if (!track) {
      console.error('‚ùå setupSpectatorScreenShare called with no track!');
      return;
    }
    
    try {
      console.log('üì∫ Setting up spectator screen share');
      spectatorScreenShare.srcObject = new MediaStream([track]);
      spectatorScreenShare.classList.remove('hidden');
      spectatorScreenShare.style.display = 'block';
      participantsContainer.style.display = 'none';
      hideWaitingOverlay();
      
      // Safari-specific: force play attempt
      if (isSafari) {
        console.log('üçé Safari: Attempting to play spectator screen share...');
        spectatorScreenShare.play().then(() => {
          console.log('‚úÖ Safari: Spectator screen share playing');
        }).catch(err => {
          console.warn('‚ö†Ô∏è Safari: Spectator screen share play failed:', err.message);
        });
      }
      
      // Update expand buttons availability
      updateSpectatorExpandButtons();
      
      console.log('‚úÖ Spectator screen share started');
    } catch (error) {
      console.error('‚ùå Failed to set up spectator screen share:', error);
    }
  }

  function setupRemoteAudio(track) {
    console.log("üîä setupRemoteAudio called", {
      hasTrack: !!track,
      trackKind: track?.kind,
      trackLabel: track?.label,
      trackReadyState: track?.readyState,
      isSafari
    });
    
    if (!track) {
      console.error('‚ùå setupRemoteAudio called with no track!');
      return;
    }
    
    let remoteAudio = document.getElementById('remote-audio');
    if (!remoteAudio) {
      remoteAudio = document.createElement('audio');
      remoteAudio.id = 'remote-audio';
      remoteAudio.autoplay = true;
      remoteAudio.playsInline = true;
      // Safari-specific: muted initially if no user gesture
      if (isSafari && !userGestureReceived) {
        console.log('üçé Safari: Creating audio element muted initially');
        remoteAudio.muted = false; // Still try unmuted, Safari will block if needed
      }
      document.body.appendChild(remoteAudio);
      console.log("üîä Created remote audio element");
    }
    
    try {
      remoteAudio.srcObject = new MediaStream([track]);
      console.log("üîä Remote audio track attached");
      
      remoteAudio.play().then(() => {
        console.log("‚úÖ Remote audio started playing");
      }).catch(err => {
        console.warn("‚ö†Ô∏è Remote audio play failed:", err.message);
        if (isSafari) {
          showToast('üîä Tap screen to enable audio (Safari restriction)');
        } else {
          showToast('üîä Click anywhere to enable audio');
        }
        
        // Set up one-time click handler to retry audio
        const retryAudio = () => {
          if (remoteAudio && remoteAudio.srcObject) {
            remoteAudio.play().then(() => {
              console.log('‚úÖ Audio started after user interaction');
            }).catch(e => console.log('Audio retry failed:', e.message));
          }
          document.removeEventListener('click', retryAudio);
          document.removeEventListener('touchstart', retryAudio);
        };
        document.addEventListener('click', retryAudio, { once: true });
        document.addEventListener('touchstart', retryAudio, { once: true });
      });
    } catch (error) {
      console.error('‚ùå Failed to set up remote audio:', error);
    }
  }

  function hideRemoteVideo() {
    if (isSpectator) {
      hideSpectatorVideo();
      return;
    }
    
    const remoteVideo = document.getElementById('remote-video');
    const placeholder = document.getElementById('remote-placeholder');
    
    remoteVideo.style.display = 'none';
    placeholder.style.display = 'flex';
  }

  function hideSpectatorVideo() {
    // This function is called when screen sharing stops
    // For the new layout, we don't need to do anything here since
    // hideSpectatorScreenShare() handles the screen share cleanup
    console.log('üõë Spectator video track stopped - handled by screen share function');
  }

  function hideScreenShareVideo() {
    console.log('üì∫ hideScreenShareVideo called', { isSpectator });
    
    if (isSpectator) {
      hideSpectatorScreenShare();
      return;
    }
    
    const screenShareVideoEl = document.getElementById('screen-share-video');
    const remoteVideoEl = document.getElementById('remote-video');
    
    if (screenShareVideoEl) {
      console.log('üì∫ Hiding screen share video element');
      screenShareVideoEl.style.display = 'none';
      screenShareVideoEl.classList.add('hidden');
      // Clear the stream to free resources
      if (screenShareVideoEl.srcObject) {
        screenShareVideoEl.srcObject = null;
      }
    }
    
    // Restore remote camera video
    if (remoteVideoEl) {
      console.log('üìπ Restoring remote camera video');
      remoteVideoEl.style.display = 'block';
      remoteVideoEl.classList.remove('hidden');
      
      // If we have a stream, try to play it (Safari may need this)
      if (remoteVideoEl.srcObject && isSafari) {
        remoteVideoEl.play().catch(err => {
          console.log('üìπ Remote video play after screen share end:', err.message);
        });
      }
    }
    
    showToast('üì∫ Screen share ended');
    console.log('‚úÖ Screen share hidden, camera video restored');
  }

  function hideSpectatorScreenShare() {
    console.log('üì∫ hideSpectatorScreenShare called');
    
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const participantsContainer = document.getElementById('spectator-participants-container');
    
    if (!spectatorScreenShare || !participantsContainer) {
      console.error('‚ùå Screen share elements not found when hiding');
      return;
    }
    
    console.log('üì∫ Hiding spectator screen share');
    spectatorScreenShare.classList.add('hidden');
    spectatorScreenShare.style.display = 'none';
    spectatorScreenShare.srcObject = null;
    participantsContainer.style.display = 'grid';
    
    // Ensure participant videos are visible and playing
    restoreSpectatorParticipantVideos();
    
    console.log('‚úÖ Spectator screen share hidden, participants view restored');
  }

  function restoreSpectatorParticipantVideos() {
    console.log('üîÑ Restoring spectator participant videos after screen share');
    console.log('üîÑ Current spectator slots:', {
      slot1: spectatorParticipant1?.participantId,
      slot2: spectatorParticipant2?.participantId
    });
    
    // Restore participant 1 video if it exists
    const video1 = document.getElementById('spectator-participant-1');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    if (video1 && video1.srcObject) {
      video1.classList.remove('hidden');
      video1.style.display = 'block';
      if (placeholder1) placeholder1.style.display = 'none';
      video1.play().then(() => {
        console.log('‚úÖ Participant 1 video now playing');
      }).catch(err => console.log('Video 1 play after restore:', err.message));
      console.log('‚úÖ Restored participant 1 video');
    } else {
      console.log('‚ÑπÔ∏è No video stream for participant 1 slot');
    }
    
    // Restore participant 2 video if it exists
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    if (video2 && video2.srcObject) {
      video2.classList.remove('hidden');
      video2.style.display = 'block';
      if (placeholder2) placeholder2.style.display = 'none';
      video2.play().then(() => {
        console.log('‚úÖ Participant 2 video now playing');
      }).catch(err => console.log('Video 2 play after restore:', err.message));
      console.log('‚úÖ Restored participant 2 video');
    } else {
      console.log('‚ÑπÔ∏è No video stream for participant 2 slot');
    }
    
    // Update overlay based on camera status
    checkAndHideClickOverlay();
  }

  function updateRemoteInfo(name) {
    const remoteNameEl = document.getElementById('remote-name');
    if (remoteNameEl) {
      // Use display name for better UI experience, fallback to username
      const displayName = extractUserDisplayName(name);
      remoteNameEl.textContent = displayName;
    }
  }

  // Helper function to extract and display user names in a UI-friendly way
  function extractUserDisplayName(userName) {
    // If no currentUserData or name is not provided, use name as-is
    if (!userName) return 'Guest';
    
    // For authenticated users, prefer display name over username
    // Check if this is our own name being displayed
    if (window.currentUserData && userName === window.currentUserData.username) {
      return window.currentUserData.displayName || userName;
    }
    
    // For other users, check if they have displayName in their username format
    // This assumes other users also have the same URL parameter structure
    // For now, just clean up the username for better display
    return userName.replace(/^(User_|Viewer_)/, '').replace(/[_-]/g, ' ') || userName;
  }

  // Helper function to get current user's display info
  function getCurrentUserDisplayInfo() {
    if (window.currentUserData && window.currentUserData.isAuthenticated) {
      return {
        displayName: window.currentUserData.displayName,
        username: window.currentUserData.username,
        avatar: window.currentUserData.avatar,
        isAuthenticated: true
      };
    }
    return {
      displayName: userName,
      username: userName,
      avatar: '',
      isAuthenticated: false
    };
  }

  // Update placeholder to show participant with camera off (not disconnected)
  function updateRemotePlaceholderForCameraOff(participant) {
    const placeholder = document.getElementById('remote-placeholder');
    if (!placeholder) return;
    
    const content = placeholder.querySelector('.text-center.text-white.relative.z-10');
    if (!content) return;
    
    const participantName = participant.user_name || 'Guest';
    const displayName = extractUserDisplayName(participantName);
    const firstLetter = displayName.charAt(0).toUpperCase();
    
    // Get avatar URL from participant data or URL parameters
    const avatarUrl = getParticipantAvatarUrl(participant);
    
    content.innerHTML = `
      <div class="w-24 h-24 mx-auto mb-4 bg-gray-600 rounded-full flex items-center justify-center shadow-lg overflow-hidden">
        ${avatarUrl ? 
          `<img src="${avatarUrl}" alt="${displayName}" class="w-full h-full object-cover">` :
          `<span class="text-white font-bold text-2xl">${firstLetter}</span>`
        }
      </div>
      <p class="font-bold text-lg text-white">${displayName}</p>
      <p class="text-sm text-gray-300 mt-1">üì∑ Camera is off</p>
    `;
  }

  // COMPLETELY NEW APPROACH: Replace video element with guaranteed-visible placeholder
  function updateSpectatorPlaceholderForCameraOff(participantId, participant) {
    console.log('üé≠ NEW APPROACH: Creating guaranteed placeholder for camera off:', participantId, participant.user_name);
    
    // Find which slot this participant is in
    let slot = null;
    if (spectatorParticipant1 && spectatorParticipant1.participantId === participantId) {
      slot = 1;
    } else if (spectatorParticipant2 && spectatorParticipant2.participantId === participantId) {
      slot = 2;
    }
    
    console.log(`üìç Found participant in slot: ${slot}`);
    
    if (!slot) {
      console.log('‚ö†Ô∏è No slot found for participant:', participantId);
      return;
    }
    
    const parentContainer = document.getElementById(`spectator-participant-${slot}`).parentElement;
    const nameElement = document.getElementById(`spectator-name-${slot}`);
    
    if (!parentContainer) {
      console.error(`‚ùå Parent container not found for slot ${slot}`);
      return;
    }
    
    const participantName = participant.user_name || 'Guest';
    const displayName = extractUserDisplayName(participantName);
    const firstLetter = displayName.charAt(0).toUpperCase();
    const avatarUrl = getParticipantAvatarUrl(participant);
    
    console.log(`üë§ Creating NEW placeholder element for: ${displayName} (${firstLetter})`);
    
    // STEP 1: Remove the old video and placeholder entirely
    const oldVideo = document.getElementById(`spectator-participant-${slot}`);
    const oldPlaceholder = document.getElementById(`spectator-placeholder-${slot}`);
    
    if (oldVideo) {
      oldVideo.remove();
      console.log(`üóëÔ∏è Removed old video element for slot ${slot}`);
    }
    
    if (oldPlaceholder) {
      oldPlaceholder.remove();
      console.log(`üóëÔ∏è Removed old placeholder element for slot ${slot}`);
    }
    
    // STEP 2: Create a completely new camera-off placeholder element
    const newPlaceholder = document.createElement('div');
    newPlaceholder.id = `spectator-placeholder-${slot}`;
    
    // CRITICAL: Remove ALL classes to prevent Tailwind conflicts
    newPlaceholder.className = '';
    
    // CRITICAL: Set cssText directly to override everything
    newPlaceholder.style.cssText = `
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      background: linear-gradient(135deg, #e63946 0%, #FFD166 100%) !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      z-index: 1000 !important;
      border-radius: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      visibility: visible !important;
      opacity: 1 !important;
    `;
    
    // STEP 3: Add the placeholder content with inline styles for guaranteed visibility
    newPlaceholder.innerHTML = `
      <div style="
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        width: 100% !important;
        height: 100% !important;
        color: white !important;
      ">
        <div style="
          width: 100px !important;
          height: 100px !important;
          margin: 0 auto 16px !important;
          background: rgba(255, 255, 255, 0.2) !important;
          border-radius: 50% !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          overflow: hidden !important;
          border: 4px solid white !important;
          box-shadow: 0 4px 16px rgba(0,0,0,0.3) !important;
        ">
          ${avatarUrl ? 
            `<img src="${avatarUrl}" alt="${displayName}" style="
              width: 100% !important;
              height: 100% !important;
              object-fit: cover !important;
              display: block !important;
            " onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
             <span style="
               color: white !important;
               font-weight: bold !important;
               font-size: 36px !important;
               display: none !important;
               align-items: center !important;
               justify-content: center !important;
               width: 100% !important;
               height: 100% !important;
             ">${firstLetter}</span>` :
            `<span style="
              color: white !important;
              font-weight: bold !important;
              font-size: 36px !important;
              display: flex !important;
              align-items: center !important;
              justify-content: center !important;
              width: 100% !important;
              height: 100% !important;
            ">${firstLetter}</span>`
          }
        </div>
        <p style="
          font-size: 20px !important;
          font-weight: bold !important;
          color: white !important;
          margin: 0 0 8px 0 !important;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.5) !important;
        ">${displayName}</p>
        <p style="
          font-size: 14px !important;
          color: rgba(255,255,255,0.9) !important;
          margin: 0 !important;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.5) !important;
        ">üì∑ Camera is off</p>
      </div>
    `;
    
    // STEP 4: Create a new video placeholder for future use
    const newVideo = document.createElement('video');
    newVideo.id = `spectator-participant-${slot}`;
    newVideo.className = 'w-full h-full object-cover hidden';
    newVideo.autoplay = true;
    newVideo.playsInline = true;
    newVideo.style.cssText = 'display: none !important;';
    
    // STEP 5: Insert both elements into the parent container
    parentContainer.style.position = 'relative';
    parentContainer.appendChild(newVideo);
    parentContainer.appendChild(newPlaceholder);
    
    // STEP 6: Force immediate visibility with DOM manipulation
    // Use display: flex instead of display: none to ensure visibility
    newPlaceholder.style.setProperty('display', 'flex', 'important');
    newPlaceholder.classList.remove('hidden');
    
    // Ensure parent container is visible and has dimensions
    parentContainer.style.setProperty('display', 'block', 'important');
    parentContainer.style.setProperty('position', 'relative', 'important');
    
    // STEP 6: Update name element
    if (nameElement) {
      nameElement.textContent = displayName;
      nameElement.style.display = 'block';
      nameElement.classList.remove('hidden');
    }
    
    console.log(`‚úÖ GUARANTEED VISIBLE: Created new placeholder element for slot ${slot}`);
    console.log(`üéØ Avatar: ${avatarUrl ? 'Using avatar image' : 'Using initial letter: ' + firstLetter}`);
    console.log(`üì¶ Placeholder element:`, newPlaceholder);
    console.log(`üì¶ Placeholder bounding rect:`, newPlaceholder.getBoundingClientRect());
    
    // Force a repaint to ensure the element is visible
    setTimeout(() => {
      newPlaceholder.style.opacity = '1';
      console.log(`üîÑ Forced repaint for slot ${slot} placeholder`);
    }, 10);
  }

  // Get participant avatar URL from various sources
  function getParticipantAvatarUrl(participant) {
    // First check if this is our own participant data
    if (participant.user_name === window.currentUserData?.username) {
      return window.currentUserData.avatar;
    }
    
    // For now, we don't have avatar data from other participants
    // This could be enhanced in the future to pass avatar URLs through Daily.co metadata
    return '';
  }

  // Update local placeholder when you turn off your own camera
  function updateLocalPlaceholderForCameraOff() {
    const placeholder = document.getElementById('local-placeholder');
    if (!placeholder) return;
    
    const content = placeholder.querySelector('.text-center.text-white.relative.z-10');
    if (!content) return;
    
    const userDisplayInfo = getCurrentUserDisplayInfo();
    const displayName = userDisplayInfo.displayName;
    const firstLetter = displayName.charAt(0).toUpperCase();
    const avatarUrl = userDisplayInfo.avatar;
    
    content.innerHTML = `
      <div class="w-16 h-16 mx-auto mb-3 bg-gray-600 rounded-full flex items-center justify-center shadow-lg overflow-hidden">
        ${avatarUrl ? 
          `<img src="${avatarUrl}" alt="${displayName}" class="w-full h-full object-cover">` :
          `<span class="text-white font-bold text-xl">${firstLetter}</span>`
        }
      </div>
      <p class="font-bold text-gold">${displayName}</p>
      <p class="text-sm text-gray-300 mt-1">üì∑ Camera is off</p>
    `;
  }

  function updateSpectatorParticipants() {
    const container = document.getElementById('spectator-participants');
    if (!container) return;
    
    const participants = getParticipantsSnapshot();
    const activeParticipants = Object.values(participants).filter(p => {
      if (p.local) return false;
      return getParticipantRole(p) !== 'spectator';
    });
    
    container.innerHTML = '';
    
    activeParticipants.forEach((participant, index) => {
      const badge = document.createElement('div');
      badge.className = 'bg-main-red text-white px-3 py-1 rounded-full text-sm font-semibold shadow-lg';
      const participantData = getParticipantUserData(participant);
      const displayName = participantData?.displayName || participant.user_name || `Participant ${index + 1}`;
      badge.textContent = displayName;
      container.appendChild(badge);
    });
  }

  // Control functions (only for participants)
    async function toggleMic() {
      if (isSpectator || !livekitRoom?.localParticipant) return;
      
      console.log("üé§ Toggling microphone. Current state:", isMicOn);
      const desiredState = !isMicOn;
      const micBtn = document.getElementById('mic-btn');
      
      try {
        await livekitRoom.localParticipant.setMicrophoneEnabled(desiredState);
        isMicOn = !!livekitRoom.localParticipant.isMicrophoneEnabled;
        
        if (micBtn) {
          micBtn.classList.toggle('active', !isMicOn);
        }
        
        if (isMicOn) {
          showToast('üé§ Microphone on - Speak to test!');
          startAudioLevelMonitoring();
        } else {
          showToast('üîá Microphone muted');
        }
        
        const localParticipant = getParticipantsSnapshot().local;
        if (localParticipant) {
          console.log("üë§ Local participant audio track state:", localParticipant.tracks.audio);
        }
      } catch (error) {
        console.error('‚ùå Failed to toggle microphone:', error);
        showToast('‚ùå Microphone toggle failed');
      }
    }

    async function toggleCamera() {
      if (isSpectator || !livekitRoom?.localParticipant) return;
      
      const desiredState = !isCameraOn;
      const cameraBtn = document.getElementById('camera-btn');
      const localVideoEl = document.getElementById('local-video');
      const placeholder = document.getElementById('local-placeholder');
      
      try {
        await livekitRoom.localParticipant.setCameraEnabled(desiredState);
        isCameraOn = !!livekitRoom.localParticipant.isCameraEnabled;
        
        if (cameraBtn) {
          cameraBtn.classList.toggle('active', !isCameraOn);
        }
        
        if (isCameraOn) {
          if (localVideoEl) localVideoEl.style.display = 'block';
          if (placeholder) placeholder.style.display = 'none';
          showToast('üìπ Camera on');
        } else {
          if (localVideoEl) localVideoEl.style.display = 'none';
          if (placeholder) placeholder.style.display = 'flex';
          updateLocalPlaceholderForCameraOff();
          showToast('üì∑ Camera off');
        }
      } catch (error) {
        console.error('‚ùå Failed to toggle camera:', error);
        showToast('‚ùå Camera toggle failed');
      }
    }

    async function toggleScreenShare() {
      if (isSpectator || !livekitRoom?.localParticipant) return;
      
      const screenShareBtn = document.getElementById('screen-share-btn');
      const localVideo = document.getElementById('local-video');
      
      if (!isScreenSharing) {
        try {
          await livekitRoom.localParticipant.setScreenShareEnabled(true, { audio: true });
          isScreenSharing = true;
          if (screenShareBtn) screenShareBtn.classList.add('active');
          
          if (localVideo) {
            localVideo.classList.add('screen-sharing');
            console.log('üì∫ Removed mirror transform for screen sharing');
          }
          
          showToast('üñ•Ô∏è Screen sharing started');
        } catch (error) {
          console.error('Screen share failed:', error);
          showToast('‚ùå Screen share failed');
        }
      } else {
        try {
          await livekitRoom.localParticipant.setScreenShareEnabled(false);
          isScreenSharing = false;
          if (screenShareBtn) screenShareBtn.classList.remove('active');
          
          if (localVideo) {
            localVideo.classList.remove('screen-sharing');
            console.log('üìπ Restored mirror transform after screen sharing');
          }
          
          showToast('üñ•Ô∏è Screen sharing stopped');
        } catch (error) {
          console.error('Stop screen share failed:', error);
        }
      }
    }

    async function startServerSideRecording(preferences = {}) {
      if (!LIVEKIT_RECORDINGS_ENDPOINT) {
        throw new Error('Recording endpoint not configured. Please set controlApiBaseUrl or recordingsEndpoint.');
      }
      if (!livekitRoomName) {
        throw new Error('LiveKit room name not resolved yet.');
      }
      const response = await fetch(`${LIVEKIT_RECORDINGS_ENDPOINT.replace(/\/$/, '')}/start`, {
        method: 'POST',
        headers: buildControlApiHeaders(),
        body: JSON.stringify({
          roomName: livekitRoomName,
          roomUrl,
          preferences,
          initiatedBy: userId,
          metadata: getLiveKitMetadataPayload(),
          layout: DEFAULT_RECORDING_LAYOUT
        })
      });
      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        throw new Error(`Recording start failed: ${response.status} ${response.statusText} ${errorText}`);
      }
      return response.json();
    }

    async function stopServerSideRecording(activeRecordingId) {
      if (!LIVEKIT_RECORDINGS_ENDPOINT) {
        throw new Error('Recording endpoint not configured.');
      }
      if (!activeRecordingId) {
        throw new Error('Recording ID missing, cannot stop recording.');
      }
      const response = await fetch(`${LIVEKIT_RECORDINGS_ENDPOINT.replace(/\/$/, '')}/stop`, {
        method: 'POST',
        headers: buildControlApiHeaders(),
        body: JSON.stringify({
          recordingId: activeRecordingId,
          roomName: livekitRoomName,
          roomUrl
        })
      });
      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        throw new Error(`Recording stop failed: ${response.status} ${response.statusText} ${errorText}`);
      }
      return response.json();
    }

    async function toggleRecording() {
    console.log('üé¨ toggleRecording called');
    console.log('üé¨ isSpectator:', isSpectator);
    console.log('üé¨ isRecording:', isRecording);
    
    if (isSpectator) {
      console.log('üé¨ Blocked: user is spectator');
      return;
    }
    
    // Check if user has recording permission
    const recordBtn = document.getElementById('record-btn');
    console.log('üé¨ Record button found:', !!recordBtn);
    console.log('üé¨ Record button hidden:', recordBtn?.classList.contains('hidden'));
    
    if (recordBtn && recordBtn.classList.contains('hidden')) {
      // Button is hidden = no permission, but user somehow clicked it
      showToast('‚¨ÜÔ∏è Upgrade to Host Pro or Pro Bundle to record!');
      return;
    }
    
    // Double-check permission via API (in case state is stale)
    try {
      const currentUserId = window.currentUserData?.userId || userId;
      console.log('üé¨ Checking recording permission for user:', currentUserId);
      if (currentUserId && isValidUuid(currentUserId)) {
        const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
        const data = await response.json();
        console.log('üé¨ Subscription data:', data);
        console.log('üé¨ Can record:', data.limits?.canRecord);
        if (!data.limits?.canRecord) {
          showToast('‚¨ÜÔ∏è Upgrade to Host Pro or Pro Bundle to record!');
          hideRecordButton();
          return;
        }
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Could not verify recording permission:', e);
    }
    
    console.log('üé¨ Permission check passed, isRecording:', isRecording);
    
    if (!isRecording) {
      console.log('üé¨ Showing recording consent modal');
      showRecordingConsentModal();
    } else {
      console.log('üé¨ Stopping recording');
      stopRecording();
    }
  }

  function showRecordingConsentModal() {
    console.log('üé¨ showRecordingConsentModal called');
    const modal = document.getElementById('recording-consent-modal');
    if (modal) {
      // Remove hidden class AND force display with inline style
      modal.classList.remove('hidden');
      modal.style.display = 'flex';
      modal.style.visibility = 'visible';
      modal.style.opacity = '1';
      console.log('üé¨ Recording consent modal shown');
      console.log('üé¨ Modal display:', modal.style.display);
      console.log('üé¨ Modal computed display:', window.getComputedStyle(modal).display);
    } else {
      console.error('‚ùå Recording consent modal not found!');
    }
  }

  function cancelRecording() {
    const modal = document.getElementById('recording-consent-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.style.display = 'none';
    }
  }

    async function confirmRecording() {
    const privacy = document.getElementById('recording-privacy').value;
    const autoDelete = document.getElementById('recording-auto-delete').value;
    
    const modal = document.getElementById('recording-consent-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.style.display = 'none';
    }
    
    try {
        const response = await startServerSideRecording({ privacy, autoDelete });
        recordingId = response.recordingId || response.egressId || response.id || `recording_${Date.now()}`;
        handleRecordingStarted({ recordingId });
      
      // Store recording preferences
      window.recordingPreferences = {
        privacy: privacy,
        autoDelete: autoDelete
      };
      
      console.log('üé¨ Recording started with preferences:', window.recordingPreferences);
      
    } catch (error) {
      console.error('‚ùå Failed to start recording:', error);
      showToast('‚ùå Failed to start recording: ' + error.message);
    }
  }

  async function stopRecording() {
    try {
        await stopServerSideRecording(recordingId);
        handleRecordingStopped({ recordingId });
      console.log('üõë Recording stopped');
    } catch (error) {
      console.error('‚ùå Failed to stop recording:', error);
      showToast('‚ùå Failed to stop recording: ' + error.message);
    }
  }

  async function saveRecordingMetadata(event) {
    if (!roomUrl) {
      throw new Error('Room URL missing while saving recording metadata');
    }
    if (!firebaseConfig.databaseURL) {
      throw new Error('Realtime Database URL missing while saving recording metadata');
    }
  
    const roomId = btoa(roomUrl);
    const recordingPath = `recordings/${roomId}/${recordingId}`;
    const recordingEndpoint = await getAuthedRealtimeUrl(firebaseConfig.databaseURL, recordingPath);
    const currentTopic = document.getElementById('topic-display').textContent || 'General Chat';
    const preferences = window.recordingPreferences || { privacy: 'private', autoDelete: 'never' };
    const now = getServerNow();
  
    let existingMetadata = null;
    try {
      const existingResponse = await fetch(recordingEndpoint);
      if (existingResponse.ok) {
        existingMetadata = await existingResponse.json();
        if (existingMetadata?.downloadUrl) {
          console.log('üéØ Recording metadata already finalized. Skipping overwrite.');
          return existingMetadata;
        }
      }
    } catch (lookupError) {
      console.warn('‚ö†Ô∏è Unable to fetch existing recording metadata:', lookupError);
    }

    const recordingData = {
      recordingId,
      roomUrl,
      topic: currentTopic,
      participants: Object.values(getParticipantsSnapshot()).map(p => p.user_name || 'Guest'),
      privacy: preferences.privacy,
      autoDelete: preferences.autoDelete,
      status: 'processing',
      uploadProgress: 0,
      createdAt: existingMetadata?.createdAt || now,
      uploadInitiatedAt: existingMetadata?.uploadInitiatedAt || now,
      downloadUrl: existingMetadata?.downloadUrl || null
    };

    const payloadString = JSON.stringify(recordingData);
    recordingUploadState.pendingPayloadString = payloadString;
    recordingUploadState.pendingEndpoint = recordingEndpoint;
    recordingUploadState.dbPath = recordingPath;

    const method = existingMetadata ? 'PATCH' : 'PUT';
    const response = await fetch(recordingEndpoint, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: payloadString,
      keepalive: true
    });
  
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Failed to save recording metadata: ${response.status} ${response.statusText} ${errorBody}`);
    }
  
    recordingUploadState.pendingPayloadString = null;
    recordingUploadState.progress = 0;
    updateRecordingStatusIndicator('uploading', 0);

    finalizeRecordingUpload('metadata-saved');
    console.log('üíæ Recording metadata saved to Firebase');
  }

  function toggleSettings() {
    if (isSpectator) return;
    
    const settingsPanel = document.getElementById('settings-panel');
    if (settingsPanel.classList.contains('hidden')) {
      settingsPanel.classList.remove('hidden');
    } else {
      settingsPanel.classList.add('hidden');
    }
  }

  async function leaveCall(event) {
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }

    console.log('üëã Leave button clicked');
    console.log('üìä Rating check:', {
      otherParticipantId,
      otherParticipantName,
      isSpectator,
      isGuest: window.currentUserData?.isGuest,
      userId: window.currentUserData?.userId
    });
    
    // Try to get other participant from LiveKit if not already set
    if (!otherParticipantId && livekitRoom) {
      const remoteParticipants = Array.from(livekitRoom.remoteParticipants.values());
      const otherParticipant = remoteParticipants.find(p => getParticipantRole(p) !== 'spectator');
      if (otherParticipant) {
        const participantData = getParticipantUserData(otherParticipant);
        otherParticipantId = participantData?.userId || getParticipantUserId(otherParticipant);
        otherParticipantName = participantData?.displayName || otherParticipant.identity?.split('_').pop() || 'Partner';
        console.log('üìä Found other participant from LiveKit:', otherParticipantId, otherParticipantName);
      }
    }
    
    // IMPORTANT: Show rating modal BEFORE cleanup if there was another participant
    const shouldShowRating = otherParticipantId && 
                             !isSpectator && 
                             window.currentUserData?.userId &&
                             !window.currentUserData?.isGuest;
    
    console.log('üìä Should show rating:', shouldShowRating);
    
    if (shouldShowRating) {
      console.log('üìä Showing rating modal before leaving...');
      
      // Store the rating data before cleanup
      window.pendingLeaveRating = {
        otherUserId: otherParticipantId,
        otherUserName: otherParticipantName
      };
      
      // Show the rating modal
      showRatingModal(otherParticipantId, otherParticipantName);
      
      // Execute cleanup in background but don't reload yet
      // The rating modal close/submit will trigger the reload
      await executeComprehensiveCleanup('leave-button');
      
      // Don't reload - the rating modal will handle it
      return;
    }
    
    // Execute comprehensive cleanup
    await executeComprehensiveCleanup('leave-button');
    
    // Reload page after cleanup
    setTimeout(() => {
      window.location.reload();
    }, 500);
  }

  function cleanup() {
    console.log('üßπ Cleanup triggered');
    executeComprehensiveCleanup('cleanup');
  }

  // Event listeners for controls (only set up for participants)
  if (!isSpectator) {
    console.log('üéõÔ∏è Setting up participant control buttons...');
    document.getElementById('mic-btn').addEventListener('click', toggleMic);
    document.getElementById('camera-btn').addEventListener('click', toggleCamera);
    document.getElementById('screen-share-btn').addEventListener('click', toggleScreenShare);
    
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.addEventListener('click', toggleRecording);
      console.log('üé¨ Record button event listener attached');
    } else {
      console.error('‚ùå Record button not found in DOM!');
    }
    
    document.getElementById('settings-btn').addEventListener('click', toggleSettings);
    document.getElementById('share-btn').addEventListener('click', openShareModal);
    document.getElementById('leave-btn').addEventListener('click', leaveCall);
    document.getElementById('close-settings').addEventListener('click', toggleSettings);
    const copyRecordingLinkBtn = document.getElementById('copy-recording-link');
    if (copyRecordingLinkBtn) {
      copyRecordingLinkBtn.addEventListener('click', copyRecordingDownloadLink);
    }
    console.log('üéõÔ∏è Participant control buttons set up complete');
  } else {
    // Hide participant-only controls for spectators
    const participantContainer = document.getElementById('local-video-container');
    if (participantContainer) {
      participantContainer.style.display = 'none';
    }
  }

  // Device setup functions (only for participants)
  async function requestPermissionsAndSetupDevices() {
    if (isSpectator) return;
    
    try {
      console.log("üîê Requesting media permissions...");
      
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: true, 
        audio: true 
      });
      
      console.log("‚úÖ Permissions granted successfully!");
      console.log("üé§ Audio tracks:", stream.getAudioTracks().length);
      console.log("üìπ Video tracks:", stream.getVideoTracks().length);
      
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length > 0) {
        console.log("üé§ Audio track label:", audioTracks[0].label);
        console.log("üé§ Audio track enabled:", audioTracks[0].enabled);
        console.log("üé§ Audio track ready state:", audioTracks[0].readyState);
      }
      
      stream.getTracks().forEach(track => track.stop());
      setTimeout(setupDeviceSelectors, 1000);
      
    } catch (error) {
      console.error("‚ùå Permission denied or device error:", error);
      
      if (error.name === 'NotAllowedError') {
        showToast('‚ùå Please allow camera and microphone access and reload the page');
      } else if (error.name === 'NotFoundError') {
        showToast('‚ùå No camera or microphone found. Please check your devices.');
      } else {
        showToast('‚ùå Camera/mic permissions needed. Error: ' + error.name);
      }
      
      setTimeout(setupDeviceSelectors, 1000);
    }
  }

    async function setupDeviceSelectors() {
      if (isSpectator) return;
      
      try {
        console.log("üîß Setting up device selectors...");
        
        const allDevices = await navigator.mediaDevices.enumerateDevices();
        console.log("üì± Enumerated devices:", allDevices);

        const cameraSelector = document.getElementById('camera-selector');
        const micSelector = document.getElementById('mic-selector');

        if (!cameraSelector || !micSelector) {
          console.error("‚ùå Settings selectors not found in DOM");
          return;
        }

        cameraSelector.innerHTML = '<option disabled>Select camera...</option>';
        micSelector.innerHTML = '<option disabled>Select microphone...</option>';

        const videoDevices = allDevices.filter(d => d.kind === 'videoinput');
        const audioDevices = allDevices.filter(d => d.kind === 'audioinput');

        if (!selectedCameraDeviceId && videoDevices.length > 0) {
          selectedCameraDeviceId = videoDevices[0].deviceId;
        }
        if (!selectedMicDeviceId && audioDevices.length > 0) {
          selectedMicDeviceId = audioDevices[0].deviceId;
        }
        
        videoDevices.forEach(device => {
          const option = new Option(
            device.label || `Camera ${device.deviceId.slice(0, 8)}...`, 
            device.deviceId
          );
          if (selectedCameraDeviceId === device.deviceId) {
            option.selected = true;
          }
          cameraSelector.appendChild(option);
        });

        audioDevices.forEach(device => {
          const option = new Option(
            device.label || `Microphone ${device.deviceId.slice(0, 8)}...`, 
            device.deviceId
          );
          if (selectedMicDeviceId === device.deviceId) {
            option.selected = true;
          }
          micSelector.appendChild(option);
        });

          cameraSelector.onchange = async (e) => {
          if (e.target.value) {
            console.log("üìπ Changing camera to:", e.target.value);
            try {
              await switchLiveKitDevice('videoinput', e.target.value);
              selectedCameraDeviceId = e.target.value;
              showToast('üìπ Camera changed');
            } catch (error) {
              console.error("‚ùå Camera change failed:", error);
              showToast('‚ùå Camera change failed');
            }
          }
          };

          micSelector.onchange = async (e) => {
          if (e.target.value) {
            console.log("üé§ Changing microphone to:", e.target.value);
            try {
              await switchLiveKitDevice('audioinput', e.target.value);
              selectedMicDeviceId = e.target.value;
              showToast('üé§ Microphone changed');
            } catch (error) {
              console.error("‚ùå Microphone change failed:", error);
              showToast('‚ùå Microphone change failed');
            }
          }
          };

        console.log("‚úÖ Device selectors set up successfully");

      } catch (error) {
        console.error('‚ùå Error setting up device selectors:', error);
        showToast('‚ùå Device settings unavailable');
      }
    }

    // Audio level monitoring for microphone confirmation (participants only)
    let audioLevelObserverActive = false;
    
    function startAudioLevelMonitoring() {
      if (isSpectator || !livekitRoom || audioLevelObserverActive || !LiveKitRoomEvent) return;
      
      console.log("üé§ Starting LiveKit audio level monitoring...");
      audioLevelObserverActive = true;
      livekitRoom.on(LiveKitRoomEvent.ActiveSpeakersChanged, (speakers) => {
        if (!livekitRoom?.localParticipant) return;
        const localSid = livekitRoom.localParticipant.sid;
        if (speakers.some((participant) => participant.sid === localSid)) {
          console.log("‚úÖ MICROPHONE IS WORKING! Local participant detected as active speaker");
        }
      });
    }

  // Timer + account usage helpers
  function getDisplayedMinutesUsedValue() {
    const baseline = typeof accountMinutesBaseline === 'number' ? accountMinutesBaseline : 0;
    return baseline + Math.max(0, latestSessionMinutesUsed);
  }

  function updateMinutesUsedUi() {
    if (isSpectator) return;
    const headerMinutesElement = document.getElementById('minutes-used-header');
    const stickyMinutesElement = document.getElementById('minutes-used-sticky');
    const displayValue = getDisplayedMinutesUsedValue();

    if (headerMinutesElement) {
      headerMinutesElement.textContent = displayValue.toString();
    }
    if (stickyMinutesElement) {
      stickyMinutesElement.textContent = displayValue.toString();
    }
  }

  async function loadParticipantUsageSnapshot(retryCount = 0) {
    if (isSpectator || accountMinutesLoaded) {
      return;
    }
    if (!supabaseClient || !isValidUuid(userId)) {
      if (retryCount < 3) {
        setTimeout(() => loadParticipantUsageSnapshot(retryCount + 1), 1500 * (retryCount + 1));
      } else {
        console.warn('‚ö†Ô∏è Unable to load participant usage snapshot (client or user unavailable).');
      }
      return;
    }

    accountMinutesLoaded = true;
    try {
      const { data, error } = await supabaseClient
        .from('user_stats')
        .select('minutes_used_this_month, minutes_remaining')
        .eq('user_id', userId)
        .limit(1);

      if (error) {
        throw error;
      }

      const row = Array.isArray(data) ? data[0] : data;
      if (row) {
        accountMinutesBaseline = Number(row.minutes_used_this_month) || 0;
        accountMinutesRemaining = row.minutes_remaining !== null && row.minutes_remaining !== undefined
          ? Number(row.minutes_remaining)
          : null;
        console.log('üìä Loaded account minutes snapshot:', {
          minutesUsed: accountMinutesBaseline,
          minutesRemaining: accountMinutesRemaining
        });
        updateMinutesUsedUi();
      } else {
        console.warn('‚ÑπÔ∏è No user_stats row found for user:', userId);
      }
    } catch (error) {
      accountMinutesLoaded = false;
      console.error('‚ùå Failed to load participant usage snapshot:', error);
      if (retryCount < 3) {
        setTimeout(() => loadParticipantUsageSnapshot(retryCount + 1), 2000 * (retryCount + 1));
      }
    }
  }

  // Timer functions
  function configureTimerUiForMode() {
    const headerMinutesWrapper = document.getElementById('minutes-used-header-wrapper');
    const stickyMinutesWrapper = document.getElementById('minutes-used-sticky-wrapper');
    const headerSubtitle = document.getElementById('timer-header-subtitle');
    if (isSpectator) {
      if (headerMinutesWrapper) {
        headerMinutesWrapper.classList.add('hidden');
        headerMinutesWrapper.style.display = 'none';
      }
      if (stickyMinutesWrapper) {
        stickyMinutesWrapper.classList.add('hidden');
        stickyMinutesWrapper.style.display = 'none';
      }
      if (headerSubtitle) {
        headerSubtitle.textContent = 'time remaining';
      }
    } else {
      if (headerMinutesWrapper) {
        headerMinutesWrapper.classList.remove('hidden');
        headerMinutesWrapper.style.display = '';
      }
      if (stickyMinutesWrapper) {
        stickyMinutesWrapper.classList.remove('hidden');
        stickyMinutesWrapper.style.display = '';
      }
      if (headerSubtitle) {
        headerSubtitle.textContent = 'time remaining';
      }
      updateMinutesUsedUi();
    }
  }

  function startTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    timerExpiredHandled = false;
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
  }

  function resetTimerDisplayForSpectator() {
    const timerElement = document.getElementById('timer');
    if (timerElement) {
      timerElement.textContent = '--:--';
    }
    const timerHeaderElement = document.getElementById('timer-header');
    if (timerHeaderElement) {
      timerHeaderElement.textContent = '--:--';
    }
    const headerMinutesElement = document.getElementById('minutes-used-header');
    const stickyMinutesElement = document.getElementById('minutes-used-sticky');
    const headerMinutesWrapper = document.getElementById('minutes-used-header-wrapper');
    const stickyMinutesWrapper = document.getElementById('minutes-used-sticky-wrapper');
    if (headerMinutesElement) {
      headerMinutesElement.textContent = '0';
    }
    if (stickyMinutesElement) {
      stickyMinutesElement.textContent = '0';
    }
    if (headerMinutesWrapper) {
      headerMinutesWrapper.classList.add('hidden');
      headerMinutesWrapper.style.display = 'none';
    }
    if (stickyMinutesWrapper) {
      stickyMinutesWrapper.classList.add('hidden');
      stickyMinutesWrapper.style.display = 'none';
    }
  }

  async function updateTimer() {
    let effectiveTimeRemaining = timeRemaining;

    if (timerState.expiresAt) {
      const remainingMs = timerState.expiresAt - getServerNow();
      effectiveTimeRemaining = Math.max(0, Math.ceil(remainingMs / 1000));
      timeRemaining = effectiveTimeRemaining;
    } else {
      if (timerInterval && timeRemaining > 0) {
        timeRemaining = Math.max(0, timeRemaining - 1);
      }
      effectiveTimeRemaining = timeRemaining;
    }

    const minutes = Math.floor(effectiveTimeRemaining / 60);
    const seconds = effectiveTimeRemaining % 60;
    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    const timerElement = document.getElementById('timer');
    const hasTimerData = typeof timerState.startedAt === 'number' || typeof timerState.expiresAt === 'number';
    if (timerElement) {
      timerElement.textContent = hasTimerData || isSpectator ? timeString : '--:--';
    }

    const timerHeaderElement = document.getElementById('timer-header');
    if (timerHeaderElement) {
      timerHeaderElement.textContent = hasTimerData || isSpectator ? timeString : '--:--';
    }

    // Calculate minutes based on when THIS USER joined, not when room started
    if (!isSpectator && userJoinedAtTimestamp) {
      const now = getServerNow();
      let elapsedSeconds = Math.max(0, Math.floor((now - userJoinedAtTimestamp) / 1000));
      
      // Cap at room's remaining time if timer is set
      if (timerState.expiresAt) {
        const maxSecondsInRoom = Math.max(0, Math.floor((timerState.expiresAt - userJoinedAtTimestamp) / 1000));
        elapsedSeconds = Math.min(elapsedSeconds, maxSecondsInRoom);
      }
      
      latestSessionMinutesUsed = Math.floor(elapsedSeconds / 60);
      updateMinutesUsedUi();
    } else if (!isSpectator) {
      latestSessionMinutesUsed = 0;
      updateMinutesUsedUi();
    }

    if (!timerState.expiresAt) {
      return;
    }

    if (effectiveTimeRemaining > 0) {
      timerExpiredHandled = false;
      return;
    }

    if (timerExpiredHandled) {
      return;
    }

    if (isSpectator) {
      return;
    }

    timerExpiredHandled = true;
    clearInterval(timerInterval);
    
    console.log('‚è∞ Timer expired - showing upgrade modal');
    
    // Show the upgrade modal with grace period instead of immediately reloading
    // This gives users a chance to upgrade or say goodbye
    sessionLimitState.limitReached = true;
    showUpgradeModal();
    
    // Show rating modal too if there was another participant (will show after upgrade modal is closed)
    if (otherParticipantId && !window.currentUserData?.isGuest) {
      window.pendingTimerExpiredRating = {
        otherUserId: otherParticipantId,
        otherUserName: otherParticipantName
      };
    }
  }

  // Sticky timer scroll handler
  window.addEventListener('scroll', function() {
    const stickyTimer = document.getElementById('stickyTimer');
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    if (scrollTop > 200 && !document.getElementById('video-interface').classList.contains('hidden')) {
      stickyTimer.style.opacity = '1';
      stickyTimer.style.transform = 'translateY(0)';
    } else {
      stickyTimer.style.opacity = '0';
      stickyTimer.style.transform = 'translateY(-20px)';
    }
  });

  // Toast function
  function showToast(message) {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    toastMessage.textContent = message;
    toast.classList.remove('hidden', 'translate-y-full');
    
    setTimeout(() => {
      toast.classList.add('translate-y-full');
      setTimeout(() => toast.classList.add('hidden'), 300);
    }, 3000);
  }

  // ============================================
  // SESSION LIMIT FUNCTIONS (Plan-based limits)
  // ============================================
  
  const PLAN_LIMITS = {
    free: 60,           // 60 minutes
    host_pro: 180,      // 3 hours
    ad_free_plus: 60,   // 60 minutes (viewer plan)
    ad_free_premium: 60,// 60 minutes (viewer plan)
    pro_bundle: 180     // 3 hours (has host pro)
  };
  
  const PLAN_NAMES = {
    free: 'Free',
    host_pro: 'Host Pro',
    ad_free_plus: 'Ad-Free Plus',
    ad_free_premium: 'Ad-Free Premium',
    pro_bundle: 'Pro Bundle'
  };
  
  let graceCountdownInterval = null;
  
  async function fetchUserSubscription() {
    // Only check for authenticated users with valid UUID
    if (!userId || !isValidUuid(userId)) {
      console.log('‚è±Ô∏è No valid userId, using free plan limits');
      return { plan: 'free', limitMinutes: 60 };
    }
    
    try {
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${userId}`);
      if (!response.ok) {
        console.warn('‚ö†Ô∏è Failed to fetch subscription, using free plan');
        return { plan: 'free', limitMinutes: 60 };
      }
      
      const data = await response.json();
      const plan = data.plan || 'free';
      const limitMinutes = PLAN_LIMITS[plan] || 60;
      
      console.log(`‚úÖ User plan: ${plan}, limit: ${limitMinutes} minutes`);
      return { plan, limitMinutes };
    } catch (error) {
      console.error('‚ùå Error fetching subscription:', error);
      return { plan: 'free', limitMinutes: 60 };
    }
  }
  
  async function initializeSessionLimits() {
    // Skip for spectators - they don't have time limits
    if (isSpectator) {
      console.log('üëÄ Spectator mode - no session limits');
      return;
    }
    
    const { plan, limitMinutes } = await fetchUserSubscription();
    
    sessionLimitState.userPlan = plan;
    sessionLimitState.limitMinutes = limitMinutes;
    sessionLimitState.sessionStartTime = Date.now();
    sessionLimitState.warningShown80 = false;
    sessionLimitState.warningShown95 = false;
    sessionLimitState.limitReached = false;
    sessionLimitState.graceEndTime = null;
    
    console.log(`‚è±Ô∏è Session limits initialized: ${limitMinutes} min (${plan} plan)`);
    
    // Start checking session limits
    startSessionLimitChecker();
  }
  
  function startSessionLimitChecker() {
    // Check every 10 seconds
    setInterval(checkSessionLimits, 10000);
  }
  
  function checkSessionLimits() {
    if (isSpectator || !sessionLimitState.sessionStartTime) return;
    if (sessionLimitState.limitReached) return; // Already handled
    
    const now = Date.now();
    const elapsedMs = now - sessionLimitState.sessionStartTime;
    const elapsedMinutes = elapsedMs / (1000 * 60);
    const limitMinutes = sessionLimitState.limitMinutes;
    const percentUsed = (elapsedMinutes / limitMinutes) * 100;
    
    // 80% warning
    if (percentUsed >= 80 && percentUsed < 95 && !sessionLimitState.warningShown80) {
      const remainingMinutes = Math.ceil(limitMinutes - elapsedMinutes);
      showToast(`‚è∞ You have ${remainingMinutes} minutes left. Upgrade for more time!`);
      sessionLimitState.warningShown80 = true;
      console.log(`‚ö†Ô∏è 80% warning shown - ${remainingMinutes} min remaining`);
    }
    
    // 95% warning
    if (percentUsed >= 95 && percentUsed < 100 && !sessionLimitState.warningShown95) {
      const remainingMinutes = Math.max(1, Math.ceil(limitMinutes - elapsedMinutes));
      showToast(`‚ö†Ô∏è ${remainingMinutes} minute${remainingMinutes > 1 ? 's' : ''} remaining! Upgrade now to keep chatting`);
      sessionLimitState.warningShown95 = true;
      console.log(`‚ö†Ô∏è 95% warning shown - ${remainingMinutes} min remaining`);
    }
    
    // 100% - show upgrade modal
    if (percentUsed >= 100 && !sessionLimitState.limitReached) {
      sessionLimitState.limitReached = true;
      showUpgradeModal();
    }
  }
  
  function showUpgradeModal() {
    const modal = document.getElementById('upgrade-modal');
    const planSpan = document.getElementById('upgrade-modal-plan');
    const messageEl = document.getElementById('upgrade-modal-message');
    
    if (!modal) return;
    
    // Update modal content based on plan
    const planName = PLAN_NAMES[sessionLimitState.userPlan] || 'Free';
    const limitMinutes = sessionLimitState.limitMinutes;
    
    if (planSpan) planSpan.textContent = planName;
    if (messageEl) {
      messageEl.innerHTML = `
        You've reached the <strong>${limitMinutes}-minute limit</strong> on the ${planName} plan.<br>
        Upgrade to Host Pro for <strong>3 hours</strong> of uninterrupted conversation!
      `;
    }
    
    // Start grace period countdown (60 seconds)
    sessionLimitState.graceEndTime = Date.now() + 60000;
    startGraceCountdown();
    
    // Show modal
    modal.classList.remove('hidden');
    
    console.log('üö® Session limit reached - showing upgrade modal');
  }
  
  function startGraceCountdown() {
    const graceSecondsEl = document.getElementById('grace-seconds');
    
    if (graceCountdownInterval) {
      clearInterval(graceCountdownInterval);
    }
    
    graceCountdownInterval = setInterval(() => {
      if (!sessionLimitState.graceEndTime) {
        clearInterval(graceCountdownInterval);
        return;
      }
      
      const remaining = Math.max(0, Math.ceil((sessionLimitState.graceEndTime - Date.now()) / 1000));
      
      if (graceSecondsEl) {
        graceSecondsEl.textContent = remaining;
      }
      
      if (remaining <= 0) {
        clearInterval(graceCountdownInterval);
        endSessionFromUpgradeModal();
      }
    }, 1000);
  }
  
  async function endSessionFromUpgradeModal() {
    // Clear grace countdown
    if (graceCountdownInterval) {
      clearInterval(graceCountdownInterval);
    }
    
    // Hide modal
    const modal = document.getElementById('upgrade-modal');
    if (modal) modal.classList.add('hidden');
    
    // Execute cleanup
    await executeComprehensiveCleanup('timer-expired');
    
    showToast('üëã Session ended. Upgrade anytime for more time!');
    console.log('üëã Session ended due to time limit');
    
    // Show rating modal if there was another participant
    if (window.pendingTimerExpiredRating && !window.currentUserData?.isGuest) {
      console.log('üìä Showing rating modal after timer expiration...');
      window.pendingLeaveRating = window.pendingTimerExpiredRating;
      window.pendingTimerExpiredRating = null;
      showRatingModal(window.pendingLeaveRating.otherUserId, window.pendingLeaveRating.otherUserName);
      return; // Rating modal close will handle redirect
    }
    
    // Redirect to pricing after a moment
    setTimeout(() => {
      window.location.href = '/pricing.html?session_ended=true';
    }, 2000);
  }
  
  // Make function available globally for onclick
  window.endSessionFromUpgradeModal = endSessionFromUpgradeModal;

  // ============================================
  // RECORDING PERMISSIONS (Plan-based)
  // ============================================
  
  async function initializeRecordingPermissions() {
    // Skip for spectators - they can't record anyway
    if (isSpectator) {
      hideRecordButton();
      return;
    }
    
    try {
      const currentUserId = window.currentUserData?.userId || userId;
      
      // Check if user has a valid UUID (authenticated)
      if (!currentUserId || !isValidUuid(currentUserId)) {
        console.log('üé• Recording: User not authenticated - hiding record button');
        hideRecordButton();
        return;
      }
      
      // Fetch user's subscription to check recording permission
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
      const data = await response.json();
      
      const plan = data.plan || 'free';
      const canRecord = data.limits?.canRecord || false;
      
      console.log(`üé• Recording permission: ${canRecord} (${plan} plan)`);
      
      if (canRecord) {
        showRecordButton();
        console.log('üé• Record button enabled');
      } else {
        hideRecordButton();
        console.log('üé• Record button hidden - upgrade to Host Pro or Pro Bundle to record');
      }
    } catch (error) {
      console.error('‚ùå Error checking recording permissions:', error);
      // Default to hiding on error
      hideRecordButton();
    }
  }
  
  function showRecordButton() {
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.remove('hidden');
      recordBtn.style.display = 'block';
    }
  }
  
  function hideRecordButton() {
    const recordBtn = document.getElementById('record-btn');
    if (recordBtn) {
      recordBtn.classList.add('hidden');
      recordBtn.style.display = 'none';
    }
  }

  // ============================================
  // TIPPING FUNCTIONS (Red Room)
  // ============================================
  
  let roomHostData = {
    hostId: null,
    hostName: null,
    isHost: false
  };
  let selectedTipAmount = 0;
  let userGemBalance = 0;
  
  // Initialize host tracking when joining room
  // Host = the first participant to join (earliest joinedAt timestamp)
  async function initializeHostTracking() {
    console.log('üéØ Initializing host tracking...');
    const sphereId = extractSphereId(roomUrl);
    if (!sphereId) {
      console.warn('‚ö†Ô∏è No sphereId found for host tracking');
      return;
    }
    
    try {
      // Read all presence entries and find the host (earliest participant)
      const presenceRef = db.ref(`presence/${sphereId}`);
      const snapshot = await presenceRef.once('value');
      const users = snapshot.val() || {};
      
      console.log('üë• Presence snapshot:', Object.keys(users).length, 'entries');
      
      // Find all participants (not spectators)
      const participants = Object.entries(users)
        .filter(([key, user]) => user.type === 'participant' && user.status !== 'offline')
        .map(([key, user]) => ({ key, ...user }));
      
      console.log('üë• Found', participants.length, 'active participants');
      
      if (participants.length === 0) {
        // No participants yet - we're likely the first one
        console.log('üëë No other participants - you are the host');
        roomHostData.isHost = true;
        roomHostData.hostId = window.currentUserData?.userId || userId;
        roomHostData.hostName = window.currentUserData?.displayName || userName || 'Host';
        showTipButtonIfNotHost();
        loadMutedUsers(); // Load muted users for host
        showToast('üëë You are the host!');
        return;
      }
      
      // Find the participant with the earliest joinedAt timestamp
      const sortedParticipants = participants.sort((a, b) => {
        const aTime = a.joinedAt || Infinity;
        const bTime = b.joinedAt || Infinity;
        return aTime - bTime;
      });
      
      const hostParticipant = sortedParticipants[0];
      roomHostData.hostId = hostParticipant.userId;
      roomHostData.hostName = hostParticipant.displayName || hostParticipant.name || 'Host';
      
      // Check if current user is the host
      const currentUserId = window.currentUserData?.userId || userId;
      roomHostData.isHost = (hostParticipant.userId === currentUserId);
      
      console.log('üë§ Host determined:', roomHostData.hostName, '| Is you?', roomHostData.isHost);
      
      if (roomHostData.isHost) {
        console.log('üëë You are the host of this room');
        loadMutedUsers(); // Load muted users for host
        showToast('üëë You are the host!');
      } else {
        console.log(`üë§ Host is: ${roomHostData.hostName} (${roomHostData.hostId})`);
      }
      
      // Show tip button for non-hosts
      showTipButtonIfNotHost();
      
      // Listen for presence changes to update host if needed
      listenForHostChanges(sphereId);
      
    } catch (error) {
      console.error('‚ùå Error initializing host tracking:', error);
      // Show tip button anyway - fallback behavior
      roomHostData.isHost = true; // Assume host on error
      showTipButtonIfNotHost();
    }
  }
  
  // Listen for presence changes to dynamically determine host
  function listenForHostChanges(sphereId) {
    const presenceRef = db.ref(`presence/${sphereId}`);
    
    presenceRef.on('value', (snapshot) => {
      const users = snapshot.val() || {};
      
      const participants = Object.entries(users)
        .filter(([key, user]) => user.type === 'participant' && user.status !== 'offline')
        .map(([key, user]) => ({ key, ...user }));
      
      if (participants.length === 0) return;
      
      // Find the earliest participant
      const sortedParticipants = participants.sort((a, b) => {
        const aTime = a.joinedAt || Infinity;
        const bTime = b.joinedAt || Infinity;
        return aTime - bTime;
      });
      
      const hostParticipant = sortedParticipants[0];
      const previousHostId = roomHostData.hostId;
      
      roomHostData.hostId = hostParticipant.userId;
      roomHostData.hostName = hostParticipant.displayName || hostParticipant.name || 'Host';
      
      const currentUserId = window.currentUserData?.userId || userId;
      roomHostData.isHost = (hostParticipant.userId === currentUserId);
      
      // If host changed, update UI
      if (previousHostId !== roomHostData.hostId) {
        console.log(`üîÑ Host updated: ${roomHostData.hostName}`);
        showTipButtonIfNotHost();
      }
    });
  }
  
  async function loadHostFromFirebase() {
    // Same logic as initializeHostTracking - determine host from presence
    await initializeHostTracking();
  }
  
  function showTipButtonIfNotHost() {
    console.log('üíé showTipButtonIfNotHost called');
    const tipBtn = document.getElementById('floating-tip-btn');
    const reportBtn = document.getElementById('floating-report-btn');
    const blockBtn = document.getElementById('floating-block-btn');
    
    if (!tipBtn) {
      console.error('‚ùå Tip button element not found!');
      return;
    }
    
    // Show tip button only if user is NOT the host
    // Hosts cannot tip themselves in production
    const ALLOW_SELF_TIP = false; // Disabled for production
    
    console.log('üíé Is host?', roomHostData.isHost);
    
    if (!roomHostData.isHost || ALLOW_SELF_TIP) {
      tipBtn.classList.remove('hidden');
      tipBtn.style.display = 'block'; // Force visibility
      console.log('üíé Tip button NOW VISIBLE');
    } else {
      tipBtn.classList.add('hidden');
      tipBtn.style.display = 'none';
      console.log('üëë Tip button hidden (you are the host)');
    }
    
    // Update spectator management button visibility (hosts only)
    updateSpectatorManagementButton();
    
    // Always show report/block buttons during calls (for both hosts and non-hosts)
    // But only if there's another participant and user is logged in
    if (!isSpectator && window.currentUserData?.userId && !window.currentUserData.isGuest) {
      if (reportBtn) {
        reportBtn.classList.remove('hidden');
        reportBtn.style.display = 'block';
      }
      if (blockBtn) {
        blockBtn.classList.remove('hidden');
        blockBtn.style.display = 'block';
      }
      console.log('üö© Report/Block buttons NOW VISIBLE');
    }
  }
  
  // Hide floating action buttons (called during cleanup)
  function hideFloatingActionButtons() {
    const tipBtn = document.getElementById('floating-tip-btn');
    const reportBtn = document.getElementById('floating-report-btn');
    const blockBtn = document.getElementById('floating-block-btn');
    
    if (tipBtn) {
      tipBtn.classList.add('hidden');
      tipBtn.style.display = 'none';
    }
    if (reportBtn) {
      reportBtn.classList.add('hidden');
      reportBtn.style.display = 'none';
    }
    if (blockBtn) {
      blockBtn.classList.add('hidden');
      blockBtn.style.display = 'none';
    }
  }
  
  // Animation configuration - all the fun stuff!
  let selectedTipAnimation = 'gems';
  let selectedTipRecipient = null; // { id, name, badge }
  let tippableParticipants = []; // List of signed-in participants who can receive tips
  
  const TIP_ANIMATIONS = {
    // Classic
    gems: { emoji: ['üíé', 'üí†', 'üî∑', 'üîπ'], type: 'rain', sound: 'coin' },
    confetti: { emoji: ['üéâ', 'üéä', '‚ú®', 'üéà', 'üéÅ'], type: 'explode', sound: 'party' },
    money: { emoji: ['üíµ', 'üí∞', 'üí∏', 'ü§ë', 'üí≤'], type: 'rain', sound: 'coin' },
    fire: { emoji: ['üî•', 'üî•', 'üî•', 'üí•', '‚ö°'], type: 'rise', sound: 'whoosh' },
    stars: { emoji: ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üå†'], type: 'float', sound: 'magic' },
    // Animals
    cats: { emoji: ['üê±', 'üò∫', 'üò∏', 'üòª', 'üêà'], type: 'rain', sound: 'meow', useGif: 'cat' },
    dogs: { emoji: ['üêï', 'üê∂', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üê©'], type: 'rain', sound: 'woof', useGif: 'dog' },
    frogs: { emoji: ['üê∏', 'üê∏', 'üê∏', 'üê∏', 'üê∏'], type: 'rain', sound: 'ribbit' },
    butterflies: { emoji: ['ü¶ã', 'ü¶ã', 'ü¶ã', 'üå∏', 'üå∫'], type: 'float', sound: 'magic' },
    unicorn: { emoji: ['ü¶Ñ', 'üåà', '‚ú®', 'üíñ', '‚≠ê'], type: 'float', sound: 'magic' },
    // Food
    pizza: { emoji: ['üçï', 'üçï', 'üçï', 'üßÄ', 'üçÖ'], type: 'rain', sound: 'chomp' },
    tacos: { emoji: ['üåÆ', 'üåØ', 'ü´î', 'üå∂Ô∏è', 'ü•ë'], type: 'rain', sound: 'chomp' },
    // Vibes
    hearts: { emoji: ['üíñ', 'üíï', 'üíó', 'üíì', '‚ù§Ô∏è'], type: 'float', sound: 'love' },
    rocket: { emoji: ['üöÄ'], type: 'rocket', sound: 'whoosh' },
    rainbow: { emoji: ['üåà', 'üåà', 'üåà', '‚ú®', 'ü¶Ñ'], type: 'wave', sound: 'magic' },
    gaming: { emoji: ['üéÆ', 'üëæ', 'üïπÔ∏è', 'üéØ', 'üèÜ'], type: 'rain', sound: 'game' },
    music: { emoji: ['üéµ', 'üé∂', 'üé∏', 'üé§', 'üéß'], type: 'float', sound: 'music' },
    disco: { emoji: ['ü™©', 'üï∫', 'üíÉ', '‚ú®', 'üéµ'], type: 'disco', sound: 'music' },
    skull: { emoji: ['üíÄ', 'üëª', 'üéÉ', 'ü¶á', 'üï∑Ô∏è'], type: 'rain', sound: 'spooky' },
    sparkles: { emoji: ['‚ú®', '‚ú®', '‚ú®', 'üí´', '‚≠ê'], type: 'explode', sound: 'magic' },
    // Nature
    snow: { emoji: ['‚ùÑÔ∏è', '‚ùÑÔ∏è', '‚ùÑÔ∏è', 'üå®Ô∏è', '‚õÑ'], type: 'snow', sound: 'wind' },
    cherry: { emoji: ['üå∏', 'üå∏', 'üå∏', 'üíÆ', 'üèµÔ∏è'], type: 'snow', sound: 'wind' },
    leaves: { emoji: ['üçÇ', 'üçÅ', 'üçÉ', 'üåæ', 'üçÇ'], type: 'snow', sound: 'wind' },
    // Special
    meme: { emoji: ['üòÇ', 'ü§£', 'üíÄ', 'üò≠', 'üî•'], type: 'explode', sound: 'laugh', useGif: 'meme' },
    random: { emoji: [], type: 'random', sound: 'random' }
  };

  // GIF APIs (all FREE! But we add caching + rate limiting for scalability)
  const GIF_APIS = {
    cat: 'https://api.thecatapi.com/v1/images/search?mime_types=gif&limit=10',
    dog: 'https://api.thedogapi.com/v1/images/search?mime_types=gif&limit=10',
    meme: 'https://meme-api.com/gimme'
  };
  
  // GIF Cache for scalability (reduces API calls)
  const GIF_CACHE = {
    cat: [],
    dog: [],
    meme: [],
    lastFetch: { cat: 0, dog: 0, meme: 0 },
    CACHE_DURATION: 5 * 60 * 1000, // 5 minutes cache
    MIN_FETCH_INTERVAL: 10 * 1000, // Min 10 seconds between API calls per type
  };
  
  // Fallback GIFs (static, always available - no API needed)
  const FALLBACK_GIFS = {
    cat: [
      'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
      'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
    ],
    dog: [
      'https://media.giphy.com/media/4Zo41lhzKt6iZ8xff9/giphy.gif',
      'https://media.giphy.com/media/Y4pAQv58ETJgRwoLxj/giphy.gif'
    ],
    meme: [
      'https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif',
      'https://media.giphy.com/media/xT0xeJpnrWC4XWblEk/giphy.gif'
    ]
  };

  async function openTipModal() {
    const modal = document.getElementById('tip-modal');
    if (!modal) return;
    
    // Check if current user is signed in
    const currentUserId = window.currentUserData?.userId || userId;
    if (!currentUserId || !isValidUuid(currentUserId)) {
      showToast('‚ùå Please sign in to send tips!');
      showAuthModal && showAuthModal();
      return;
    }
    
    // Load tippable participants (signed-in users only, excluding self)
    await loadTippableParticipants();
    
    // Check if there's anyone to tip
    if (tippableParticipants.length === 0) {
      showToast('‚ö†Ô∏è No signed-in participants to tip. Guests cannot receive tips.');
      return;
    }
    
    // Reset selection BEFORE populating dropdown
    selectedTipAmount = 0;
    selectedTipAnimation = 'gems';
    selectedTipRecipient = null;
    
    // Populate recipient dropdown (this will auto-select if there's a host or single recipient)
    populateTipRecipientDropdown();
    
    // Load user's gem balance
    await loadUserGemBalanceForTip();
    
    // Update display after everything is set
    updateTipDisplay();
    
    // Reset message input
    const msgInput = document.getElementById('tip-message-input');
    if (msgInput) msgInput.value = '';
    updateTipMessageCount();
    
    // Reset animation picker UI
    document.querySelectorAll('.tip-anim-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.dataset.anim === 'gems') btn.classList.add('selected');
    });
    
    // Show modal
    modal.classList.remove('hidden');
  }
  
  // Get list of participants who can receive tips (signed-in only, excluding self)
  async function loadTippableParticipants() {
    tippableParticipants = [];
    const currentUserId = window.currentUserData?.userId || userId;
    const sphereId = extractSphereId(roomUrl);
    
    if (!sphereId) {
      console.warn('‚ö†Ô∏è No sphereId for loading tippable participants');
      return;
    }
    
    try {
      const presenceRef = db.ref(`presence/${sphereId}`);
      const snapshot = await presenceRef.once('value');
      const users = snapshot.val() || {};
      
      Object.entries(users).forEach(([key, participant]) => {
        if (!participant || participant.status === 'offline') return;
        
        const participantUserId = participant.userId;
        const isSignedIn = participantUserId && isValidUuid(participantUserId);
        const isSelf = participantUserId === currentUserId;
        const isOnline = participant.status !== 'offline';
        
        if (isSignedIn && !isSelf && isOnline) {
          tippableParticipants.push({
            id: participantUserId,
            name: participant.displayName || participant.name || 'User',
            type: participant.type || 'participant',
            isHost: roomHostData.hostId === participantUserId
          });
        }
      });
      
      // Sort: host first, then by name
      tippableParticipants.sort((a, b) => {
        if (a.isHost && !b.isHost) return -1;
        if (!a.isHost && b.isHost) return 1;
        return a.name.localeCompare(b.name);
      });
      
      console.log('üë• Tippable participants:', tippableParticipants);
    } catch (error) {
      console.error('‚ùå Error loading tippable participants:', error);
    }
  }
  
  function populateTipRecipientDropdown() {
    const select = document.getElementById('tip-recipient-select');
    const noRecipientsMsg = document.getElementById('tip-no-recipients');
    
    if (!select) return;
    
    select.innerHTML = '<option value="">-- Select a participant --</option>';
    
    if (tippableParticipants.length === 0) {
      if (noRecipientsMsg) noRecipientsMsg.classList.remove('hidden');
      return;
    }
    
    if (noRecipientsMsg) noRecipientsMsg.classList.add('hidden');
    
    // Add participants as options
    tippableParticipants.forEach((p, index) => {
      const option = document.createElement('option');
      option.value = p.id;
      const badge = p.isHost ? 'üëë ' : (p.type === 'spectator' ? 'üëÄ ' : '');
      const hostLabel = p.isHost ? ' (Host)' : '';
      option.textContent = `${badge}${p.name}${hostLabel}`;
      select.appendChild(option);
      
      // Auto-select if only one option, or select host by default
      if (tippableParticipants.length === 1 || (p.isHost && !selectedTipRecipient)) {
        select.value = p.id;
        selectedTipRecipient = p;
        onTipRecipientChange();
      }
    });
  }
  
  function onTipRecipientChange() {
    const select = document.getElementById('tip-recipient-select');
    const infoEl = document.getElementById('tip-recipient-info');
    const badgeEl = document.getElementById('tip-recipient-badge');
    
    if (!select) return;
    
    const selectedId = select.value;
    selectedTipRecipient = tippableParticipants.find(p => p.id === selectedId) || null;
    
    if (infoEl && badgeEl && selectedTipRecipient) {
      const typeLabel = selectedTipRecipient.isHost ? 'üëë Host' : 
                       (selectedTipRecipient.type === 'spectator' ? 'üëÄ Spectator' : 'üé§ Participant');
      badgeEl.textContent = `Tipping: ${selectedTipRecipient.name} (${typeLabel})`;
      infoEl.classList.remove('hidden');
    } else if (infoEl) {
      infoEl.classList.add('hidden');
    }
    
    updateTipDisplay();
  }
  
  function closeTipModal() {
    const modal = document.getElementById('tip-modal');
    if (modal) modal.classList.add('hidden');
    
    // Reset
    selectedTipAmount = 0;
    selectedTipAnimation = 'gems';
    
    const customInput = document.getElementById('tip-custom-amount');
    if (customInput) customInput.value = '';
    
    const msgInput = document.getElementById('tip-message-input');
    if (msgInput) msgInput.value = '';
    
    const errorEl = document.getElementById('tip-error');
    if (errorEl) errorEl.classList.add('hidden');
  }
  
  async function loadUserGemBalanceForTip() {
    const currentUserId = window.currentUserData?.userId || userId;
    
    if (!currentUserId || !isValidUuid(currentUserId)) {
      userGemBalance = 0;
      updateAllGemBalanceDisplays();
      return;
    }
    
    try {
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
      if (response.ok) {
        const data = await response.json();
        userGemBalance = data.totalGems || 0;
        updateAllGemBalanceDisplays();
      }
    } catch (error) {
      console.error('‚ùå Error loading gem balance for tip:', error);
      userGemBalance = 0;
      updateAllGemBalanceDisplays();
    }
  }
  
  // Update all gem balance displays across the UI
  function updateAllGemBalanceDisplays() {
    const balanceText = `üíé ${userGemBalance.toLocaleString()}`;
    
    // Update all balance displays
    ['tip-your-balance', 'pot-tip-balance', 'spectator-pot-tip-balance'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = balanceText;
    });
  }
  
  function selectTipAmount(amount) {
    const tipAmount = parseInt(amount, 10);
    if (isNaN(tipAmount) || tipAmount < 10) {
      selectedTipAmount = 0;
    } else {
      selectedTipAmount = tipAmount;
    }
    
    // Update custom input to reflect selection
    const customInput = document.getElementById('tip-custom-amount');
    if (customInput && tipAmount >= 10) {
      customInput.value = tipAmount;
    }
    
    updateTipDisplay();
  }
  
  function selectTipAnimation(animType) {
    selectedTipAnimation = animType;
    
    // Update UI
    document.querySelectorAll('.tip-anim-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.dataset.anim === animType) {
        btn.classList.add('selected');
      }
    });
    
    console.log('üé¨ Selected animation:', animType);
  }
  
  function updateTipMessageCount() {
    const input = document.getElementById('tip-message-input');
    const counter = document.getElementById('tip-message-count');
    if (input && counter) {
      counter.textContent = input.value.length;
    }
  }
  
  // Add event listener for message input (handle both cases: DOM ready or already loaded)
  function setupTipMessageListener() {
    const msgInput = document.getElementById('tip-message-input');
    if (msgInput) {
      msgInput.addEventListener('input', updateTipMessageCount);
    }
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupTipMessageListener);
  } else {
    setupTipMessageListener();
  }
  
  function updateTipDisplay() {
    const selectedEl = document.getElementById('tip-selected-amount');
    const hostReceivesEl = document.getElementById('tip-host-receives');
    const sendBtn = document.getElementById('send-tip-btn');
    const errorEl = document.getElementById('tip-error');
    
    if (selectedEl) {
      selectedEl.textContent = `üíé ${selectedTipAmount.toLocaleString()}`;
    }
    
    if (hostReceivesEl) {
      const recipientShare = Math.floor(selectedTipAmount * 0.5);
      const recipientName = selectedTipRecipient?.name || 'recipient';
      hostReceivesEl.textContent = `üíé ${recipientShare.toLocaleString()} to ${recipientName}`;
    }
    
    // Enable/disable send button - must have amount AND recipient selected
    if (sendBtn) {
      const hasRecipient = selectedTipRecipient && selectedTipRecipient.id;
      const canSend = selectedTipAmount >= 10 && selectedTipAmount <= userGemBalance && hasRecipient;
      sendBtn.disabled = !canSend;
      
      // Update button text based on state
      if (!hasRecipient) {
        sendBtn.textContent = 'üë§ Select recipient';
      } else if (selectedTipAmount < 10) {
        sendBtn.textContent = 'üíé Enter amount';
      } else {
        sendBtn.textContent = `üéâ Tip ${selectedTipRecipient.name}`;
      }
    }
    
    // Show error if insufficient balance
    if (errorEl) {
      if (selectedTipAmount > userGemBalance && selectedTipAmount >= 10) {
        errorEl.textContent = `Insufficient gems. You have ${userGemBalance.toLocaleString()}.`;
        errorEl.classList.remove('hidden');
      } else {
        errorEl.classList.add('hidden');
      }
    }
  }
  
  async function sendTip() {
    if (selectedTipAmount < 10) {
      showToast('‚ùå Minimum tip is 10 gems');
      return;
    }
    
    if (selectedTipAmount > userGemBalance) {
      showToast('‚ùå Insufficient gems');
      return;
    }
    
    // Check if user is signed in (required to send tips)
    const currentUserId = window.currentUserData?.userId || userId;
    if (!currentUserId || !isValidUuid(currentUserId)) {
      showToast('‚ùå Please sign in to send tips');
      return;
    }
    
    // Check if recipient is selected
    if (!selectedTipRecipient || !selectedTipRecipient.id) {
      showToast('‚ùå Please select who you want to tip');
      return;
    }
    
    // Validate recipient has valid ID
    if (!isValidUuid(selectedTipRecipient.id)) {
      showToast('‚ùå Selected user cannot receive tips (not signed in)');
      return;
    }
    
    // Save values before modal closes
    const tipAmountToSend = selectedTipAmount;
    const tipAnimation = selectedTipAnimation;
    const tipMessage = document.getElementById('tip-message-input')?.value?.trim() || '';
    const useTTS = document.getElementById('tip-tts-toggle')?.checked ?? true;
    const recipientId = selectedTipRecipient.id;
    const recipientName = selectedTipRecipient.name;
    
    const sendBtn = document.getElementById('send-tip-btn');
    if (sendBtn) {
      sendBtn.textContent = 'üöÄ Sending...';
      sendBtn.disabled = true;
    }
    
    const currentUserName = window.currentUserData?.displayName || userName || 'Someone';
    const sphereId = extractSphereId(roomUrl);
    
    console.log('üíé Sending tip:', { senderId: currentUserId, recipientId, recipientName, amount: tipAmountToSend });
    
    try {
      const response = await fetch('/.netlify/functions/send-tip', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          senderId: currentUserId,
          hostId: recipientId, // Using recipient ID (backend still calls it hostId)
          amount: tipAmountToSend,
          roomId: sphereId,
          senderName: currentUserName
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        closeTipModal();
        
        // Notify everyone via LiveKit (includes animation + message + recipient)
        notifyRoomOfTip(currentUserName, recipientName, tipAmountToSend, tipAnimation, tipMessage, useTTS);
        
        // Update gem display in header
        fetchAndDisplayGemBalance();
        
        // If in Red Room, also update the debate scoreboard with this tip
        if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
          // Find the participant ID that matches this recipient
          const participant = roomTypeState.participants.find(p => 
            p.userId === recipientId || p.name === recipientName
          );
          if (participant) {
            // Update local state - use userId for storage
            const storageKey = participant.userId || participant.id;
            roomTypeState.participantTips = roomTypeState.participantTips || {};
            roomTypeState.participantTips[storageKey] = (roomTypeState.participantTips[storageKey] || 0) + tipAmountToSend;
            updateDebateScoreboard();
            
            // Broadcast via LiveKit to all viewers
            if (livekitRoom && livekitRoom.localParticipant) {
              try {
                const potUpdateMessage = {
                  type: 'pot-update',
                  recipientId: participant.id,
                  recipientUserId: participant.userId, // Include stable userId
                  tipAmount: tipAmountToSend,
                  totalPot: roomTypeState.potTotal || 0,
                  timestamp: Date.now()
                };
                publishLiveKitDataMessage(potUpdateMessage);
                console.log('üìä Debate scoreboard updated with regular tip via LiveKit');
              } catch (err) {
                console.warn('‚ö†Ô∏è Could not broadcast scoreboard update:', err);
              }
            }
          }
        }
        
        console.log(`üí∏ Tip sent: ${tipAmountToSend} gems to ${recipientName} with ${tipAnimation} animation`);
        console.log(`üí∞ ${recipientName} received: ${data.hostReceived} gems | Platform fee: ${data.platformFee} gems`);
      } else {
        throw new Error(data.error || 'Failed to send tip');
      }
    } catch (error) {
      console.error('‚ùå Error sending tip:', error);
      showToast(`‚ùå ${error.message}`);
      
      if (sendBtn) {
        sendBtn.textContent = 'üéâ Send Tip';
        sendBtn.disabled = false;
      }
    }
  }
  
  function notifyRoomOfTip(senderName, recipientName, amount, animation, message, useTTS) {
    console.log('üì§ Sending tip notification via LiveKit...', { senderName, recipientName, amount, animation });
    
    // Create tip data
    const tipData = {
      senderName,
      recipientName: recipientName || 'someone',
      amount,
      animation: animation || 'gems',
      message: message || '',
      useTTS: useTTS !== false,
      timestamp: Date.now()
    };
    
    let sent = false;
    
    // Method 1: Try LiveKit data message (works for all participants, no Firebase permissions needed!)
    if (livekitRoom && livekitRoom.localParticipant) {
      try {
        const tipMessage = {
          type: 'tip-celebration',
          tipData: tipData
        };
        sent = publishLiveKitDataMessage(tipMessage);
        if (sent) {
          console.log('‚úÖ Tip notification sent via LiveKit!');
        }
      } catch (err) {
        console.warn('‚ö†Ô∏è Could not send tip via LiveKit:', err.message);
      }
    }
    
    // Method 2: Fallback to Firebase chat if LiveKit fails
    if (!sent && chatRef) {
      console.log('üì§ Trying Firebase fallback for tip notification...');
      const tipChatMessage = {
        text: `üíé TIP: ${senderName} ‚Üí ${recipientName}: ${amount} gems`,
        sender: 'system',
        senderName: 'TipBot',
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        isTip: true,
        tipData: tipData
      };
      chatRef.push(tipChatMessage).catch(err => {
        console.warn('‚ö†Ô∏è Firebase fallback also failed:', err.message);
      });
    }
    
    if (!sent && !chatRef) {
      console.warn('‚ö†Ô∏è No method available to broadcast tip notification');
    }
    
    // Always play locally for the sender immediately
    playTipCelebration(tipData);
  }
  
  // Keep old function name for backwards compatibility
  function notifyHostOfTip(senderName, amount, animation, message, useTTS) {
    notifyRoomOfTip(senderName, roomHostData.hostName || 'the host', amount, animation, message, useTTS);
  }
  
  function listenForTipNotifications() {
    // Tip notifications are now handled via LiveKit data messages!
    // See handleAppMessage() for the 'tip-celebration' type handler.
    // This function is kept for compatibility but LiveKit is the primary mechanism.
    console.log('üîî Tip notifications enabled via LiveKit data messages');
    console.log('‚úÖ Tip notification system ready');
  }
  
  // ============================================
  // TIP CELEBRATION ANIMATION ENGINE
  // ============================================
  
  // Rate limit tip celebrations to prevent spam/abuse
  let lastTipCelebration = 0;
  const TIP_CELEBRATION_COOLDOWN = 2000; // 2 seconds between celebrations
  let tipCelebrationQueue = [];
  let isProcessingTipQueue = false;
  
  async function playTipCelebration(tip) {
    const now = Date.now();
    
    // Queue the celebration if one is already playing
    if (now - lastTipCelebration < TIP_CELEBRATION_COOLDOWN) {
      tipCelebrationQueue.push(tip);
      if (!isProcessingTipQueue) {
        processNextTipInQueue();
      }
      return;
    }
    
    lastTipCelebration = now;
    await _playTipCelebrationInternal(tip);
  }
  
  function processNextTipInQueue() {
    if (tipCelebrationQueue.length === 0) {
      isProcessingTipQueue = false;
      return;
    }
    
    isProcessingTipQueue = true;
    setTimeout(async () => {
      const nextTip = tipCelebrationQueue.shift();
      if (nextTip) {
        lastTipCelebration = Date.now();
        await _playTipCelebrationInternal(nextTip);
      }
      processNextTipInQueue();
    }, TIP_CELEBRATION_COOLDOWN);
  }
  
  async function _playTipCelebrationInternal(tip) {
    const { senderName, recipientName, amount, animation, message, useTTS } = tip;
    
    // Get animation config (or random if selected)
    let animConfig;
    if (animation === 'random') {
      const keys = Object.keys(TIP_ANIMATIONS).filter(k => k !== 'random');
      const randomKey = keys[Math.floor(Math.random() * keys.length)];
      animConfig = TIP_ANIMATIONS[randomKey];
    } else {
      animConfig = TIP_ANIMATIONS[animation] || TIP_ANIMATIONS.gems;
    }
    
    // Show the overlay
    const overlay = document.getElementById('tip-animation-overlay');
    if (overlay) {
      overlay.style.display = 'block';
    }
    
    // Calculate intensity based on amount
    const intensity = amount >= 500 ? 'mega' : amount >= 100 ? 'high' : amount >= 50 ? 'medium' : 'low';
    const particleCount = intensity === 'mega' ? 150 : intensity === 'high' ? 100 : intensity === 'medium' ? 60 : 30;
    
    // Show announcement (sender ‚Üí recipient)
    showTipAnnouncement(senderName, recipientName, amount, message);
    
    // Shake screen for big tips
    if (intensity === 'mega' || intensity === 'high') {
      document.body.style.animation = 'tipShake 0.5s ease-in-out';
      setTimeout(() => { document.body.style.animation = ''; }, 500);
    }
    
    // Disco mode overlay
    if (animConfig.type === 'disco') {
      const discoOverlay = document.createElement('div');
      discoOverlay.className = 'tip-disco-overlay';
      document.body.appendChild(discoOverlay);
      setTimeout(() => discoOverlay.remove(), 5000);
    }
    
    // Fetch and show GIF if needed
    if (animConfig.useGif) {
      await showTipGif(animConfig.useGif);
    }
    
    // Spawn particles based on animation type
    switch (animConfig.type) {
      case 'rain':
        spawnRainParticles(animConfig.emoji, particleCount);
        break;
      case 'rise':
        spawnRiseParticles(animConfig.emoji, particleCount);
        break;
      case 'explode':
        spawnExplodeParticles(animConfig.emoji, particleCount);
        break;
      case 'float':
        spawnFloatParticles(animConfig.emoji, particleCount);
        break;
      case 'snow':
        spawnSnowParticles(animConfig.emoji, particleCount);
        break;
      case 'rocket':
        spawnRocketAnimation();
        break;
      case 'wave':
        spawnRainbowWave();
        break;
      case 'disco':
        spawnFloatParticles(animConfig.emoji, particleCount);
        break;
      default:
        spawnRainParticles(animConfig.emoji, particleCount);
    }
    
    // Play Text-to-Speech if enabled
    if (useTTS && message) {
      speakTipMessage(senderName, recipientName, amount, message);
    } else if (useTTS) {
      speakTipMessage(senderName, recipientName, amount, '');
    }
    
    // Clean up after animation
    setTimeout(() => {
      hideTipOverlay();
    }, 6000);
  }
  
  function showTipAnnouncement(senderName, recipientName, amount, message) {
    const announcement = document.getElementById('tip-announcement');
    const amountEl = document.getElementById('tip-announcement-amount');
    const senderEl = document.getElementById('tip-announcement-sender');
    const messageEl = document.getElementById('tip-announcement-message');
    
    if (amountEl) amountEl.textContent = `üíé ${amount}`;
    if (senderEl) {
      // Show who tipped who
      if (recipientName) {
        senderEl.textContent = `${senderName} ‚Üí ${recipientName}`;
      } else {
        senderEl.textContent = `${senderName} tipped!`;
      }
    }
    
    if (messageEl) {
      if (message) {
        messageEl.textContent = `"${message}"`;
        messageEl.style.display = 'block';
      } else {
        messageEl.style.display = 'none';
      }
    }
    
    if (announcement) {
      announcement.classList.add('visible');
      
      // Hide after 4 seconds
      setTimeout(() => {
        announcement.classList.remove('visible');
      }, 4000);
    }
  }
  
  // Get a GIF URL with caching, rate limiting, and fallback
  async function getGifUrl(type) {
    const cache = GIF_CACHE;
    const now = Date.now();
    
    // Check if we have cached GIFs that are still fresh
    if (cache[type].length > 0 && (now - cache.lastFetch[type]) < cache.CACHE_DURATION) {
      // Return a random cached GIF and remove it from cache
      const randomIndex = Math.floor(Math.random() * cache[type].length);
      return cache[type].splice(randomIndex, 1)[0];
    }
    
    // Rate limit: don't fetch too frequently
    if ((now - cache.lastFetch[type]) < cache.MIN_FETCH_INTERVAL) {
      // Use fallback instead
      const fallbacks = FALLBACK_GIFS[type] || [];
      if (fallbacks.length > 0) {
        return fallbacks[Math.floor(Math.random() * fallbacks.length)];
      }
      return '';
    }
    
    // Fetch new GIFs
    try {
      cache.lastFetch[type] = now;
      
      if (type === 'cat' || type === 'dog') {
        const res = await fetch(GIF_APIS[type]);
        if (res.ok) {
          const data = await res.json();
          // Cache multiple GIFs for later use
          const urls = data.map(item => item.url).filter(Boolean);
          if (urls.length > 0) {
            cache[type] = urls.slice(1); // Cache all but the first
            return urls[0]; // Return the first one
          }
        }
      } else if (type === 'meme') {
        const res = await fetch(GIF_APIS.meme);
        if (res.ok) {
          const data = await res.json();
          return data?.url || data?.preview?.[data.preview.length - 1] || '';
        }
      }
    } catch (err) {
      console.warn(`GIF API error for ${type}:`, err.message);
    }
    
    // Fallback if API failed
    const fallbacks = FALLBACK_GIFS[type] || [];
    if (fallbacks.length > 0) {
      return fallbacks[Math.floor(Math.random() * fallbacks.length)];
    }
    return '';
  }
  
  async function showTipGif(type) {
    const gifDisplay = document.getElementById('tip-gif-display');
    const gifImage = document.getElementById('tip-gif-image');
    if (!gifDisplay || !gifImage) return;
    
    try {
      const gifUrl = await getGifUrl(type);
      
      if (gifUrl) {
        // Set up load handler before setting src
        gifImage.onload = () => {
          gifDisplay.style.display = 'block';
          gifDisplay.classList.add('visible');
        };
        gifImage.onerror = () => {
          console.warn('GIF failed to load, using fallback');
          // Try fallback on error
          const fallbacks = FALLBACK_GIFS[type] || [];
          if (fallbacks.length > 0) {
            gifImage.src = fallbacks[Math.floor(Math.random() * fallbacks.length)];
          } else {
            gifDisplay.style.display = 'none';
          }
        };
        gifImage.src = gifUrl;
        
        // Hide after 4 seconds
        setTimeout(() => {
          gifDisplay.classList.remove('visible');
          gifDisplay.style.display = 'none';
        }, 4000);
      }
    } catch (err) {
      console.warn('Could not load GIF:', err);
    }
  }
  
  function spawnRainParticles(emojis, count) {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.className = 'tip-particle';
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.top = '-50px';
        particle.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
        particle.style.animation = `tipFall ${2 + Math.random() * 2}s linear forwards`;
        particle.style.animationDelay = Math.random() * 0.5 + 's';
        container.appendChild(particle);
        
        setTimeout(() => particle.remove(), 5000);
      }, i * 30);
    }
  }
  
  function spawnRiseParticles(emojis, count) {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.className = 'tip-particle';
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        particle.style.left = 20 + Math.random() * 60 + 'vw';
        particle.style.bottom = '-50px';
        particle.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
        particle.style.animation = `tipRise ${2 + Math.random() * 2}s linear forwards`;
        container.appendChild(particle);
        
        setTimeout(() => particle.remove(), 5000);
      }, i * 50);
    }
  }
  
  function spawnExplodeParticles(emojis, count) {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    for (let i = 0; i < count; i++) {
      const particle = document.createElement('div');
      particle.className = 'tip-particle';
      particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      particle.style.left = '50%';
      particle.style.top = '50%';
      particle.style.fontSize = (1 + Math.random() * 2) + 'rem';
      
      // Random direction
      const angle = Math.random() * Math.PI * 2;
      const distance = 100 + Math.random() * 300;
      const tx = Math.cos(angle) * distance + 'px';
      const ty = Math.sin(angle) * distance + 'px';
      
      particle.style.setProperty('--tx', tx);
      particle.style.setProperty('--ty', ty);
      particle.style.animation = `tipExplode ${1 + Math.random()}s ease-out forwards`;
      container.appendChild(particle);
      
      setTimeout(() => particle.remove(), 3000);
    }
  }
  
  function spawnFloatParticles(emojis, count) {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.className = 'tip-particle';
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.bottom = '0';
        particle.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
        particle.style.setProperty('--drift', (Math.random() - 0.5) * 100 + 'px');
        particle.style.setProperty('--rot', Math.random() * 360 + 'deg');
        particle.style.animation = `tipFloat ${3 + Math.random() * 2}s ease-out forwards`;
        container.appendChild(particle);
        
        setTimeout(() => particle.remove(), 6000);
      }, i * 40);
    }
  }
  
  function spawnSnowParticles(emojis, count) {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.className = 'tip-particle';
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.top = '-50px';
        particle.style.fontSize = (1 + Math.random() * 1.5) + 'rem';
        particle.style.setProperty('--drift', (Math.random() - 0.5) * 200 + 'px');
        particle.style.animation = `tipSnow ${4 + Math.random() * 3}s linear forwards`;
        container.appendChild(particle);
        
        setTimeout(() => particle.remove(), 8000);
      }, i * 100);
    }
  }
  
  function spawnRocketAnimation() {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    // Main rocket - set initial position
    const rocket = document.createElement('div');
    rocket.className = 'tip-particle';
    rocket.textContent = 'üöÄ';
    rocket.style.fontSize = '4rem';
    rocket.style.left = '0';
    rocket.style.top = '50%';
    rocket.style.animation = 'tipRocket 2s ease-in-out forwards';
    container.appendChild(rocket);
    
    // Trail particles
    for (let i = 0; i < 20; i++) {
      setTimeout(() => {
        const trail = document.createElement('div');
        trail.className = 'tip-particle';
        trail.textContent = ['‚ú®', 'üí´', '‚≠ê'][Math.floor(Math.random() * 3)];
        trail.style.left = Math.random() * 100 + 'vw';
        trail.style.top = 40 + Math.random() * 20 + 'vh';
        trail.style.opacity = '0.7';
        trail.style.animation = 'tipFloat 1s ease-out forwards';
        container.appendChild(trail);
        setTimeout(() => trail.remove(), 2000);
      }, i * 100);
    }
    
    setTimeout(() => rocket.remove(), 3000);
  }
  
  function spawnRainbowWave() {
    const container = document.getElementById('tip-particles-container');
    if (!container) return;
    
    const colors = ['üî¥', 'üü†', 'üü°', 'üü¢', 'üîµ', 'üü£'];
    
    for (let row = 0; row < 6; row++) {
      for (let col = 0; col < 15; col++) {
        setTimeout(() => {
          const particle = document.createElement('div');
          particle.className = 'tip-particle';
          particle.textContent = colors[row];
          particle.style.left = col * 7 + 'vw';
          particle.style.top = 30 + row * 8 + 'vh';
          particle.style.fontSize = '2rem';
          particle.style.opacity = '0';
          particle.style.transition = 'opacity 0.3s ease-in-out';
          container.appendChild(particle);
          
          setTimeout(() => { particle.style.opacity = '1'; }, 50);
          setTimeout(() => { particle.style.opacity = '0'; }, 2000);
          setTimeout(() => particle.remove(), 2500);
        }, row * 100 + col * 50);
      }
    }
  }
  
  function hideTipOverlay() {
    const overlay = document.getElementById('tip-animation-overlay');
    const container = document.getElementById('tip-particles-container');
    const gifDisplay = document.getElementById('tip-gif-display');
    const announcement = document.getElementById('tip-announcement');
    
    if (container) container.innerHTML = '';
    if (gifDisplay) {
      gifDisplay.classList.remove('visible');
      gifDisplay.style.display = 'none';
    }
    if (announcement) announcement.classList.remove('visible');
    if (overlay) overlay.style.display = 'none';
  }
  
  // ============================================
  // TEXT-TO-SPEECH (FREE!)
  // ============================================
  
  function speakTipMessage(senderName, recipientName, amount, message) {
    if (!('speechSynthesis' in window)) {
      console.warn('TTS not supported');
      return;
    }
    
    // Cancel any ongoing speech
    speechSynthesis.cancel();
    
    // Build the message with recipient
    let text;
    if (recipientName) {
      text = `${senderName} tipped ${recipientName} ${amount} gems!`;
    } else {
      text = `${senderName} donated ${amount} gems!`;
    }
    if (message) {
      text += ` They say: ${message}`;
    }
    
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.0;
    utterance.pitch = 1.0;
    utterance.volume = 0.8;
    
    // Try to use a nice voice
    const voices = speechSynthesis.getVoices();
    const preferredVoice = voices.find(v => v.name.includes('Google') || v.name.includes('Natural')) || voices[0];
    if (preferredVoice) utterance.voice = preferredVoice;
    
    speechSynthesis.speak(utterance);
    console.log('üîä TTS:', text);
  }
  
  // Pre-load voices
  if ('speechSynthesis' in window) {
    speechSynthesis.getVoices();
    speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
  }
  
  // Make functions globally available
  window.openTipModal = openTipModal;
  window.closeTipModal = closeTipModal;
  window.selectTipAmount = selectTipAmount;
  window.selectTipAnimation = selectTipAnimation;
  window.onTipRecipientChange = onTipRecipientChange;
  window.sendTip = sendTip;
  window.playTipCelebration = playTipCelebration;

  // ============================================
  // RED ROOM POT SYSTEM
  // ============================================
  
  let roomTypeState = {
    type: 'red', // 'red' for debate, 'green' for help
    potAmount: 0,
    participants: [],
    participantTips: {}, // Track tips per participant {participantId: tipAmount}
    selectedPotRecipient: null,
    votingActive: false,
    hasVoted: false,
    isHost: false,
    debateEnded: false, // For red rooms
    roomEnded: false    // For green rooms
  };
  
  // Initialize room type from URL or Firebase
  async function initializeRoomType() {
    const urlParams = new URLSearchParams(window.location.search);
    let roomType = urlParams.get('roomType');
    const isHost = urlParams.get('host') === 'true';
    
    // If no roomType in URL, try to detect from Firebase (for existing rooms)
    if (!roomType) {
      const sphereId = extractSphereId(roomUrl);
      if (sphereId && db) {
        try {
          const roomInfoRef = db.ref(`chats/${sphereId}/roomInfo`);
          const snapshot = await roomInfoRef.once('value');
          const roomInfo = snapshot.val();
          if (roomInfo?.roomType) {
            roomType = roomInfo.roomType;
            console.log('üîç Detected room type from Firebase:', roomType);
          }
        } catch (e) {
          console.log('‚ö†Ô∏è Could not detect room type from Firebase');
        }
      }
    }
    
    // Default to red room if still not set
    roomType = roomType || 'red';
    roomTypeState.type = roomType;
    roomTypeState.isHost = isHost;
    
    // Save room type AND topic to Firebase so others can detect it
    const sphereId = extractSphereId(roomUrl);
    if (sphereId && db && !isSpectator) {
      try {
        // Get topic from URL or displayed element
        const urlParams = new URLSearchParams(window.location.search);
        let topic = urlParams.get('topic');
        if (topic) {
          topic = decodeURIComponent(topic);
        } else {
          const topicEl = document.getElementById('topic-display');
          if (topicEl && topicEl.textContent && topicEl.textContent !== 'Loading Topic...' && topicEl.textContent !== 'General Chat') {
            topic = topicEl.textContent;
          }
        }
        
        const updateData = {
          roomType: roomType,
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Only add topic if we have one
        if (topic) {
          updateData.topic = topic;
        }
        
        await db.ref(`chats/${sphereId}/roomInfo`).update(updateData);
        console.log('‚úÖ Saved room info to Firebase:', { roomType, topic });
      } catch (e) {
        console.log('‚ö†Ô∏è Could not save room info to Firebase:', e.message);
      }
    }
    
    // Show/hide Red Room pot panel based on room type
    const potPanel = document.getElementById('red-room-pot-panel');
    const spectatorPotPanel = document.getElementById('spectator-red-room-pot-panel');
    const potTipSection = document.getElementById('pot-tip-section');
    const spectatorPotTipSection = document.getElementById('spectator-pot-tip-section');
    
    if (roomType === 'red') {
      // Show appropriate panel based on user type
      if (isSpectator) {
        // Show spectator panel, hide participant panel
        if (spectatorPotPanel) spectatorPotPanel.classList.remove('hidden');
        if (potPanel) potPanel.classList.add('hidden');
        
        // Load gem balance for spectators to tip
        loadUserGemBalanceForTip();
        setTimeout(() => {
          const potBalanceEl = document.getElementById('spectator-pot-tip-balance');
          if (potBalanceEl) potBalanceEl.textContent = `üíé ${userGemBalance.toLocaleString()}`;
        }, 500);
      } else {
        // Show participant panel, hide spectator panel
        if (potPanel) potPanel.classList.remove('hidden');
        if (spectatorPotPanel) spectatorPotPanel.classList.add('hidden');
        
        // Participants can't tip to pot - show message
        const participantMessage = document.getElementById('pot-participant-message');
        if (potTipSection) potTipSection.style.display = 'none';
        if (participantMessage) participantMessage.style.display = 'block';
      }
      
      // Initialize pot targets and listeners
      setTimeout(() => {
        updatePotTargets();
        updateDebateScoreboard();
        listenForPotUpdates();
        // Show End Debate button if user is the host
        showEndDebateButtonIfHost();
      }, 1000);
    } else {
      // Green room - hide all red room panels
      if (potPanel) potPanel.classList.add('hidden');
      if (spectatorPotPanel) spectatorPotPanel.classList.add('hidden');
      
      // Show End Session button if user is the host (for Green Rooms)
      setTimeout(() => {
        showEndDebateButtonIfHost();
      }, 1000);
    }
    
    // Register room with server (only if host or first participant)
    if (isHost || !isSpectator) {
      registerActiveRoom();
    }
    
    // Periodically update room counts (every 30 seconds) to keep live page in sync
    setInterval(() => {
      updateRoomCounts();
    }, 30000);
    
    console.log(`üè† Room type: ${roomType}, isHost: ${isHost}, isSpectator: ${isSpectator}`);
  }
  
  // Register this room as active
  async function registerActiveRoom() {
    const currentUserId = window.currentUserData?.userId || userId;
    const sphereId = extractSphereId(roomUrl);
    
    if (!currentUserId || !sphereId) {
      console.log('‚ö†Ô∏è Cannot register room: missing userId or sphereId');
      return;
    }
    
    try {
      const urlParams = new URLSearchParams(window.location.search);
      // Get topic from URL first, then from displayed topic element, then fallback
      let topic = urlParams.get('topic') || urlParams.get('matchedTopic');
      if (!topic) {
        const topicEl = document.getElementById('topic-display');
        if (topicEl && topicEl.textContent && topicEl.textContent !== 'Loading Topic...') {
          topic = topicEl.textContent;
        } else {
          topic = 'General Discussion';
        }
      }
      
      const response = await fetch('/.netlify/functions/manage-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'create',
          roomId: sphereId,
          hostId: currentUserId,
          hostName: window.currentUserData?.displayName || userName || 'Host',
          hostAvatar: window.currentUserData?.avatar || '',
          roomType: roomTypeState.type,
          topic: decodeURIComponent(topic),
          isPublic: true,
          durationMinutes: sessionLimitState?.limitMinutes || 60
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('üè† Room registered as active:', data);
      } else {
        console.warn('‚ö†Ô∏è Room registration returned non-OK status');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not register room:', error.message);
    }
  }
  
  // Update room participant/spectator counts
  async function updateRoomCounts() {
    const sphereId = extractSphereId(roomUrl);
    if (!sphereId) return;
    
    try {
      // Count participants and spectators from LiveKit room
      let participantCount = 0;
      let spectatorCount = 0;
      
      if (livekitRoom) {
        const remoteParticipants = Array.from(livekitRoom.remoteParticipants?.values() || []);
        
        // Include local participant
        if (!isSpectator) {
          participantCount = 1;
        } else {
          spectatorCount = 1;
        }
        
        // Count remote participants by their role
        for (const p of remoteParticipants) {
          let isRemoteSpectator = false;
          
          // Check metadata for role
          if (p.metadata) {
            try {
              const metadata = JSON.parse(p.metadata);
              if (metadata.role === 'spectator') {
                isRemoteSpectator = true;
              }
            } catch (e) {}
          }
          
          // Also check identity pattern for spectators
          if (!isRemoteSpectator && p.identity) {
            // Spectators have identities like cs_XXXXXX_spectator_... or contain 'spectator'
            if (p.identity.includes('spectator') || p.identity.startsWith('Viewer_')) {
              isRemoteSpectator = true;
            }
          }
          
          if (isRemoteSpectator) {
            spectatorCount++;
          } else {
            participantCount++;
          }
        }
      }
      
      // Use sendBeacon for reliability (works even on page close)
      const payload = JSON.stringify({
        action: 'update-counts',
        roomId: sphereId,
        participantCount,
        spectatorCount
      });
      
      // Try fetch first, fallback to sendBeacon
      try {
        await fetch('/.netlify/functions/manage-room', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: payload
        });
      } catch (fetchError) {
        // Fallback to sendBeacon
        navigator.sendBeacon('/.netlify/functions/manage-room', new Blob([payload], { type: 'application/json' }));
      }
      
      console.log(`üìä Room counts updated: ${participantCount} participants, ${spectatorCount} spectators`);
      
      // Also update local display if we have viewer count elements
      const viewerCountEls = [
        document.getElementById('participant-chat-viewer-count'),
        document.getElementById('spectator-chat-viewer-count')
      ];
      viewerCountEls.forEach(el => {
        if (el) el.textContent = spectatorCount;
      });
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not update room counts:', error.message);
    }
  }
  
  // Update pot display (both participant and spectator panels)
  function updatePotDisplay(amount) {
    roomTypeState.potAmount = amount;
    
    // Update both participant and spectator pot displays
    ['pot-amount-display', 'spectator-pot-amount-display'].forEach(id => {
      const potDisplay = document.getElementById(id);
      if (potDisplay) {
        potDisplay.textContent = `üíé ${amount.toLocaleString()}`;
        
        // Add animation for visual feedback
        potDisplay.classList.add('scale-110');
        potDisplay.style.color = '#ffd166';
        setTimeout(() => {
          potDisplay.classList.remove('scale-110');
          potDisplay.style.color = '';
        }, 500);
      }
    });
    
    updateDebateScoreboard();
  }
  
  // Update pot targets (participants to tip)
  function updatePotTargets() {
    const targetsContainer = document.getElementById('pot-tip-targets');
    
    // Get all participants (exclude spectators)
    const participants = [];
    const localUserId = window.currentUserData?.userId || userId;
    
    if (isSpectator) {
      // SPECTATORS: Get participants from LiveKit room or spectator slots
      const cleanName = (name) => {
        if (!isValidDisplayName(name)) return null;
        return name;
      };
      
      // Helper to extract userId from LiveKit participant by SID
      // Note: remoteParticipants is keyed by identity, not SID, so we iterate
      const getUserIdFromLiveKit = (participantSid) => {
        if (!livekitRoom || !livekitRoom.remoteParticipants) return null;
        
        // First try direct lookup (in case participantSid is actually identity)
        let lkP = livekitRoom.remoteParticipants.get(participantSid);
        
        // If not found, iterate to find by SID
        if (!lkP) {
          for (const [identity, p] of livekitRoom.remoteParticipants) {
            if (p.sid === participantSid) {
              lkP = p;
              break;
            }
          }
        }
        
        if (lkP) {
          const metadata = parseLiveKitMetadata(lkP.metadata);
          const foundUserId = metadata?.userId || metadata?.user_id || null;
          console.log('üîç getUserIdFromLiveKit found userId:', foundUserId, 'for SID:', participantSid);
          return foundUserId;
        }
        console.log('‚ö†Ô∏è getUserIdFromLiveKit could not find participant for SID:', participantSid);
        return null;
      };
      
      if (typeof spectatorParticipant1 !== 'undefined' && spectatorParticipant1) {
        const name = cleanName(spectatorParticipant1.participantName) || 
                     cleanName(spectatorParticipant1.displayName) ||
                     'Debater 1';
        // Get userId from stored value or look it up from LiveKit
        const pUserId = spectatorParticipant1.userId || getUserIdFromLiveKit(spectatorParticipant1.participantId);
        participants.push({
          id: spectatorParticipant1.participantId || 'participant1',
          name: name,
          userId: pUserId
        });
      }
      if (typeof spectatorParticipant2 !== 'undefined' && spectatorParticipant2) {
        const name = cleanName(spectatorParticipant2.participantName) || 
                     cleanName(spectatorParticipant2.displayName) ||
                     'Debater 2';
        // Get userId from stored value or look it up from LiveKit
        const pUserId = spectatorParticipant2.userId || getUserIdFromLiveKit(spectatorParticipant2.participantId);
        participants.push({
          id: spectatorParticipant2.participantId || 'participant2',
          name: name,
          userId: pUserId
        });
      }
      
      // Also try LiveKit room directly if spectator slots not populated
      if (participants.length < 2 && livekitRoom) {
        const remoteParticipants = Array.from(livekitRoom.remoteParticipants?.values() || []);
        for (const p of remoteParticipants) {
          if (p.metadata?.includes('spectator')) continue;
          
          let pName = p.name;
          let pUserId = null;
          try {
            const metadata = parseLiveKitMetadata(p.metadata);
            if (metadata) {
              pUserId = metadata.userId || metadata.user_id || null;
              if (!isValidDisplayName(pName)) {
                pName = metadata.displayName || metadata.name || metadata.username;
              }
            }
          } catch (e) {}
          
          if (!isValidDisplayName(pName)) {
            pName = isValidDisplayName(p.identity) ? p.identity : 'Debater';
          }
          
          const pId = p.sid || p.identity;
          
          if (!participants.find(existing => existing.id === pId || existing.name === pName)) {
            participants.push({ id: pId, name: pName, userId: pUserId });
          }
          
          if (participants.length >= 2) break;
        }
      }
    } else {
      // PARTICIPANTS: Add self and opponent
      if (localUserId) {
        participants.push({
          id: localUserId,
          name: window.currentUserData?.displayName || userName || 'You',
          userId: localUserId // For participants, id IS the userId
        });
      }
      
      if (typeof otherParticipantId !== 'undefined' && otherParticipantId && otherParticipantId !== localUserId) {
        let oppName = otherParticipantName;
        if (!isValidDisplayName(oppName)) {
          oppName = 'Opponent';
        }
        participants.push({
          id: otherParticipantId,
          name: oppName,
          userId: otherParticipantId // For participants, id IS the userId
        });
      }
    }
    
    console.log('üéØ Pot targets updated:', participants.map(p => ({ id: p.id?.substring(0, 15), name: p.name, userId: p.userId?.substring(0, 15) || 'null' })));
    
    roomTypeState.participants = participants;
    
    updateDebateScoreboard();
    
    // Helper function to render targets in a container
    function renderTargets(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      if (participants.length < 2) {
        container.innerHTML = `
          <div class="col-span-2 text-center text-white text-opacity-70 py-2 text-sm">
            ‚è≥ Waiting for debaters to join...
          </div>
        `;
        return;
      }
      
      container.innerHTML = participants.map((p, idx) => {
        // Look up tips by userId (stable UUID) first, then fall back to id (SID)
        const tips = roomTypeState.participantTips[p.userId] || roomTypeState.participantTips[p.id] || 0;
        const isSelected = roomTypeState.selectedPotRecipient === p.id;
        const color = idx === 0 ? 'from-yellow-400 to-yellow-500' : 'from-blue-400 to-blue-500';
        
        return `
          <button 
            onclick="selectPotRecipient('${p.id}')"
            class="p-3 rounded-lg font-bold text-sm transition transform hover:scale-105 ${isSelected ? 'ring-2 ring-white bg-gradient-to-r ' + color + ' text-black' : 'bg-white bg-opacity-20 text-white'}"
          >
            ${isSelected ? '‚úì ' : ''}${p.name}
            <div class="text-xs mt-1">üíé ${tips.toLocaleString()}</div>
          </button>
        `;
      }).join('');
    }
    
    // Render targets in both participant and spectator panels
    renderTargets('pot-tip-targets');
    renderTargets('spectator-pot-tip-targets');
    
    // Auto-select first participant if none selected
    if (!roomTypeState.selectedPotRecipient && participants.length > 0) {
      roomTypeState.selectedPotRecipient = participants[0].id;
      updatePotTargets();
    }
  }
  
  // Re-render just the tip target buttons (without rebuilding participants array)
  // Called after loading tips from Supabase to update displayed amounts
  function rerenderPotTargetButtons() {
    const participants = roomTypeState.participants || [];
    if (participants.length < 2) return;
    
    function renderToContainer(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      container.innerHTML = participants.map((p, idx) => {
        // Look up tips by userId (stable UUID) first, then fall back to id (SID)
        const tips = roomTypeState.participantTips[p.userId] || roomTypeState.participantTips[p.id] || 0;
        const isSelected = roomTypeState.selectedPotRecipient === p.id;
        const color = idx === 0 ? 'from-yellow-400 to-yellow-500' : 'from-blue-400 to-blue-500';
        
        return `
          <button 
            onclick="selectPotRecipient('${p.id}')"
            class="p-3 rounded-lg font-bold text-sm transition transform hover:scale-105 ${isSelected ? 'ring-2 ring-white bg-gradient-to-r ' + color + ' text-black' : 'bg-white bg-opacity-20 text-white'}"
          >
            ${isSelected ? '‚úì ' : ''}${p.name}
            <div class="text-xs mt-1">üíé ${tips.toLocaleString()}</div>
          </button>
        `;
      }).join('');
    }
    
    renderToContainer('pot-tip-targets');
    renderToContainer('spectator-pot-tip-targets');
  }
  
  // Select who to tip in the pot
  function selectPotRecipient(recipientId) {
    roomTypeState.selectedPotRecipient = recipientId;
    updatePotTargets();
    console.log('üéØ Selected pot recipient:', recipientId);
  }
  window.selectPotRecipient = selectPotRecipient;
  
  // Tip to the pot (spectators only)
  async function tipToPot(amount) {
    if (roomTypeState.type !== 'red') {
      showToast('üí° Pot tips are only for Red Room debates');
      return;
    }
    
    if (!isSpectator) {
      showToast('üé§ Participants can\'t tip - you\'re debating!');
      return;
    }
    
    if (!roomTypeState.selectedPotRecipient) {
      showToast('‚ùå Please select who you want to win first');
      return;
    }
    
    const currentUserId = window.currentUserData?.userId || userId;
    if (!currentUserId) {
      showToast('‚ùå Please sign in to tip');
      showAuthModal && showAuthModal();
      return;
    }
    
    if (userGemBalance === 0) {
      await loadUserGemBalanceForTip();
    }
    
    if (amount > userGemBalance) {
      showToast(`‚ùå Insufficient gems (you have ${userGemBalance})`);
      return;
    }
    
    // Find the actual userId for the selected recipient
    // selectedPotRecipient is the 'id' field (LiveKit participant ID for spectators)
    const selectedParticipant = roomTypeState.participants.find(p => p.id === roomTypeState.selectedPotRecipient);
    let recipientUserId = selectedParticipant?.userId;
    
    // If userId not found in stored participant, try to look it up directly from LiveKit
    if (!recipientUserId && livekitRoom && livekitRoom.remoteParticipants) {
      console.log('üîç Attempting direct LiveKit lookup for userId...');
      for (const [identity, p] of livekitRoom.remoteParticipants) {
        if (p.sid === roomTypeState.selectedPotRecipient) {
          const metadata = parseLiveKitMetadata(p.metadata);
          recipientUserId = metadata?.userId || metadata?.user_id;
          console.log('üîç Direct LiveKit lookup found userId:', recipientUserId);
          break;
        }
      }
    }
    
    // Fallback to the selectedPotRecipient if still no userId
    if (!recipientUserId) {
      recipientUserId = roomTypeState.selectedPotRecipient;
    }
    
    if (!recipientUserId) {
      console.error('‚ùå Could not find userId for selected recipient:', roomTypeState.selectedPotRecipient);
      showToast('‚ùå Could not identify the debater. Please try again.');
      return;
    }
    
    console.log('üíé Tip to pot details:', {
      selectedPotRecipient: roomTypeState.selectedPotRecipient,
      resolvedUserId: recipientUserId,
      participantName: selectedParticipant?.name,
      allParticipants: roomTypeState.participants.map(p => ({ id: p.id, name: p.name, userId: p.userId }))
    });
    
    // Validate that we have a proper UUID for recipientUserId
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(recipientUserId)) {
      console.error('‚ùå recipientUserId is not a valid UUID:', recipientUserId);
      console.log('üîç Attempting to refresh pot targets to get userId...');
      // Try refreshing pot targets to get the userId
      updatePotTargets();
      // Try again after refresh
      const refreshedParticipant = roomTypeState.participants.find(p => p.id === roomTypeState.selectedPotRecipient);
      if (refreshedParticipant?.userId && uuidRegex.test(refreshedParticipant.userId)) {
        recipientUserId = refreshedParticipant.userId;
        console.log('‚úÖ Got userId after refresh:', recipientUserId);
      } else {
        showToast('‚ùå Could not identify the debater. Please wait for them to fully connect.');
        return;
      }
    }
    
    const sphereId = extractSphereId(roomUrl);
    const currentUserName = window.currentUserData?.displayName || userName || 'Someone';
    
    try {
      const response = await fetch('/.netlify/functions/tip-to-pot', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          senderId: currentUserId,
          recipientId: recipientUserId,
          amount: amount,
          roomId: sphereId,
          senderName: currentUserName
        })
      });
      
      const data = await response.json();
      console.log('üíé Tip to pot response:', { status: response.status, data });
      
      if (data.success) {
        updatePotDisplay(data.potTotal);
        showToast(`üíé Added ${amount} gems to the pot!`);
        
        fetchAndDisplayGemBalance();
        broadcastPotUpdate(amount, data.potTotal);
        
        console.log(`üî¥ Pot tip: ${amount} gems, total pot: ${data.potTotal}`);
      } else {
        throw new Error(data.error || 'Failed to add to pot');
      }
    } catch (error) {
      console.error('‚ùå Error tipping to pot:', error);
      showToast(`‚ùå ${error.message}`);
    }
  }
  window.tipToPot = tipToPot;
  
  // Broadcast pot update to all viewers via LiveKit
  function broadcastPotUpdate(tipAmount, totalPot) {
    const recipientId = roomTypeState.selectedPotRecipient;
    
    // Find the recipient's stable userId
    const recipient = roomTypeState.participants.find(p => p.id === recipientId);
    const recipientUserId = recipient?.userId;
    
    // Update local state immediately - use userId for storage
    const storageKey = recipientUserId || recipientId;
    if (storageKey) {
      roomTypeState.participantTips[storageKey] = (roomTypeState.participantTips[storageKey] || 0) + tipAmount;
    }
    roomTypeState.potTotal = totalPot;
    updatePotDisplay(totalPot);
    updateDebateScoreboard();
    
    // Broadcast via LiveKit to all other viewers
    if (livekitRoom && livekitRoom.localParticipant) {
      try {
        const potUpdateMessage = {
          type: 'pot-update',
          recipientId: recipientId,
          recipientUserId: recipientUserId, // Include stable userId for cross-session compatibility
          tipAmount: tipAmount,
          totalPot: totalPot,
          timestamp: Date.now()
        };
        const sent = publishLiveKitDataMessage(potUpdateMessage);
        if (sent) {
          console.log('‚úÖ Pot update broadcast via LiveKit!');
        }
      } catch (err) {
        console.warn('Could not broadcast pot update via LiveKit:', err);
      }
    }
  }
  
  // Listen for pot updates (via LiveKit data messages)
  function listenForPotUpdates() {
    if (roomTypeState.type !== 'red') return;
    
    // Initialize pot state
    roomTypeState.participantTips = roomTypeState.participantTips || {};
    roomTypeState.potTotal = roomTypeState.potTotal || 0;
    
    // Load initial pot state from Supabase
    loadPotStateFromSupabase();
    
    // Pot updates are received via LiveKit data messages
    // See handleAppMessage() for the 'pot-update' type handler
    console.log('üî¥ Listening for pot updates via LiveKit');
  }
  
  // Load pot state from Supabase on page load
  // Uses get_pot_breakdown RPC function which bypasses RLS to show ALL pot transactions
  async function loadPotStateFromSupabase() {
    const sphereId = extractSphereId(roomUrl);
    if (!sphereId) return;
    
    try {
      // Use RPC function that bypasses RLS to get full pot breakdown
      // This ensures ALL users see the same data (not just their own transactions)
      const { data: breakdown, error: rpcError } = await supabaseClient
        .rpc('get_pot_breakdown', { p_room_id: sphereId });
      
      if (rpcError) {
        console.warn('‚ö†Ô∏è Could not load pot breakdown via RPC, falling back to direct query:', rpcError.message);
        // Fallback to direct query (may be restricted by RLS)
        await loadPotStateFromSupabaseFallback(sphereId);
        return;
      }
      
      if (breakdown && breakdown.length > 0) {
        // Build tips by recipient from RPC response
        const tipsByUser = {};
        let totalPot = 0;
        
        breakdown.forEach(row => {
          tipsByUser[row.recipient_id] = parseInt(row.total_amount, 10) || 0;
          totalPot += tipsByUser[row.recipient_id];
        });
        
        // Store tips by userId (not participantId)
        roomTypeState.participantTips = tipsByUser;
        roomTypeState.potTotal = totalPot;
        
        console.log('üíæ Loaded pot state from Supabase (RPC):', { tipsByUser, totalPot });
        
        updatePotDisplay(totalPot);
        updateDebateScoreboard();
        
        // Re-render the tip target buttons with updated tip amounts
        rerenderPotTargetButtons();
      } else {
        // No transactions found, but still update displays to show 0
        roomTypeState.participantTips = roomTypeState.participantTips || {};
        roomTypeState.potTotal = roomTypeState.potTotal || 0;
        updatePotDisplay(roomTypeState.potTotal);
        updateDebateScoreboard();
        rerenderPotTargetButtons();
        console.log('üíæ No pot transactions found for room:', sphereId);
      }
    } catch (err) {
      console.warn('‚ö†Ô∏è Error loading pot state:', err);
    }
  }
  
  // Fallback function if RPC is not available (e.g., function not yet deployed)
  async function loadPotStateFromSupabaseFallback(sphereId) {
    try {
      const { data: transactions, error } = await supabaseClient
        .from('pot_transactions')
        .select('recipient_id, amount')
        .eq('room_id', sphereId)
        .eq('status', 'held');
      
      if (error) {
        console.warn('‚ö†Ô∏è Fallback query also failed:', error.message);
        return;
      }
      
      if (transactions && transactions.length > 0) {
        const tipsByUser = {};
        let totalPot = 0;
        
        transactions.forEach(tx => {
          tipsByUser[tx.recipient_id] = (tipsByUser[tx.recipient_id] || 0) + tx.amount;
          totalPot += tx.amount;
        });
        
        roomTypeState.participantTips = tipsByUser;
        roomTypeState.potTotal = totalPot;
        
        console.log('üíæ Loaded pot state from Supabase (fallback):', { tipsByUser, totalPot });
        
        updatePotDisplay(totalPot);
        updateDebateScoreboard();
        rerenderPotTargetButtons();
      } else {
        roomTypeState.participantTips = roomTypeState.participantTips || {};
        roomTypeState.potTotal = roomTypeState.potTotal || 0;
        updatePotDisplay(roomTypeState.potTotal);
        updateDebateScoreboard();
        rerenderPotTargetButtons();
      }
    } catch (err) {
      console.warn('‚ö†Ô∏è Error in fallback pot state load:', err);
    }
  }
  
  // Handle incoming pot update from LiveKit
  function handlePotUpdate(data) {
    console.log('üî¥ Pot update received:', data);
    
    // Use recipientUserId (stable UUID) for storage, fallback to recipientId
    const recipientKey = data.recipientUserId || data.recipientId;
    
    if (recipientKey) {
      roomTypeState.participantTips[recipientKey] = (roomTypeState.participantTips[recipientKey] || 0) + data.tipAmount;
    }
    if (data.totalPot !== undefined) {
      roomTypeState.potTotal = data.totalPot;
      updatePotDisplay(data.totalPot);
    }
    updateDebateScoreboard();
    // Also update the tip target buttons to show new amounts
    rerenderPotTargetButtons();
  }
  
  // Update the debate scoreboard (both participant and spectator panels)
  function updateDebateScoreboard() {
    const participants = roomTypeState.participants;
    const tips = roomTypeState.participantTips;
    
    const debater1 = participants[0];
    const debater2 = participants[1];
    
    // Look up tips by userId (stable UUID) OR participantId (session SID) for backwards compatibility
    const tips1 = debater1 ? (tips[debater1.userId] || tips[debater1.id] || 0) : 0;
    const tips2 = debater2 ? (tips[debater2.userId] || tips[debater2.id] || 0) : 0;
    const totalTips = tips1 + tips2 || 1;
    
    // Helper function to update a panel's scoreboard
    function updatePanel(prefix) {
      const name1El = document.getElementById(prefix + 'debater-1-name');
      const tips1El = document.getElementById(prefix + 'debater-1-tips');
      const bar1El = document.getElementById(prefix + 'debater-1-bar');
      const crown1El = document.getElementById(prefix + 'debater-1-crown');
      
      const name2El = document.getElementById(prefix + 'debater-2-name');
      const tips2El = document.getElementById(prefix + 'debater-2-tips');
      const bar2El = document.getElementById(prefix + 'debater-2-bar');
      const crown2El = document.getElementById(prefix + 'debater-2-crown');
      
      if (name1El) name1El.textContent = debater1?.name || 'Waiting...';
      if (tips1El) tips1El.textContent = `üíé ${tips1.toLocaleString()}`;
      if (bar1El) bar1El.style.width = `${(tips1 / totalTips) * 100}%`;
      if (crown1El) crown1El.style.display = tips1 > tips2 && tips1 > 0 ? 'inline' : 'none';
      
      if (name2El) name2El.textContent = debater2?.name || 'Waiting...';
      if (tips2El) tips2El.textContent = `üíé ${tips2.toLocaleString()}`;
      if (bar2El) bar2El.style.width = `${(tips2 / totalTips) * 100}%`;
      if (crown2El) crown2El.style.display = tips2 > tips1 && tips2 > 0 ? 'inline' : 'none';
      
      if (tips1 > tips2 && tips1 > 0 && bar1El) {
        bar1El.classList.add('animate-pulse');
        setTimeout(() => bar1El.classList.remove('animate-pulse'), 2000);
      }
      if (tips2 > tips1 && tips2 > 0 && bar2El) {
        bar2El.classList.add('animate-pulse');
        setTimeout(() => bar2El.classList.remove('animate-pulse'), 2000);
      }
    }
    
    // Update both participant and spectator panels
    updatePanel(''); // Participant panel (debater-1-name, etc.)
    updatePanel('spectator-'); // Spectator panel (spectator-debater-1-name, etc.)
  }
  
  // ============================================
  // END DEBATE FUNCTIONS (Host Only)
  // ============================================
  
  // Show the End Debate button to the host
  function showEndDebateButtonIfHost() {
    const endDebateSection = document.getElementById('end-debate-section');
    const endSessionSection = document.getElementById('end-session-section');
    
    const urlParams = new URLSearchParams(window.location.search);
    const isHost = urlParams.get('host') === 'true';
    
    // Red Room - show End Debate button
    if (roomTypeState.type === 'red' && endDebateSection) {
      if (isHost && !isSpectator) {
        endDebateSection.classList.remove('hidden');
        console.log('üèÅ End Debate button shown (you are the host)');
      }
    }
    
    // Green Room - show End Session button
    if (roomTypeState.type === 'green' && endSessionSection) {
      if (isHost && !isSpectator) {
        endSessionSection.classList.remove('hidden');
        console.log('üü¢ End Session button shown (you are the host)');
      }
    }
  }
  
  // Confirm and end green room
  function confirmEndGreenRoom() {
    if (confirm('Are you sure you want to end this help session? All participants will be notified.')) {
      endGreenRoom();
    }
  }
  
  // Show confirmation modal before ending debate
  function showEndDebateConfirm() {
    const modal = document.getElementById('end-debate-modal');
    const confirmView = document.getElementById('end-debate-confirm');
    const loadingView = document.getElementById('end-debate-loading');
    const resultsView = document.getElementById('end-debate-results');
    const potStatus = document.getElementById('end-debate-pot-status');
    const voidWarning = document.getElementById('end-debate-void-warning');
    
    // Reset views
    confirmView.classList.remove('hidden');
    loadingView.classList.add('hidden');
    resultsView.classList.add('hidden');
    
    // Show current pot status
    const currentPot = roomTypeState.potTotal || 0;
    potStatus.textContent = `üíé ${currentPot.toLocaleString()}`;
    
    // Show void warning if under 100 gems
    if (currentPot < 100) {
      voidWarning.classList.remove('hidden');
    } else {
      voidWarning.classList.add('hidden');
    }
    
    modal.classList.remove('hidden');
  }
  window.showEndDebateConfirm = showEndDebateConfirm;
  
  // Hide the End Debate modal
  function hideEndDebateModal() {
    const modal = document.getElementById('end-debate-modal');
    if (modal) modal.classList.add('hidden');
  }
  window.hideEndDebateModal = hideEndDebateModal;
  
  // Actually end the debate (call API)
  async function confirmEndDebate() {
    const confirmView = document.getElementById('end-debate-confirm');
    const loadingView = document.getElementById('end-debate-loading');
    const resultsView = document.getElementById('end-debate-results');
    const confirmBtn = document.getElementById('confirm-end-debate-btn');
    
    // Show loading
    confirmView.classList.add('hidden');
    loadingView.classList.remove('hidden');
    confirmBtn.disabled = true;
    
    const sphereId = extractSphereId(roomUrl);
    const hostId = window.currentUserData?.userId || userId;
    
    try {
      const response = await fetch('/.netlify/functions/end-red-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: sphereId,
          hostId: hostId
        })
      });
      
      const data = await response.json();
      console.log('üèÅ End debate response:', data);
      
      // Show results
      loadingView.classList.add('hidden');
      resultsView.classList.remove('hidden');
      
      const resultIcon = document.getElementById('end-debate-result-icon');
      const resultTitle = document.getElementById('end-debate-result-title');
      const resultDetails = document.getElementById('end-debate-result-details');
      
      if (data.success) {
        if (data.result === 'void') {
          // Pot was voided (under 100 gems)
          resultIcon.textContent = 'üîÑ';
          resultTitle.textContent = 'Debate Voided';
          resultDetails.innerHTML = `
            <div class="text-yellow-300 font-bold mb-2">Pot was under 100 gems</div>
            <div class="text-white text-sm">All ${data.totalPot || 0} gems have been refunded to their senders.</div>
          `;
        } else if (data.result === 'draw') {
          // It's a draw
          resultIcon.textContent = 'ü§ù';
          resultTitle.textContent = 'It\'s a Draw!';
          resultDetails.innerHTML = `
            <div class="text-blue-300 font-bold mb-2">Tips were equal</div>
            <div class="text-white text-sm">Total pot: üíé ${data.totalPot?.toLocaleString() || 0}</div>
            <div class="text-gray-300 text-xs mt-2">Each debater keeps their respective tips.</div>
          `;
        } else {
          // We have a winner!
          const winnerName = data.winnerName || 'Winner';
          const winnerAmount = data.winnerAmount || 0;
          resultIcon.textContent = 'üèÜ';
          resultTitle.textContent = `${winnerName} Wins!`;
          resultDetails.innerHTML = `
            <div class="text-green-300 font-bold mb-2">Winner takes the pot!</div>
            <div class="text-white text-lg mb-2">üíé ${winnerAmount.toLocaleString()} credited</div>
            <div class="text-gray-300 text-sm">Total pot was: üíé ${data.totalPot?.toLocaleString() || 0}</div>
            <div class="text-xs text-gray-400 mt-2">(50% winner share + platform fee deducted)</div>
          `;
        }
        
        // Broadcast to other users that debate ended
        broadcastDebateEnded(data);
        
      } else {
        // Error occurred
        resultIcon.textContent = '‚ùå';
        resultTitle.textContent = 'Error';
        resultDetails.innerHTML = `
          <div class="text-red-300 font-bold mb-2">Could not end debate</div>
          <div class="text-white text-sm">${data.error || 'Unknown error'}</div>
        `;
      }
      
    } catch (error) {
      console.error('‚ùå Error ending debate:', error);
      loadingView.classList.add('hidden');
      resultsView.classList.remove('hidden');
      
      document.getElementById('end-debate-result-icon').textContent = '‚ùå';
      document.getElementById('end-debate-result-title').textContent = 'Error';
      document.getElementById('end-debate-result-details').innerHTML = `
        <div class="text-red-300">${error.message}</div>
      `;
    }
  }
  window.confirmEndDebate = confirmEndDebate;
  
  // Close modal and optionally leave the room
  function closeEndDebateAndLeave() {
    hideEndDebateModal();
    // Optionally redirect to /live.html or show "Debate Ended" state
    showToast('üèÅ Debate ended! Room will close shortly.');
    
    // Hide the pot panel and show a "Debate Ended" message
    ['red-room-pot-panel', 'spectator-red-room-pot-panel'].forEach(id => {
      const panel = document.getElementById(id);
      if (panel) panel.classList.add('hidden');
    });
  }
  window.closeEndDebateAndLeave = closeEndDebateAndLeave;
  
  // Broadcast to other users that the debate has ended
  function broadcastDebateEnded(data) {
    if (livekitRoom && livekitRoom.localParticipant) {
      try {
        const endMessage = {
          type: 'debate-ended',
          result: data.result,
          winnerName: data.winnerName,
          winnerAmount: data.winnerAmount,
          totalPot: data.totalPot,
          timestamp: Date.now()
        };
        publishLiveKitDataMessage(endMessage);
        console.log('üì¢ Broadcast debate-ended to all participants');
      } catch (err) {
        console.warn('Could not broadcast debate-ended:', err);
      }
    }
  }
  
  // Handle received debate-ended message (for non-hosts)
  function handleDebateEnded(data) {
    console.log('üèÅ Debate ended notification received:', data);
    
    // Cancel any pending auto-end timer
    cancelAutoEndTimer();
    
    // Mark debate as ended to prevent further auto-end attempts
    roomTypeState.debateEnded = true;
    
    // Show the winner announcement modal (more prominent than toast)
    showWinnerAnnouncementModal(data);
    
    // Hide pot panels
    ['red-room-pot-panel', 'spectator-red-room-pot-panel'].forEach(id => {
      const panel = document.getElementById(id);
      if (panel) panel.classList.add('hidden');
    });
    
    // Refresh gem balance in case user was refunded
    if (typeof fetchAndDisplayGemBalance === 'function') {
      fetchAndDisplayGemBalance();
    }
  }
  
  // Show winner announcement modal to all users
  function showWinnerAnnouncementModal(data) {
    const modal = document.getElementById('winner-announcement-modal');
    const icon = document.getElementById('winner-icon');
    const title = document.getElementById('winner-title');
    const details = document.getElementById('winner-details');
    const message = document.getElementById('winner-message');
    
    if (!modal) return;
    
    if (data.result === 'void') {
      // Pot was voided
      icon.textContent = 'üîÑ';
      title.textContent = 'Debate Voided';
      details.innerHTML = `
        <div class="text-yellow-300 text-xl font-bold mb-2">Pot Under Minimum</div>
        <div class="text-white text-lg">üíé ${data.totalPot || 0} gems</div>
        <div class="text-purple-200 text-sm mt-3">All gems have been refunded to their senders.</div>
      `;
      message.textContent = 'Better luck next time! Tip more to reach the 100 gem minimum.';
    } else if (data.result === 'draw') {
      // Draw
      icon.textContent = 'ü§ù';
      title.textContent = 'It\'s a Draw!';
      details.innerHTML = `
        <div class="text-blue-300 text-xl font-bold mb-2">Evenly Matched!</div>
        <div class="text-white text-lg">üíé ${data.totalPot?.toLocaleString() || 0} total pot</div>
        <div class="text-purple-200 text-sm mt-3">Tips were equal - each debater keeps their share.</div>
      `;
      message.textContent = 'A close battle! Both debaters performed well.';
    } else {
      // Winner!
      const winnerName = data.winnerName || 'The Winner';
      icon.textContent = 'üèÜ';
      title.textContent = `${winnerName} Wins!`;
      details.innerHTML = `
        <div class="text-green-300 text-xl font-bold mb-2">üéâ Victory! üéâ</div>
        <div class="text-white text-2xl font-bold mb-2">üíé ${(data.winnerAmount || 0).toLocaleString()}</div>
        <div class="text-purple-200 text-sm">credited to ${winnerName}</div>
        <div class="text-purple-300 text-xs mt-3">Total pot was: üíé ${(data.totalPot || 0).toLocaleString()}</div>
      `;
      message.textContent = 'Congratulations to the winner! Thanks for watching!';
    }
    
    modal.classList.remove('hidden');
    
    // Also show a toast as backup
    if (data.result === 'void') {
      showToast('üîÑ Debate voided - gems refunded!');
    } else if (data.result === 'draw') {
      showToast('ü§ù It\'s a draw!');
    } else {
      showToast(`üèÜ ${data.winnerName || 'Winner'} takes the pot!`);
    }
  }
  
  // Close the winner announcement modal
  function closeWinnerModal() {
    const modal = document.getElementById('winner-announcement-modal');
    if (modal) modal.classList.add('hidden');
  }
  window.closeWinnerModal = closeWinnerModal;
  
  // ============================================
  // AUTO-END DEBATE WHEN PARTICIPANTS LEAVE
  // ============================================
  
  let autoEndTimerId = null;
  const AUTO_END_DELAY_MS = 60000; // 60 seconds after both participants leave
  
  // Check if we should auto-end the debate (called when participants leave)
  function checkAutoEndDebate() {
    // Only auto-end for Red Rooms
    if (roomTypeState.type !== 'red') return;
    
    // Don't auto-end if already ended
    if (roomTypeState.debateEnded) return;
    
    // Count active participants (non-spectators) in LiveKit
    const activeParticipantCount = countActiveDebaters();
    
    console.log('üîç Checking auto-end: active debaters =', activeParticipantCount);
    
    if (activeParticipantCount === 0) {
      // No debaters left - start auto-end timer
      startAutoEndTimer();
    } else if (activeParticipantCount === 1) {
      // One debater left - show warning but don't auto-end yet
      // The remaining debater might be waiting for opponent to return
      showToast('‚ö†Ô∏è Your opponent left. Debate will auto-close in 60s if they don\'t return.');
      startAutoEndTimer();
    } else {
      // Both debaters present - cancel any pending auto-end
      cancelAutoEndTimer();
    }
  }
  
  // Count active debaters (non-spectators) in the room
  function countActiveDebaters() {
    if (!livekitRoom || !livekitRoom.remoteParticipants) return 0;
    
    let count = 0;
    
    // Count self if we're a participant (not spectator)
    if (!isSpectator) {
      count = 1;
    }
    
    // Count remote participants who are NOT spectators
    for (const [sid, participant] of livekitRoom.remoteParticipants) {
      const normalizedP = normalizeLiveKitParticipant(participant, { local: false });
      const role = getParticipantRole(normalizedP);
      if (role !== 'spectator') {
        count++;
      }
    }
    
    return count;
  }
  
  // Start the auto-end countdown timer
  function startAutoEndTimer() {
    // Cancel any existing timer
    cancelAutoEndTimer();
    
    // Only the host should auto-end the debate
    const urlParams = new URLSearchParams(window.location.search);
    const isHost = urlParams.get('host') === 'true';
    
    if (!isHost || isSpectator) {
      console.log('‚è±Ô∏è Not starting auto-end timer (not host or is spectator)');
      return;
    }
    
    console.log(`‚è±Ô∏è Starting auto-end timer (${AUTO_END_DELAY_MS / 1000}s)`);
    
    autoEndTimerId = setTimeout(async () => {
      // Double-check before ending
      const activeCount = countActiveDebaters();
      
      if (activeCount <= 1 && !roomTypeState.debateEnded) {
        console.log('‚è±Ô∏è Auto-end timer expired, ending debate...');
        await autoEndDebate();
      } else {
        console.log('‚è±Ô∏è Auto-end cancelled - participants returned');
      }
    }, AUTO_END_DELAY_MS);
  }
  
  // Cancel the auto-end timer
  function cancelAutoEndTimer() {
    if (autoEndTimerId) {
      console.log('‚è±Ô∏è Cancelled auto-end timer');
      clearTimeout(autoEndTimerId);
      autoEndTimerId = null;
    }
  }
  
  // Auto-end the debate (called by timer)
  async function autoEndDebate() {
    if (roomTypeState.debateEnded) return;
    
    roomTypeState.debateEnded = true;
    
    const sphereId = extractSphereId(roomUrl);
    const hostId = window.currentUserData?.userId || userId;
    
    try {
      console.log('ü§ñ Auto-ending debate due to participants leaving...');
      
      const response = await fetch('/.netlify/functions/end-red-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: sphereId,
          hostId: hostId
        })
      });
      
      const data = await response.json();
      console.log('ü§ñ Auto-end response:', data);
      
      if (data.success) {
        // Broadcast to any remaining spectators
        broadcastDebateEnded(data);
        
        // Show result to the host
        if (data.result === 'void') {
          showToast('üîÑ Debate auto-closed: All gems refunded (pot under 100)');
        } else if (data.result === 'draw') {
          showToast('ü§ù Debate auto-closed: Draw - gems distributed equally');
        } else {
          showToast(`üèÜ Debate auto-closed: ${data.winnerName || 'Winner'} takes the pot!`);
        }
        
        // Hide pot panels
        ['red-room-pot-panel', 'spectator-red-room-pot-panel'].forEach(id => {
          const panel = document.getElementById(id);
          if (panel) panel.classList.add('hidden');
        });
      }
    } catch (error) {
      console.error('‚ùå Error auto-ending debate:', error);
      roomTypeState.debateEnded = false; // Allow retry
    }
  }
  
  // End Green Room (when host leaves or manually ends)
  async function endGreenRoom() {
    if (roomTypeState.roomEnded) return;
    
    roomTypeState.roomEnded = true;
    
    const sphereId = extractSphereId(roomUrl);
    
    try {
      console.log('üü¢ Ending Green Room...');
      
      // Update room status in database
      const response = await fetch('/.netlify/functions/manage-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'end',
          roomId: sphereId
        })
      });
      
      const data = await response.json();
      console.log('üü¢ Green room ended:', data);
      
      // Broadcast to all participants that room is ending
      if (livekitRoom) {
        const endMessage = {
          type: 'room-ended',
          roomType: 'green',
          message: 'The host has ended this help session.'
        };
        try {
          await livekitRoom.localParticipant?.publishData(
            new TextEncoder().encode(JSON.stringify(endMessage)),
            { reliable: true }
          );
        } catch (e) {
          console.warn('‚ö†Ô∏è Could not broadcast room end message:', e);
        }
      }
      
      showToast('üü¢ Help session ended. Thank you for hosting!');
      
    } catch (error) {
      console.error('‚ùå Error ending green room:', error);
      roomTypeState.roomEnded = false; // Allow retry
    }
  }
  
  // Handle room ended message for Green Rooms
  function handleGreenRoomEnded(data) {
    console.log('üü¢ Green Room ended:', data);
    showToast(data.message || 'üü¢ This help session has ended.');
    
    // Optionally redirect after a delay
    setTimeout(() => {
      if (confirm('The help session has ended. Return to live rooms?')) {
        window.location.href = '/live.html';
      }
    }, 2000);
  }
  
  // Start voting phase
  function startVoting() {
    roomTypeState.votingActive = true;
    
    // Hide pot panels, show voting panels (both participant and spectator)
    ['red-room-pot-panel', 'spectator-red-room-pot-panel'].forEach(id => {
      const panel = document.getElementById(id);
      if (panel) panel.classList.add('hidden');
    });
    
    ['voting-panel', 'spectator-voting-panel'].forEach(id => {
      const panel = document.getElementById(id);
      if (panel) {
        panel.classList.remove('hidden');
      }
    });
    
    populateVoteOptions();
    
    showToast('üó≥Ô∏è Voting has begun! Who won the debate?');
    console.log('üó≥Ô∏è Voting phase started');
  }
  window.startVoting = startVoting;
  
  // Populate vote options (both panels)
  function populateVoteOptions() {
    const votesHtml = roomTypeState.participants.map(p => `
      <button 
        onclick="voteForWinner('${p.id}')"
        class="w-full py-3 px-4 bg-white bg-opacity-20 hover:bg-opacity-30 text-white font-bold rounded-lg transition flex items-center justify-center gap-2"
      >
        <span>üèÜ</span>
        <span>${p.name}</span>
      </button>
    `).join('');
    
    ['vote-options', 'spectator-vote-options'].forEach(id => {
      const container = document.getElementById(id);
      if (container) container.innerHTML = votesHtml;
    });
  }
  
  // Vote for winner
  async function voteForWinner(winnerId) {
    if (roomTypeState.hasVoted) {
      showToast('‚ö†Ô∏è You\'ve already voted!');
      return;
    }
    
    const currentUserId = window.currentUserData?.userId || userId;
    const sphereId = extractSphereId(roomUrl);
    
    try {
      const response = await fetch('/.netlify/functions/vote-winner', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: sphereId,
          voterId: currentUserId,
          votedFor: winnerId,
          isDraw: false
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        roomTypeState.hasVoted = true;
        showToast('‚úÖ Vote recorded!');
        
        const votingPanel = document.getElementById('voting-panel');
        if (votingPanel) {
          votingPanel.innerHTML = `
            <div class="text-center py-6">
              <div class="text-4xl mb-2">‚úÖ</div>
              <div class="text-white font-bold">Vote Recorded!</div>
              <div class="text-purple-200 text-sm mt-2">Waiting for results...</div>
            </div>
          `;
        }
      } else {
        throw new Error(data.error || 'Vote failed');
      }
    } catch (error) {
      console.error('‚ùå Error voting:', error);
      showToast(`‚ùå ${error.message}`);
    }
  }
  window.voteForWinner = voteForWinner;
  
  // Vote for draw
  async function voteForDraw() {
    if (roomTypeState.hasVoted) {
      showToast('‚ö†Ô∏è You\'ve already voted!');
      return;
    }
    
    const currentUserId = window.currentUserData?.userId || userId;
    const sphereId = extractSphereId(roomUrl);
    
    try {
      const response = await fetch('/.netlify/functions/vote-winner', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: sphereId,
          voterId: currentUserId,
          isDraw: true
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        roomTypeState.hasVoted = true;
        showToast('‚úÖ Voted for draw!');
      }
    } catch (error) {
      console.error('‚ùå Error voting draw:', error);
      showToast(`‚ùå ${error.message}`);
    }
  }
  window.voteForDraw = voteForDraw;

  // ============================================
  // BRANDING MODAL FUNCTIONS
  // ============================================
  
  let userBrandingData = null;

  async function openBrandingModal() {
    const modal = document.getElementById('branding-modal');
    if (!modal) return;
    
    const currentUserId = window.currentUserData?.userId || userId;
    
    // Fetch current subscription & branding data
    try {
      const response = await fetch(`/.netlify/functions/get-subscription?userId=${currentUserId}`);
      if (response.ok) {
        const data = await response.json();
        userBrandingData = data;
        
        // Check if user has branding permission
        const canBrand = data.limits?.canCustomBrand || false;
        const upgradePrompt = document.getElementById('branding-upgrade-prompt');
        const logoSection = document.querySelector('#branding-modal .bg-white:nth-child(2)');
        const saveBtn = document.getElementById('branding-save-btn');
        
        if (canBrand) {
          if (upgradePrompt) upgradePrompt.classList.add('hidden');
          if (saveBtn) saveBtn.classList.remove('hidden');
        } else {
          if (upgradePrompt) upgradePrompt.classList.remove('hidden');
          if (saveBtn) saveBtn.classList.add('hidden');
        }
        
        // Update badge display
        const badge = data.badge || {};
        const badgeEmoji = document.getElementById('branding-badge-emoji');
        const badgeLabel = document.getElementById('branding-badge-label');
        const badgeToggle = document.getElementById('badge-visible-toggle');
        
        if (badgeEmoji) badgeEmoji.textContent = badge.emoji || '‚Äî';
        if (badgeLabel) badgeLabel.textContent = badge.label || 'No badge';
        if (badgeToggle) badgeToggle.checked = badge.visible !== false;
        
        // Update logo preview
        const logoUrl = data.profile?.customLogoUrl;
        const logoPreviewContainer = document.getElementById('logo-preview-container');
        const logoPreview = document.getElementById('logo-preview');
        
        if (logoUrl && logoPreviewContainer && logoPreview) {
          logoPreview.src = logoUrl;
          logoPreviewContainer.classList.remove('hidden');
        } else if (logoPreviewContainer) {
          logoPreviewContainer.classList.add('hidden');
        }
      }
    } catch (error) {
      console.error('‚ùå Error loading branding data:', error);
    }
    
    modal.classList.remove('hidden');
  }

  function closeBrandingModal() {
    const modal = document.getElementById('branding-modal');
    if (modal) modal.classList.add('hidden');
  }

  async function handleLogoUpload(event) {
    const file = event.target.files?.[0];
    if (!file) return;
    
    const statusEl = document.getElementById('logo-upload-status');
    const uploadText = document.getElementById('logo-upload-text');
    
    // Validate file size
    if (file.size > 500 * 1024) {
      if (statusEl) {
        statusEl.textContent = '‚ùå File too large. Max 500KB.';
        statusEl.classList.remove('hidden', 'text-green-600');
        statusEl.classList.add('text-main-red');
      }
      return;
    }
    
    // Validate file type
    if (!['image/png', 'image/jpeg', 'image/gif'].includes(file.type)) {
      if (statusEl) {
        statusEl.textContent = '‚ùå Invalid format. Use PNG, JPG, or GIF.';
        statusEl.classList.remove('hidden', 'text-green-600');
        statusEl.classList.add('text-main-red');
      }
      return;
    }
    
    // Show uploading state
    if (uploadText) uploadText.textContent = 'Uploading...';
    if (statusEl) {
      statusEl.textContent = '‚è≥ Uploading logo...';
      statusEl.classList.remove('hidden', 'text-main-red', 'text-green-600');
      statusEl.classList.add('text-charcoal');
    }
    
    try {
      // Convert to base64
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64Data = e.target?.result;
        
        const currentUserId = window.currentUserData?.userId || userId;
        
        const response = await fetch('/.netlify/functions/upload-logo', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: currentUserId,
            logoData: base64Data,
            logoType: file.type
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          // Update preview
          const logoPreviewContainer = document.getElementById('logo-preview-container');
          const logoPreview = document.getElementById('logo-preview');
          
          if (logoPreview && logoPreviewContainer) {
            logoPreview.src = data.logoUrl;
            logoPreviewContainer.classList.remove('hidden');
          }
          
          if (statusEl) {
            statusEl.textContent = '‚úÖ Logo uploaded!';
            statusEl.classList.remove('text-main-red', 'text-charcoal');
            statusEl.classList.add('text-green-600');
          }
          
          showToast('üé® Logo uploaded successfully!');
        } else {
          throw new Error(data.error || 'Upload failed');
        }
      };
      
      reader.readAsDataURL(file);
      
    } catch (error) {
      console.error('‚ùå Logo upload error:', error);
      if (statusEl) {
        statusEl.textContent = `‚ùå ${error.message}`;
        statusEl.classList.remove('text-green-600', 'text-charcoal');
        statusEl.classList.add('text-main-red');
      }
    } finally {
      if (uploadText) uploadText.textContent = 'Upload Logo';
      // Reset file input
      event.target.value = '';
    }
  }

  function removeLogo() {
    const logoPreviewContainer = document.getElementById('logo-preview-container');
    const logoPreview = document.getElementById('logo-preview');
    
    if (logoPreviewContainer) logoPreviewContainer.classList.add('hidden');
    if (logoPreview) logoPreview.src = '';
    
    // TODO: Call API to remove logo from profile
    showToast('Logo removed');
  }

  async function saveBrandingSettings() {
    const badgeToggle = document.getElementById('badge-visible-toggle');
    const badgeVisible = badgeToggle?.checked ?? true;
    
    // TODO: Save badge visibility preference to backend
    showToast('‚úÖ Settings saved!');
    closeBrandingModal();
    
    // Refresh badge cache
    await fetchUserBadge();
  }

  // Make branding functions globally available
  window.openBrandingModal = openBrandingModal;
  window.closeBrandingModal = closeBrandingModal;
  window.handleLogoUpload = handleLogoUpload;
  window.removeLogo = removeLogo;
  window.saveBrandingSettings = saveBrandingSettings;


  // Share Link Functions
  let currentShareMode = 'participant';
  
  function generateShareLink(mode = 'participant') {
    const baseUrl = window.location.origin;
    const sphereId = extractSphereId(roomUrl);
    
    if (!sphereId) {
      console.error('Cannot generate share link: no sphereId found');
      return null;
    }
    
    // Create a clean share link with just the room and mode
    // The person clicking will add their own user info when they join
    const shareUrl = new URL(baseUrl);
    shareUrl.searchParams.set('room', roomUrl || sphereId);
    shareUrl.searchParams.set('mode', mode);
    
    return shareUrl.toString();
  }
  
  // Share stats tracking
  let shareStatsRef = null;
  let shareStatsInitialized = false;
  let currentShareStats = { participants: 0, spectators: 0, linkShares: 0 };

  function openShareModal() {
    const modal = document.getElementById('share-modal');
    const input = document.getElementById('share-link-input');
    
    // Generate participant link by default
    currentShareMode = 'participant';
    const link = generateShareLink('participant');
    
    if (link) {
      input.value = link;
      modal.classList.remove('hidden');
      
      // Highlight participant button
      document.getElementById('share-participant-link').classList.add('ring-2', 'ring-white');
      document.getElementById('share-spectator-link').classList.remove('ring-2', 'ring-white');
      
      // Initialize presence stats
      initSharePresenceStats();
      
      // Hide native share if not supported
      const nativeBtn = document.getElementById('native-share-btn');
      if (nativeBtn && !navigator.share) {
        nativeBtn.style.display = 'none';
      }
    } else {
      showToast('‚ùå Unable to generate share link');
    }
  }
  
  function closeShareModal() {
    document.getElementById('share-modal').classList.add('hidden');
  }
  
  async function initSharePresenceStats() {
    if (!firebaseRoomId || !db) return;
    
    try {
      // Listen for presence changes
      const presenceRef = db.ref(`presence/${firebaseRoomId}`);
      presenceRef.on('value', (snapshot) => {
        const users = snapshot.val() || {};
        const entries = Object.values(users);
        currentShareStats.participants = entries.filter(u => u.type === 'participant' && u.status !== 'offline').length;
        currentShareStats.spectators = entries.filter(u => u.type === 'spectator' && u.status !== 'offline').length;
        updateShareStatsUI();
      });
      
      // Listen for share stats
      const statsRef = db.ref(`shareStats/${firebaseRoomId}`);
      statsRef.on('value', (snapshot) => {
        const stats = snapshot.val() || {};
        currentShareStats.linkShares = stats.linkShares || 0;
        updateShareStatsUI();
      });
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to init share stats:', error);
    }
  }
  
  function updateShareStatsUI() {
    const participantEl = document.getElementById('share-participant-count');
    const spectatorEl = document.getElementById('share-spectator-count');
    const sharesEl = document.getElementById('share-link-shares');
    
    if (participantEl) participantEl.textContent = currentShareStats.participants;
    if (spectatorEl) spectatorEl.textContent = currentShareStats.spectators;
    if (sharesEl) sharesEl.textContent = currentShareStats.linkShares;
  }
  
  async function trackLinkShare(platform = 'copy') {
    if (!firebaseRoomId || !db) return;
    
    try {
      await ensureFirebaseAuth();
      const statsRef = db.ref(`shareStats/${firebaseRoomId}`);
      
      await statsRef.transaction((current) => {
        if (!current) {
          return { linkShares: 1, lastSharedAt: firebase.database.ServerValue.TIMESTAMP };
        }
        return {
          ...current,
          linkShares: (current.linkShares || 0) + 1,
          lastSharedAt: firebase.database.ServerValue.TIMESTAMP
        };
      });
      
      console.log(`üì§ Link share tracked: ${platform}`);
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to track share:', error);
    }
  }
  
  function copyShareLink() {
    const input = document.getElementById('share-link-input');
    const copyBtn = document.getElementById('copy-btn-text');
    const successMsg = document.getElementById('share-success-msg');
    const link = input.value;
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(link).then(() => {
        // Show success in button
        if (copyBtn) {
          copyBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => { copyBtn.textContent = 'üìã Copy Link'; }, 3000);
        }
        // Show success message
        if (successMsg) {
          successMsg.classList.remove('hidden');
          setTimeout(() => { successMsg.classList.add('hidden'); }, 4000);
        }
        trackLinkShare('clipboard');
      }).catch(() => {
        fallbackCopyToClipboard(link);
      });
    } else {
      fallbackCopyToClipboard(link);
    }
  }
  
  function fallbackCopyToClipboard(text) {
    const input = document.getElementById('share-link-input');
    input.select();
    input.setSelectionRange(0, 99999);
    
    try {
      document.execCommand('copy');
      showToast('üìã Link copied! Share it with your friend');
      trackLinkShare('clipboard-fallback');
    } catch (err) {
      showToast('‚ùå Copy failed. Please select and copy manually.');
    }
  }
  
  function setShareLinkMode(mode) {
    currentShareMode = mode;
    const input = document.getElementById('share-link-input');
    const link = generateShareLink(mode);
    const modeText = document.getElementById('share-mode-text');
    const successMsg = document.getElementById('share-success-msg');
    
    if (link) {
      input.value = link;
    }
    
    // Hide success message when switching modes
    if (successMsg) {
      successMsg.classList.add('hidden');
    }
    
    // Update button styling for clear selection
    const participantBtn = document.getElementById('share-participant-link');
    const spectatorBtn = document.getElementById('share-spectator-link');
    
    if (mode === 'participant') {
      participantBtn.classList.remove('opacity-70', 'bg-charcoal', 'text-white');
      participantBtn.classList.add('bg-gold', 'text-charcoal');
      spectatorBtn.classList.remove('bg-gold', 'text-charcoal');
      spectatorBtn.classList.add('opacity-70', 'bg-charcoal', 'text-white');
      if (modeText) modeText.textContent = 'üé§ Participant link selected ‚Äî can speak & share video';
    } else {
      spectatorBtn.classList.remove('opacity-70', 'bg-charcoal', 'text-white');
      spectatorBtn.classList.add('bg-gold', 'text-charcoal');
      participantBtn.classList.remove('bg-gold', 'text-charcoal');
      participantBtn.classList.add('opacity-70', 'bg-charcoal', 'text-white');
      if (modeText) modeText.textContent = 'üëÅÔ∏è Spectator link selected ‚Äî watch & chat only';
    }
  }
  
  // Set up share modal event listeners
  document.getElementById('share-modal-close')?.addEventListener('click', closeShareModal);
  document.getElementById('copy-share-link')?.addEventListener('click', copyShareLink);
  document.getElementById('share-participant-link')?.addEventListener('click', () => setShareLinkMode('participant'));
  document.getElementById('share-spectator-link')?.addEventListener('click', () => setShareLinkMode('spectator'));
  
  // Close modal when clicking outside
  document.getElementById('share-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'share-modal') {
      closeShareModal();
    }
  });
  
  // Close on Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeShareModal();
    }
  });

  // Spark functions (available to all users but only participants can generate new ones)
  function navigateSpark(direction) {
    if (direction === 'next') {
      currentSparkIndex = (currentSparkIndex + 1) % currentSparks.length;
    } else {
      currentSparkIndex = currentSparkIndex === 0 ? currentSparks.length - 1 : currentSparkIndex - 1;
    }
    updateSparkDisplay();
    
    // Sync with other participants
    if (livekitRoom) {
      publishLiveKitDataMessage({
        type: 'spark-navigation',
        sparkIndex: currentSparkIndex
      });
    }
  }

  function updateSparkDisplay() {
    document.getElementById('sparkText').textContent = currentSparks[currentSparkIndex];
    document.getElementById('sparkNumber').textContent = currentSparkIndex + 1;
    
    // Update navigation dots
    for (let i = 1; i <= 3; i++) {
      const dot = document.getElementById(`sparkDot${i}`);
      if (i === currentSparkIndex + 1) {
        dot.className = 'w-2 h-2 bg-main-red rounded-full transition-all';
      } else {
        dot.className = 'w-2 h-2 bg-gray-300 rounded-full transition-all';
      }
    }
    
    // Reset selection state
    const currentSparkEl = document.getElementById('currentSpark');
    currentSparkEl.classList.remove('ring-4', 'ring-gold');
    currentSparkEl.style.background = '';
    sparkIsSelected = false;
  }

  function selectCurrentSpark() {
    const currentSparkEl = document.getElementById('currentSpark');
    
    sparkIsSelected = !sparkIsSelected;
    
    if (sparkIsSelected) {
      currentSparkEl.classList.add('ring-4', 'ring-gold');
      currentSparkEl.style.background = 'linear-gradient(135deg, #FFD166 0%, #FFB6B9 100%)';
      showToast('üåü Spark highlighted for both users!');
    } else {
      currentSparkEl.classList.remove('ring-4', 'ring-gold');
      currentSparkEl.style.background = '';
      showToast('üí´ Spark deselected');
    }
    
    // Sync selection with other participants
    if (livekitRoom) {
      publishLiveKitDataMessage({
        type: 'spark-selected',
        sparkIndex: currentSparkIndex,
        isSelected: sparkIsSelected
      });
    }
  }

  // Load existing sparks for this room on join
  async function loadExistingSparks() {
    if (!roomUrl) {
      console.warn("‚ö†Ô∏è Cannot load sparks without a room URL");
      return;
    }
    if (!promptsDatabaseBaseUrl) {
      console.warn("‚ö†Ô∏è Prompts database URL missing - skipping sparks lookup");
      return;
    }
  
    try {
      console.log("üîç Loading existing sparks for room...");
      console.log("üîó Room URL from params:", roomUrl);
  
      const firebaseUrl = await getPromptsAuthedRealtimeUrl('sparks', {
        orderBy: JSON.stringify('room_url'),
        equalTo: JSON.stringify(roomUrl),
        limitToLast: 1
      });
      console.log("üîç Firebase query URL:", firebaseUrl);
  
    const response = await fetch(firebaseUrl);
  
      if (response.ok) {
        const data = await response.json();
  
        if (data && Object.keys(data).length > 0) {
          const latestSparkEntry = Object.values(data)[0];
  
          if (latestSparkEntry.sparks && latestSparkEntry.sparks.length > 0) {
            console.log("‚úÖ Found existing sparks:", latestSparkEntry.sparks);
            currentSparks = latestSparkEntry.sparks;
            currentSparkIndex = 0;
            updateSparkDisplay();
            showToast(`üìö Loaded ${latestSparkEntry.sparks.length} saved sparks for "${latestSparkEntry.topic}"!`);
            return;
          }
        }
      } else {
        const errorText = await response.text();
        console.error("‚ùå Firebase response not ok:", response.status, response.statusText, errorText);
        console.error("‚ùå Request URL was:", response.url);
      }
  
      console.log("üìù No existing sparks found, using defaults");
    } catch (error) {
      console.error("‚ùå Error loading existing sparks:", error);
      console.log("üìù Using default sparks due to error");
    }
  }

  // Initialize sparks after joining call
  async function initializeSparks() {
    await loadExistingSparks();
    
    const currentTopic = document.getElementById('topic-display').textContent;
    if (!isSpectator && currentSparks.length === 3 && currentTopic && currentTopic !== 'Loading Topic...' && currentTopic !== 'General Chat') {
      console.log("ü§ñ Auto-generating sparks for topic:", currentTopic);
      try {
        await generateSparksWithAI(currentTopic);
      } catch (error) {
        console.log("üìù Auto-generation failed, keeping defaults:", error.message);
      }
    }
  }

  // AI Spark Generation Functions (only for participants)
  async function generateNewSparks() {
    if (isSpectator) {
      showToast('üëÄ Only participants can generate sparks');
      return;
    }
    
    const generateBtn = document.getElementById('newSparkBtn');
    const originalText = generateBtn.innerHTML;
    
    try {
      generateBtn.innerHTML = 'üîÑ generating...';
      generateBtn.disabled = true;
      
      const currentTopic = document.getElementById('topic-display').textContent || 'general conversation';
      console.log("üß† Generating sparks for topic:", currentTopic);
      
      await generateSparksWithAI(currentTopic);
      
    } catch (error) {
      console.error("‚ùå Spark generation failed:", error);
      showToast('‚ùå Failed to generate sparks: ' + error.message);
    } finally {
      generateBtn.innerHTML = originalText;
      generateBtn.disabled = false;
    }
  }

  async function generateCustomSparks() {
    if (isSpectator) {
      showToast('üëÄ Only participants can generate sparks');
      return;
    }
    
    const customTopic = document.getElementById('userPrompt').value.trim();
    const generateBtn = document.querySelector('button[onclick="generateCustomSparks()"]');
    const originalText = generateBtn.innerHTML;
    
    if (!customTopic) {
      showToast('üí≠ Please enter a topic first!');
      document.getElementById('userPrompt').focus();
      return;
    }
    
    try {
      generateBtn.innerHTML = '‚ö° generating...';
      generateBtn.disabled = true;
      
      console.log("üß† Generating custom sparks for:", customTopic);
      
      await generateSparksWithAI(customTopic);
      
      document.getElementById('userPrompt').value = '';
      
    } catch (error) {
      console.error("‚ùå Custom spark generation failed:", error);
      showToast('‚ùå Failed to generate custom sparks: ' + error.message);
    } finally {
      generateBtn.innerHTML = originalText;
      generateBtn.disabled = false;
    }
  }

  async function generateSparksWithAI(topic) {
    const sparkPrompt = `Give 5 fresh and creative conversation starters about "${topic}". Number each one clearly (1. 2. 3. 4. 5.) and make them engaging and thought-provoking.`;

    console.log("ü§ñ Calling Netlify Function for AI sparks...");
    if (!promptsDatabaseBaseUrl) {
      throw new Error("Prompts database URL is not configured");
    }
    
    const response = await fetch("/.netlify/functions/generatespark", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json" 
      },
      body: JSON.stringify({ 
        prompt: sparkPrompt 
      })
    });

    if (!response.ok) {
      let errorMessage = `Netlify Function error: ${response.status} ${response.statusText}`;
      
      if (response.status === 401) {
        errorMessage = "‚ùå API Authentication failed. Please check your OpenAI API key configuration in Netlify.";
        console.error("üîë 401 Error - API key issue:", {
          status: response.status,
          statusText: response.statusText,
          url: response.url
        });
      } else if (response.status === 404) {
        errorMessage = "‚ùå Netlify Function not found. Make sure your generateSpark function is deployed.";
      } else if (response.status >= 500) {
        errorMessage = "‚ùå Server error. Please try again in a moment.";
      }
      
      throw new Error(errorMessage);
    }

    const json = await response.json();
    const rawContent = json.result || "";
    
    console.log("ü§ñ Netlify Function raw response:", rawContent);
    
    const sparks = rawContent
      .split("\n")
      .map(line => line.trim())
      .filter(line => line.length > 0 && /^\d+\./.test(line))
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(line => line.length > 10);

    console.log("‚ú® Parsed sparks:", sparks);

    if (sparks.length === 0) {
      throw new Error("No valid sparks generated from AI response");
    }

    console.log("üíæ Saving sparks to Firebase...");
    
    const sparkData = {
      topic: topic,
      sparks: sparks,
      room_url: roomUrl,
      created_at: new Date().toISOString(),
      generated_by: "ai"
    };

    const sparksEndpoint = await getPromptsAuthedRealtimeUrl('sparks');
    const saveResponse = await fetch(sparksEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(sparkData)
    });

    if (!saveResponse.ok) {
      const errorBody = await saveResponse.text();
      throw new Error(`Failed to save sparks to Firebase: ${saveResponse.status} ${saveResponse.statusText} ${errorBody}`);
    }

    console.log("üé® Updating UI with new sparks...");
    
    currentSparks = sparks;
    currentSparkIndex = 0;
    updateSparkDisplay();
    
    // Sync with other participant
    if (livekitRoom) {
      publishLiveKitDataMessage({
        type: 'sparks-updated',
        sparks: sparks,
        topic: topic
      });
    }

    showToast(`‚úÖ Generated ${sparks.length} sparks for "${topic}"!`);
    console.log("‚úÖ Spark generation complete!");
  }

  // Set up existing participants for participants who join late or refresh
  function setupExistingParticipantsForParticipant(attemptNum = 0) {
    if (isSpectator) return;
    
    // Check if remote video is already working
    const remoteVideoEl = document.getElementById('remote-video');
    const hasWorkingVideo = remoteVideoEl && 
                           remoteVideoEl.srcObject && 
                           remoteVideoEl.style.display === 'block' &&
                           !remoteVideoEl.paused;
    
    if (hasWorkingVideo && attemptNum > 0) {
      console.log('‚úÖ Remote video already working, skipping setup attempt', attemptNum);
      return;
    }
    
    console.log(`üîÑ Setting up existing participants (attempt ${attemptNum + 1})...`);
    
    const participants = getParticipantsSnapshot();
    
    // Get the local participant's session ID to properly exclude them
    const localParticipant = participants.local;
    const localSessionId = localParticipant?.session_id;
    const localUserName = userName || window.currentUserData?.username;
    
    console.log('üîç Local participant info:', {
      localSessionId,
      localUserName,
      livekitLocalSid: livekitRoom?.localParticipant?.sid
    });
    
    // Filter out the local participant more robustly
    // Check: not the 'local' key, not matching local session_id, not matching local participant sid, and local property is false
    const remoteParticipants = Object.entries(participants).filter(([id, participant]) => {
      // Skip the 'local' key
      if (id === 'local') return false;
      
      // Skip if explicitly marked as local
      if (participant.local === true) return false;
      
      // Skip if session_id matches local participant
      if (localSessionId && participant.session_id === localSessionId) return false;
      
      // Skip if session_id matches LiveKit local participant sid
      if (livekitRoom?.localParticipant?.sid && participant.session_id === livekitRoom.localParticipant.sid) return false;
      
      // Skip if username matches local user (additional safety check)
      if (localUserName && participant.user_name === localUserName) {
        console.log('‚ö†Ô∏è Skipping participant with matching username:', participant.user_name);
        return false;
      }
      
      return true;
    });
    
    console.log('üë• Found remote participants:', remoteParticipants.length, 
      remoteParticipants.map(([id, p]) => `${p.user_name}(${id.substring(0,8)})`));
    
    if (remoteParticipants.length > 0) {
      hideWaitingOverlay();
    }
    
    // CRITICAL: Filter out spectators - we only want actual debate participants
    const actualParticipants = remoteParticipants.filter(([id, p]) => {
      const role = getParticipantRole(p);
      if (role === 'spectator') {
        console.log('‚è≠Ô∏è Skipping spectator:', p.user_name);
        return false;
      }
      return true;
    });
    
    console.log('üéØ Actual participants (non-spectators):', actualParticipants.length,
      actualParticipants.map(([id, p]) => `${p.user_name}(${id.substring(0,8)})`));
    
    // Only set up ONE remote participant for participant view (1:1 call)
    // Take the first actual remote participant (not spectator)
    const [participantId, participant] = actualParticipants[0] || [];
    
    if (participant) {
      console.log('üé≠ Processing remote participant for participant view:', participantId, participant.user_name);
      
      // CRITICAL: Track this as the other participant for Red Room scoreboard
      // Try to get userId from the participant data or LiveKit
      let remoteUserId = null;
      let remoteDisplayName = participant.user_name || 'Guest';
      
      // Method 1: Try getParticipantUserId directly
      remoteUserId = getParticipantUserId(participant);
      
      // Method 2: Try from LiveKit participant metadata
      if (!remoteUserId && livekitRoom) {
        const lkParticipant = livekitRoom.remoteParticipants.get(participantId) ||
                             Array.from(livekitRoom.remoteParticipants.values()).find(p => p.sid === participantId);
        if (lkParticipant) {
          const metadata = parseLiveKitMetadata(lkParticipant.metadata);
          remoteUserId = metadata?.userId || metadata?.user_id;
          if (metadata?.displayName) {
            remoteDisplayName = metadata.displayName;
          }
        }
      }
      
      if (remoteUserId) {
        console.log('üë§ Found existing participant userId:', remoteUserId, 'name:', remoteDisplayName);
        updateOtherParticipant(remoteUserId, remoteDisplayName);
        
        // Update pot targets for Red Room
        if (typeof roomTypeState !== 'undefined' && roomTypeState.type === 'red') {
          updatePotTargets();
          // Reload pot state from Supabase to ensure fresh data
          if (typeof loadPotStateFromSupabase === 'function') {
            loadPotStateFromSupabase();
          }
        }
      } else {
        console.log('‚ö†Ô∏è Could not extract userId for existing participant');
      }
      
      // Try to get video track from multiple sources
      let videoTrack = null;
      
      // Method 1: From normalized tracks
      if (participant.tracks?.video?.persistentTrack) {
        videoTrack = participant.tracks.video.persistentTrack;
        console.log('üé• Found video track via normalized tracks');
      }
      
      // Method 2: From camera tracks
      if (!videoTrack && participant.tracks?.camera?.persistentTrack) {
        videoTrack = participant.tracks.camera.persistentTrack;
        console.log('üé• Found video track via camera tracks');
      }
      
      // Method 3: Try to get from LiveKit directly
      if (!videoTrack && livekitRoom) {
        const lkParticipant = livekitRoom.remoteParticipants.get(participantId);
        if (lkParticipant) {
          const videoPublication = lkParticipant.getTrackPublication('camera') || 
                                  Array.from(lkParticipant.videoTrackPublications.values())[0];
          if (videoPublication?.track) {
            videoTrack = videoPublication.track.mediaStreamTrack || videoPublication.track;
            console.log('üé• Found video track via LiveKit participant');
          }
        }
      }
      
      if (videoTrack) {
        console.log('üé• Setting up remote video for existing participant:', participantId);
        setupRemoteVideo(videoTrack);
        updateRemoteInfo(participant.user_name || 'Guest');
        hideWaitingOverlay();
        
        // CRITICAL: Force video visibility after setup
        const remoteVideoEl = document.getElementById('remote-video');
        const placeholder = document.getElementById('remote-placeholder');
        if (remoteVideoEl) {
          remoteVideoEl.classList.remove('hidden');
          remoteVideoEl.style.display = 'block';
          remoteVideoEl.style.visibility = 'visible';
          if (placeholder) {
            placeholder.style.display = 'none';
            placeholder.classList.add('hidden');
          }
          // Force play
          if (remoteVideoEl.srcObject && remoteVideoEl.paused) {
            remoteVideoEl.play().then(() => {
              console.log('‚úÖ Existing participant video now playing');
            }).catch(e => console.log('Play existing:', e.message));
          }
        }
      } else {
        console.log('üì∑ Remote participant has no video track, showing placeholder');
        updateRemotePlaceholderForCameraOff(participant);
      }
      
      // Set up screen share tracks if available
      if (participant.tracks && participant.tracks.screenVideo && participant.tracks.screenVideo.persistentTrack) {
        console.log('üì∫ Setting up screen share for existing participant:', participantId);
        setupScreenShareVideo(participant.tracks.screenVideo.persistentTrack);
      }
      
      // Set up audio tracks if available
      if (participant.tracks && participant.tracks.audio && participant.tracks.audio.persistentTrack) {
        console.log('üîä Setting up audio for existing participant:', participantId);
        setupRemoteAudio(participant.tracks.audio.persistentTrack);
      }
    } else {
      console.log('‚ÑπÔ∏è No remote participants found to set up');
    }
    
    console.log('‚úÖ Participant refresh setup complete');
  }

  // Video recovery watcher - periodically checks and fixes video connection issues
  let videoRecoveryInterval = null;
  
  function startVideoRecoveryWatcher() {
    if (isSpectator) return;
    if (videoRecoveryInterval) {
      clearInterval(videoRecoveryInterval);
    }
    
    let checkCount = 0;
    const maxChecks = 30; // Check for up to 5 minutes (every 10 seconds)
    
    videoRecoveryInterval = setInterval(() => {
      checkCount++;
      
      // Stop checking after max attempts
      if (checkCount > maxChecks) {
        console.log('‚èπÔ∏è Video recovery watcher stopped (max checks reached)');
        clearInterval(videoRecoveryInterval);
        videoRecoveryInterval = null;
        return;
      }
      
      const remoteVideoEl = document.getElementById('remote-video');
      const placeholder = document.getElementById('remote-placeholder');
      
      // Check if video is playing correctly
      const hasVideoStream = remoteVideoEl && remoteVideoEl.srcObject;
      const isVideoVisible = remoteVideoEl && remoteVideoEl.style.display === 'block';
      const isVideoPlaying = remoteVideoEl && !remoteVideoEl.paused && remoteVideoEl.readyState >= 2;
      
      // Check if there are remote participants we should be seeing
      const participants = getParticipantsSnapshot();
      const localUserName = userName || window.currentUserData?.username;
      const localSid = livekitRoom?.localParticipant?.sid;
      
      const remoteParticipants = Object.entries(participants).filter(([id, p]) => {
        if (id === 'local' || p.local === true) return false;
        if (p.session_id === localSid) return false;
        if (localUserName && p.user_name === localUserName) return false;
        if (getParticipantRole(p) === 'spectator') return false;
        return true;
      });
      
      if (remoteParticipants.length === 0) {
        // No remote participants, nothing to recover
        return;
      }
      
      // If we have remote participants but no video showing, attempt recovery
      if (!hasVideoStream || !isVideoVisible) {
        console.log('üîß Video recovery: attempting to fix missing remote video...');
        
        // Try to find and attach the video track
        for (const [pid, participant] of remoteParticipants) {
          let videoTrack = null;
          
          // Try multiple methods to find the track
          if (participant.tracks?.video?.persistentTrack?.readyState === 'live') {
            videoTrack = participant.tracks.video.persistentTrack;
          } else if (participant.tracks?.camera?.persistentTrack?.readyState === 'live') {
            videoTrack = participant.tracks.camera.persistentTrack;
          } else if (livekitRoom) {
            // Try LiveKit directly
            const lkParticipant = livekitRoom.remoteParticipants.get(pid);
            if (lkParticipant) {
              const cameraPub = lkParticipant.getTrackPublication('camera');
              const videoPub = Array.from(lkParticipant.videoTrackPublications.values())
                .find(pub => pub.track && !pub.source?.includes('screen'));
              
              const pub = cameraPub || videoPub;
              if (pub?.track?.mediaStreamTrack?.readyState === 'live') {
                videoTrack = pub.track.mediaStreamTrack;
              } else if (pub?.track?.readyState === 'live') {
                videoTrack = pub.track;
              }
            }
          }
          
          if (videoTrack) {
            console.log('üîß Video recovery: found track, setting up remote video');
            setupRemoteVideo(videoTrack);
            updateRemoteInfo(participant.user_name || 'Guest');
            hideWaitingOverlay();
            
            // Force visibility
            if (remoteVideoEl) {
              remoteVideoEl.classList.remove('hidden');
              remoteVideoEl.style.display = 'block';
              remoteVideoEl.style.visibility = 'visible';
              if (placeholder) {
                placeholder.style.display = 'none';
              }
            }
            
            console.log('‚úÖ Video recovery: remote video restored');
            break;
          }
        }
      } else if (hasVideoStream && isVideoVisible && !isVideoPlaying) {
        // Video stream exists but not playing - try to play it
        console.log('üîß Video recovery: video exists but not playing, attempting play...');
        remoteVideoEl.play().then(() => {
          console.log('‚úÖ Video recovery: video now playing');
        }).catch(e => {
          console.log('‚ö†Ô∏è Video recovery: play failed:', e.message);
        });
      }
    }, 10000); // Check every 10 seconds
    
    console.log('üîÑ Video recovery watcher started');
  }
  
  function stopVideoRecoveryWatcher() {
    if (videoRecoveryInterval) {
      clearInterval(videoRecoveryInterval);
      videoRecoveryInterval = null;
      console.log('‚èπÔ∏è Video recovery watcher stopped');
    }
  }

  // Set up existing participants for spectators who join late or refresh
  function setupExistingParticipants(retryCount = 0) {
    if (!isSpectator) return;
    
    console.log(`üîÑ Setting up existing participants for spectator (attempt ${retryCount + 1}/5)`);
    
    const participants = getParticipantsSnapshot();
    
    // Get the local participant's session ID to properly exclude them
    const localParticipant = participants.local;
    const localSessionId = localParticipant?.session_id;
    
    // Filter out the local participant more robustly
    const remoteParticipants = Object.entries(participants).filter(([id, participant]) => {
      // Skip the 'local' key
      if (id === 'local') return false;
      // Skip if explicitly marked as local
      if (participant.local === true) return false;
      // Skip if session_id matches local participant
      if (localSessionId && participant.session_id === localSessionId) return false;
      // Skip if session_id matches LiveKit local participant sid
      if (livekitRoom?.localParticipant?.sid && participant.session_id === livekitRoom.localParticipant.sid) return false;
      return true;
    });
    
    const spectatorSlotsPopulated = !!(spectatorParticipant1 || spectatorParticipant2);
    
    console.log('üë• Found participants:', remoteParticipants.length);
    
    // If no participants found and we haven't exceeded retry limit, try again
    if (!spectatorSlotsPopulated && remoteParticipants.length === 0 && retryCount < 4) {
      console.log(`‚è≥ No participants found, retrying in ${(retryCount + 1) * 500}ms...`);
      setTimeout(() => {
        setupExistingParticipants(retryCount + 1);
      }, (retryCount + 1) * 500);
      return;
    }
    
    if (remoteParticipants.length > 0) {
      console.log('‚úÖ Found existing participants, setting them up...');
      hydrateSpectatorTracksFromLiveKit();
      remoteParticipants.forEach(([participantId, participant]) => {
        console.log('üé≠ Processing participant:', participantId, participant.user_name);
        
        // Set up video tracks if available
        if (participant.tracks && participant.tracks.video && participant.tracks.video.persistentTrack) {
          console.log('üé• Setting up video for existing participant:', participantId);
          setupSpectatorVideo(participant.tracks.video.persistentTrack, participantId);
        }
        
        // Set up screen share tracks if available
        if (participant.tracks && participant.tracks.screenVideo && participant.tracks.screenVideo.persistentTrack) {
          console.log('üì∫ Setting up screen share for existing participant:', participantId);
          setupSpectatorScreenShare(participant.tracks.screenVideo.persistentTrack);
        }
        
        // Set up audio tracks if available
        if (participant.tracks && participant.tracks.audio && participant.tracks.audio.persistentTrack) {
          console.log('üîä Setting up audio for existing participant:', participantId);
          setupRemoteAudio(participant.tracks.audio.persistentTrack);
        }
      });
      
      // Update click overlay since we have participants, but don't hide until user interacts
      checkAndHideClickOverlay();
      
    } else if (!spectatorSlotsPopulated) {
      console.log('üì∫ No participants found after retries, showing click overlay');
      // If no participants were found after retries, make sure click overlay is visible
      forceSpectatorOverlayVisible('no-participants');
    } else {
      console.log('‚ÑπÔ∏è Spectator slots already populated, skipping fallback overlay.');
      checkAndHideClickOverlay();
    }
  }

  // Enable spectator video on user interaction
  function enableSpectatorVideo() {
    console.log("üé¨ enableSpectatorVideo() - User clicked to enable spectator video");
    console.log("üåê Browser info for spectator enable:", {
      isSafari,
      isIOS,
      isMobileSafari,
      userHasInteracted: userHasInteracted
    });
    
    // Mark that user has interacted - critical for Safari
    userHasInteracted = true;
    markUserGestureReceived();
    hydrateSpectatorTracksFromLiveKit();
    
    // Enable audio context - especially important for Safari
    enableAudioContext();
    
    const clickOverlay = document.getElementById('spectator-click-overlay');
    
    // Try to play all available participant videos and auto-play future videos
    let playPromises = [];
    let participantCount = 0;
    
    // Play participant 1 video if available
    const video1 = document.getElementById('spectator-participant-1');
    const placeholder1 = document.getElementById('spectator-placeholder-1');
    if (video1 && video1.srcObject) {
      console.log("üé¨ Attempting to play participant 1 video");
      video1.classList.remove('hidden');
      video1.style.display = 'block';
      if (placeholder1) placeholder1.style.display = 'none';
      participantCount++;
      playPromises.push(
        video1.play().then(() => {
          console.log("‚úÖ Participant 1 video now playing");
          return true;
        }).catch(err => {
          console.error("‚ùå Participant 1 video play failed:", err.message);
          if (isSafari) {
            console.log("üçé Safari: Will retry video play on next interaction");
          }
          return false;
        })
      );
    } else {
      console.log("‚ÑπÔ∏è Participant 1 video not available (no srcObject)");
    }
    
    // Play participant 2 video if available
    const video2 = document.getElementById('spectator-participant-2');
    const placeholder2 = document.getElementById('spectator-placeholder-2');
    if (video2 && video2.srcObject) {
      console.log("üé¨ Attempting to play participant 2 video");
      video2.classList.remove('hidden');
      video2.style.display = 'block';
      if (placeholder2) placeholder2.style.display = 'none';
      participantCount++;
      playPromises.push(
        video2.play().then(() => {
          console.log("‚úÖ Participant 2 video now playing");
          return true;
        }).catch(err => {
          console.error("‚ùå Participant 2 video play failed:", err.message);
          if (isSafari) {
            console.log("üçé Safari: Will retry video play on next interaction");
          }
          return false;
        })
      );
    } else {
      console.log("‚ÑπÔ∏è Participant 2 video not available (no srcObject)");
    }
    
    // Show appropriate feedback based on what's available
    if (playPromises.length > 0) {
      // Hide overlay immediately since we have videos to play
      clickOverlay.style.opacity = '0';
      clickOverlay.style.transform = 'scale(0.95)';
      setTimeout(() => {
        clickOverlay.style.display = 'none';
      }, 300);
      
      Promise.allSettled(playPromises).then((results) => {
        const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
        if (successCount > 0) {
          showToast(`üé¨ Now watching ${successCount} participant${successCount > 1 ? 's' : ''}! üëÄ`);
        } else {
          showToast('üé¨ Videos ready! They may start playing shortly...');
        }
        
        // Check if videos are actually playing after a short delay
        setTimeout(() => {
          if (!areVideosPlaying()) {
            console.log('‚ö†Ô∏è Videos not playing yet, keeping overlay ready to show');
          }
        }, 1000);
      });
    } else {
      console.log("üé¨ No videos available yet, but user interaction registered");
      showToast('üé¨ Ready for video! Waiting for participants to join...');
      
      // Keep overlay visible but update its state
      const overlayText = clickOverlay.querySelector('.text-center.text-white');
      if (overlayText) {
        const title = overlayText.querySelector('.font-bold.text-xl.text-white');
        const subtitle = overlayText.querySelector('.text-sm.text-gold');
        
        if (title) title.textContent = '‚è≥ Waiting for Participants';
        if (subtitle) subtitle.textContent = 'Videos will start automatically when participants join!';
      }
    }
    
    // Also try to play any remote audio
    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio && remoteAudio.srcObject) {
      remoteAudio.play().then(() => {
        console.log("‚úÖ Remote audio now playing");
      }).catch(err => {
        console.log("Remote audio play attempt:", err);
      });
    }
    
    console.log('üé¨ User interaction complete, videos should automatically play and start when new participants join');
    
    // CRITICAL: Update expand buttons now that user has interacted
    updateSpectatorExpandButtons();
    
    // Check overlay status
    setTimeout(() => {
      checkAndHideClickOverlay();
    }, 500);
  }

  // Enable audio context on user interaction
  document.addEventListener('click', enableAudioContext, { once: true });
  document.addEventListener('touchstart', enableAudioContext, { once: true });
  
  function enableAudioContext() {
    console.log("üîä Enabling audio context from user interaction");
    if (window.AudioContext || window.webkitAudioContext) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log("‚úÖ Audio context resumed");
        });
      }
    }
    
    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio) {
      remoteAudio.play().catch(err => console.log("Audio play attempt:", err));
    }
  }

  // Fullscreen functionality
  function toggleFullscreen(videoId) {
    const video = document.getElementById(videoId === 'remote-video' ? 'screen-share-video' : videoId);
    const container = video ? video.parentElement : null;
    
    if (!container) {
      console.error('Video container not found for fullscreen');
      return;
    }
    
    if (container.classList.contains('video-fullscreen')) {
      // Exit fullscreen
      container.classList.remove('video-fullscreen');
      showToast('üì∫ Exited fullscreen mode');
    } else {
      // Enter fullscreen
      container.classList.add('video-fullscreen');
      showToast('üì∫ Entered fullscreen mode - Press ESC or click again to exit');
      
      // Add escape key listener
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          container.classList.remove('video-fullscreen');
          document.removeEventListener('keydown', escapeHandler);
          showToast('üì∫ Exited fullscreen mode');
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
  }

  // Make fullscreen function global
  window.toggleFullscreen = toggleFullscreen;

  // Spectator Immersive Viewing Functions
  let isSpectatorExpanded = false;
  let currentExpansionMode = null; // 'participants' or 'screenshare'

  function toggleSpectatorExpansion(mode) {
    if (!isSpectator) return;
    
    console.log(`üé¨ Toggling spectator expansion mode: ${mode}`);
    
    const spectatorLayout = document.getElementById('spectator-layout');
    const videoContainer = spectatorLayout.querySelector('.lg\\:col-span-3');
    const participantsBtn = document.getElementById('expand-participants-btn');
    const screenshareBtn = document.getElementById('expand-screenshare-btn');
    
    if (isSpectatorExpanded && currentExpansionMode === mode) {
      // Exit expansion mode
      console.log('üì∫ Exiting spectator expansion mode');
      
      isSpectatorExpanded = false;
      currentExpansionMode = null;
      
      // Reset layout
      spectatorLayout.classList.remove('spectator-expanded');
      videoContainer.classList.remove('spectator-video-expanded');
      
      // Update button states
      participantsBtn.classList.remove('expanded');
      screenshareBtn.classList.remove('expanded');
      participantsBtn.innerHTML = `
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
          <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
        </svg>
        EXPAND
      `;
      screenshareBtn.innerHTML = `
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
          <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 15a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1v-2z"/>
        </svg>
        EXPAND
      `;
      
      showToast('üì∫ Exited immersive view');
      
    } else {
      // Enter expansion mode
      console.log(`üé¨ Entering spectator expansion mode: ${mode}`);
      
      isSpectatorExpanded = true;
      currentExpansionMode = mode;
      
      // Apply expansion layout
      spectatorLayout.classList.add('spectator-expanded');
      videoContainer.classList.add('spectator-video-expanded');
      
      // Update button states
      if (mode === 'participants') {
        participantsBtn.classList.add('expanded');
        screenshareBtn.classList.remove('expanded');
        participantsBtn.innerHTML = `
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
            <path d="M13 7H7v6h6V7z"/>
            <path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 110-2h1V5a2 2 0 012-2h2V2z" clip-rule="evenodd"/>
          </svg>
          COLLAPSE
        `;
        showToast('üé¨ Immersive participant view activated! Chat remains visible.');
      } else if (mode === 'screenshare') {
        screenshareBtn.classList.add('expanded');
        participantsBtn.classList.remove('expanded');
        screenshareBtn.innerHTML = `
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
            <path d="M13 7H7v6h6V7z"/>
            <path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 110-2h1V5a2 2 0 012-2h2V2z" clip-rule="evenodd"/>
          </svg>
          COLLAPSE
        `;
        showToast('üé¨ Immersive screen share view activated! Chat remains visible.');
      }
    }
    
    // Add keyboard shortcut to exit
    if (isSpectatorExpanded) {
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          toggleSpectatorExpansion(currentExpansionMode);
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
  }

  // Function to show/hide expand buttons based on content availability
  function updateSpectatorExpandButtons() {
    if (!isSpectator) return;
    
    const participantsBtn = document.getElementById('expand-participants-btn');
    const screenshareBtn = document.getElementById('expand-screenshare-btn');
    const spectatorScreenShare = document.getElementById('spectator-screen-share');
    const video1 = document.getElementById('spectator-participant-1');
    const video2 = document.getElementById('spectator-participant-2');
    
    // Check if screen share is actually active
    const hasScreenShare = spectatorScreenShare && 
                          spectatorScreenShare.srcObject && 
                          !spectatorScreenShare.classList.contains('hidden');
    
    // Check if participants are available
    const hasParticipants = (video1 && video1.srcObject && !video1.classList.contains('hidden')) || 
                           (video2 && video2.srcObject && !video2.classList.contains('hidden'));
    
    console.log(`üé¨ Button update check - Participants: ${hasParticipants}, ScreenShare: ${hasScreenShare}, UserInteracted: ${userHasInteracted}`);
    
    // Show expand buttons only after user interaction AND content is available
    if (userHasInteracted) {
      // PRIORITY: Screen share button takes precedence when active
      if (hasScreenShare) {
        // Show ONLY screen share button when screen sharing
        screenshareBtn.style.display = 'flex';
        screenshareBtn.classList.remove('hidden');
        participantsBtn.style.display = 'none';
        participantsBtn.classList.add('hidden');
        console.log('‚úÖ Showing screen share expand button');
      } else if (hasParticipants) {
        // Show ONLY participants button when no screen share but participants available
        participantsBtn.style.display = 'flex';
        participantsBtn.classList.remove('hidden');
        screenshareBtn.style.display = 'none';
        screenshareBtn.classList.add('hidden');
        console.log('‚úÖ Showing participants expand button');
      } else {
        // Hide both buttons when no content available
        participantsBtn.style.display = 'none';
        participantsBtn.classList.add('hidden');
        screenshareBtn.style.display = 'none';
        screenshareBtn.classList.add('hidden');
        console.log('‚ùå Hiding all expand buttons - no content');
      }
    } else {
      // Hide both buttons when user hasn't interacted yet
      participantsBtn.style.display = 'none';
      participantsBtn.classList.add('hidden');
      screenshareBtn.style.display = 'none';
      screenshareBtn.classList.add('hidden');
      console.log('‚ùå Hiding all expand buttons - no user interaction');
    }
  }

  // ========================================
  // MODERATION SYSTEM
  // ========================================
  
  // State for moderation
  let pendingRatingData = null;
  let selectedReportCategory = null;
  let reportTargetUserId = null;
  let reportTargetUserName = null;
  
  // Chat spam prevention
  let lastChatMessageTime = 0;
  let lastChatMessageText = '';
  const CHAT_RATE_LIMIT_MS = 2000; // 2 seconds between messages
  
  // Muted chat users (host-only feature)
  let mutedChatUserIds = new Set();
  
  // Track the other participant for rating
  let otherParticipantId = null;
  let otherParticipantName = null;
  
  // Set up feedback character counter and check for pending ratings on page load
  document.addEventListener('DOMContentLoaded', () => {
    const feedbackTextarea = document.getElementById('rating-feedback');
    const charCount = document.getElementById('feedback-char-count');
    if (feedbackTextarea && charCount) {
      feedbackTextarea.addEventListener('input', () => {
        charCount.textContent = feedbackTextarea.value.length;
      });
    }
    
    // FALLBACK: Check localStorage for pending rating on page load
    // This catches users who navigate directly to index.html with a pending rating
    setTimeout(() => {
      const existingData = getPendingRatingFromStorage();
      if (existingData && existingData.ratedId && !document.getElementById('rating-modal').classList.contains('active')) {
        console.log('üìä DOMContentLoaded: Found pending rating, checking if modal should show...');
        checkAndShowPendingRatingFromStorage();
      }
    }, 3000); // Wait 3 seconds for auth to initialize
  });
  
  // Show rating modal after call ends
  function showRatingModal(otherUserId, otherUserName) {
    if (!otherUserId || !window.currentUserData?.userId) {
      console.log('‚è≠Ô∏è Skipping rating modal - missing user data');
      return;
    }
    
    // Don't show rating for guests rating guests
    if (window.currentUserData.isGuest) {
      console.log('‚è≠Ô∏è Skipping rating modal - guest user');
      return;
    }
    
    pendingRatingData = {
      raterId: window.currentUserData.userId,
      ratedId: otherUserId,
      roomId: conversationRoomId || roomUrl,
    };
    
    const displayName = otherUserName || 'your chat partner';
    document.getElementById('rating-other-user-name').textContent = displayName;
    document.getElementById('rating-modal').classList.remove('hidden');
    document.getElementById('rating-feedback').value = '';
    document.getElementById('feedback-char-count').textContent = '0';
  }
  
  // Submit rating
  async function submitRating(rating) {
    if (!pendingRatingData) {
      console.error('No pending rating data');
      return;
    }
    
    const feedback = document.getElementById('rating-feedback')?.value?.trim() || '';
    
    try {
      const response = await fetch('/.netlify/functions/submit-rating', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...pendingRatingData,
          rating: rating,
          feedback: feedback || null,
        }),
      });
      
      const data = await response.json();
      
      if (data.success) {
        showToast(rating === 'good' ? 'üëç Thanks for your feedback!' : 'üëé Thanks for letting us know');
        // CRITICAL: Only clear localStorage after SUCCESSFUL rating submission
        markPendingRatingAsCompleted();
      } else {
        console.error('Rating submission failed:', data.error);
        // Don't clear localStorage - user can try again
      }
    } catch (error) {
      console.error('Error submitting rating:', error);
      // Don't clear localStorage on error - user can try again
    }
    
    // Check if we should redirect after rating
    const shouldRedirect = !!window.pendingLeaveRating;
    
    closeRatingModal();
    
    // If closeRatingModal didn't handle the redirect (in case of timing), handle it here
    if (shouldRedirect && !window.pendingLeaveRating) {
      // Already handled by closeRatingModal
    }
  }
  
  // Skip rating - KEEPS the pending rating so it shows again next time
  function skipRating() {
    console.log('‚è≠Ô∏è User skipped rating - keeping pending rating for next visit');
    
    // DON'T clear localStorage! The rating will show again when user returns
    // Just save to database as backup (in case localStorage is cleared)
    if (pendingRatingData) {
      const otherUserName = document.getElementById('rating-other-user-name')?.textContent;
      
      // Re-save to localStorage to ensure it persists
      savePendingRatingToStorage(pendingRatingData.ratedId, otherUserName);
      
      // Also save to database as backup
      fetch('/.netlify/functions/save-pending-rating', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: pendingRatingData.raterId,
          roomId: pendingRatingData.roomId,
          otherUserId: pendingRatingData.ratedId,
          otherUserName: otherUserName,
        }),
      }).catch(err => console.log('Could not save pending rating to database:', err));
    }
    
    closeRatingModal();
  }
  
  // Close rating modal
  function closeRatingModal() {
    document.getElementById('rating-modal').classList.add('hidden');
    pendingRatingData = null;
    
    // If we were leaving when the rating modal was shown, now redirect
    if (window.pendingLeaveRating) {
      const wasTimerExpired = sessionLimitState.limitReached;
      window.pendingLeaveRating = null;
      console.log('üìä Rating modal closed, redirecting...');
      setTimeout(() => {
        if (wasTimerExpired) {
          window.location.href = '/pricing.html?session_ended=true';
        } else {
          window.location.href = 'https://sphere.chatspheres.com/';
        }
      }, 300);
    }
  }
  
  // Show report modal
  function showReportModal(targetUserId, targetUserName) {
    if (!targetUserId) {
      // Use the other participant if no target specified
      targetUserId = otherParticipantId;
      targetUserName = otherParticipantName;
    }
    
    if (!targetUserId) {
      showToast('‚ùå No user to report');
      return;
    }
    
    reportTargetUserId = targetUserId;
    reportTargetUserName = targetUserName || 'User';
    selectedReportCategory = null;
    
    document.getElementById('report-user-name').innerHTML = `Reporting: <strong>${reportTargetUserName}</strong>`;
    document.getElementById('report-description-section').classList.add('hidden');
    document.getElementById('submit-report-btn').classList.add('hidden');
    document.getElementById('report-description').value = '';
    
    // Reset category button styles
    document.querySelectorAll('.report-category-btn').forEach(btn => {
      btn.classList.remove('border-main-red', 'bg-rose');
      btn.classList.add('border-rose');
    });
    
    document.getElementById('report-modal').classList.remove('hidden');
  }
  
  // Select report category
  function selectReportCategory(category) {
    selectedReportCategory = category;
    
    // Update button styles
    document.querySelectorAll('.report-category-btn').forEach(btn => {
      btn.classList.remove('border-main-red', 'bg-rose');
      btn.classList.add('border-rose');
    });
    event.currentTarget.classList.remove('border-rose');
    event.currentTarget.classList.add('border-main-red', 'bg-rose');
    
    // Show description and submit button
    document.getElementById('report-description-section').classList.remove('hidden');
    document.getElementById('submit-report-btn').classList.remove('hidden');
  }
  
  // Submit report
  async function submitReport() {
    if (!selectedReportCategory || !reportTargetUserId) {
      showToast('‚ùå Please select a category');
      return;
    }
    
    const description = document.getElementById('report-description')?.value?.trim() || '';
    
    try {
      const response = await fetch('/.netlify/functions/submit-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          reporterId: window.currentUserData?.userId,
          reportedId: reportTargetUserId,
          roomId: conversationRoomId || roomUrl,
          category: selectedReportCategory,
          description: description || null,
        }),
      });
      
      const data = await response.json();
      
      if (data.success) {
        showToast('üö© Report submitted. Thank you for keeping ChatSpheres safe!');
        if (data.userSuspended) {
          console.log('User was auto-suspended due to multiple reports');
        }
      } else {
        showToast(`‚ùå ${data.error || 'Failed to submit report'}`);
      }
    } catch (error) {
      console.error('Error submitting report:', error);
      showToast('‚ùå Failed to submit report. Please try again.');
    }
    
    closeReportModal();
  }
  
  // Close report modal
  function closeReportModal() {
    document.getElementById('report-modal').classList.add('hidden');
    selectedReportCategory = null;
    reportTargetUserId = null;
  }
  
  // ========== BUG REPORT FUNCTIONS ==========
  
  // Show bug report modal
  function showBugReportModal() {
    const modal = document.getElementById('bug-report-modal');
    const deviceInfoEl = document.getElementById('bug-device-info');
    
    // Collect device/browser info
    const deviceInfo = {
      browser: navigator.userAgent,
      platform: navigator.platform,
      screen: `${window.screen.width}x${window.screen.height}`,
      viewport: `${window.innerWidth}x${window.innerHeight}`,
      isSafari: isSafari,
      isIOS: isIOS,
      connection: navigator.connection ? navigator.connection.effectiveType : 'unknown'
    };
    
    if (deviceInfoEl) {
      deviceInfoEl.textContent = `${navigator.platform} | ${window.innerWidth}x${window.innerHeight} | ${isSafari ? 'Safari' : isIOS ? 'iOS' : 'Other'}`;
    }
    
    // Store device info for submission
    window.bugReportDeviceInfo = deviceInfo;
    
    // Clear previous inputs
    const categoryEl = document.getElementById('bug-category');
    const descriptionEl = document.getElementById('bug-description');
    if (categoryEl) categoryEl.value = '';
    if (descriptionEl) descriptionEl.value = '';
    
    modal.classList.remove('hidden');
  }
  
  // Close bug report modal
  function closeBugReportModal() {
    document.getElementById('bug-report-modal').classList.add('hidden');
    window.bugReportDeviceInfo = null;
  }
  
  // Submit bug report
  async function submitBugReport() {
    const categoryEl = document.getElementById('bug-category');
    const descriptionEl = document.getElementById('bug-description');
    const submitBtn = document.getElementById('submit-bug-btn');
    
    const category = categoryEl?.value || 'other';
    const description = descriptionEl?.value?.trim();
    
    if (!description) {
      showToast('‚ùå Please describe the bug');
      return;
    }
    
    if (description.length < 10) {
      showToast('‚ùå Please provide more details');
      return;
    }
    
    // Disable button during submission
    if (submitBtn) {
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';
    }
    
    try {
      const response = await fetch('/.netlify/functions/submit-bug-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: window.currentUserData?.userId || 'guest',
          userName: window.currentUserData?.userName || 'Guest',
          userEmail: window.currentUserData?.email || null,
          roomId: firebaseRoomId || conversationRoomId?.split('-')[0] || null,
          category: category,
          description: description,
          deviceInfo: window.bugReportDeviceInfo || {},
          url: window.location.href,
          isSpectator: isSpectator,
          timestamp: new Date().toISOString()
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        showToast('‚úÖ Bug report submitted! Thank you for helping us improve.');
        closeBugReportModal();
      } else {
        showToast(`‚ùå ${data.error || 'Failed to submit bug report'}`);
      }
    } catch (error) {
      console.error('Error submitting bug report:', error);
      showToast('‚ùå Failed to submit bug report. Please try again.');
    } finally {
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Bug Report';
      }
    }
  }
  
  // Block user
  async function blockUser(blockedId, blockedName) {
    if (!window.currentUserData?.userId || !blockedId) {
      showToast('‚ùå Cannot block user');
      return;
    }
    
    if (confirm(`Block ${blockedName || 'this user'}? You will never be matched with them again.`)) {
      try {
        const response = await fetch('/.netlify/functions/block-user', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            blockerId: window.currentUserData.userId,
            blockedId: blockedId,
          }),
        });
        
        const data = await response.json();
        
        if (data.success) {
          showToast('üö´ User blocked. You won\'t see them again.');
        } else {
          showToast(`‚ùå ${data.error || 'Failed to block user'}`);
        }
      } catch (error) {
        console.error('Error blocking user:', error);
        showToast('‚ùå Failed to block user. Please try again.');
      }
    }
  }
  
  // Toggle mute user in chat (host only)
  // Uses Supabase via Netlify function for persistence
  async function toggleMuteUser(userId, userName) {
    console.log('üîá toggleMuteUser called:', { userId, userName, isHost: roomHostData.isHost });
    
    if (!roomHostData.isHost) {
      showToast('‚ùå Only hosts can mute users');
      return;
    }
    
    if (!userId) {
      showToast('‚ùå No user to mute');
      return;
    }
    
    const isMuted = mutedChatUserIds.has(userId);
    const roomId = firebaseRoomId || conversationRoomId?.split('-')[0];
    
    if (!roomId) {
      showToast('‚ùå Room not found');
      return;
    }
    
    try {
      // Use Supabase via Netlify function for mute
      const response = await fetch('/.netlify/functions/mute-chat-user', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: roomId,
          mutedUserId: userId,
          hostId: roomHostData.hostId || window.currentUserData?.userId,
          action: isMuted ? 'unmute' : 'mute'
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Update local state immediately
        if (isMuted) {
          mutedChatUserIds.delete(userId);
          console.log('üîä User unmuted:', userId);
          showToast(`üîä ${userName || 'User'} unmuted`);
        } else {
          mutedChatUserIds.add(userId);
          console.log('üîá User muted:', userId);
          showToast(`üîá ${userName || 'User'} muted`);
        }
        
        // Refresh chat messages to reflect mute state
        refreshChatMessages();
      } else {
        throw new Error(data.error || 'Failed to update mute status');
      }
    } catch (error) {
      console.error('Error toggling mute:', error);
      showToast('‚ùå Failed to update mute status. Please try again.');
    }
  }
  
  // Load muted users from Supabase on initialization
  async function setupMuteListener() {
    const roomId = firebaseRoomId || conversationRoomId?.split('-')[0];
    if (!roomId) return;
    
    try {
      // Load initial muted users from Supabase
      const response = await fetch(`/.netlify/functions/mute-chat-user?roomId=${roomId}`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.mutedUserIds && Array.isArray(data.mutedUserIds)) {
          mutedChatUserIds = new Set(data.mutedUserIds);
          console.log('üîá Loaded muted users:', mutedChatUserIds.size);
          refreshChatMessages();
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è Could not load muted users:', error.message);
    }
    
    console.log('‚úÖ Mute listener set up for room:', roomId);
  }
  
  // Refresh chat messages (re-render with current mute state)
  function refreshChatMessages() {
    const chatContainers = [
      document.getElementById('live-chat-messages'),
      document.getElementById('participant-chat-messages')
    ].filter(Boolean);
    
    chatContainers.forEach(container => {
      const messages = container.querySelectorAll('.chat-message');
      messages.forEach(msgEl => {
        const userId = msgEl.dataset.userId;
        if (userId && mutedChatUserIds.has(userId)) {
          msgEl.style.display = 'none';
        } else {
          msgEl.style.display = '';
        }
        
        // Update mute button icon
        const muteBtn = msgEl.querySelector('button[onclick^="toggleMuteUser"]');
        if (muteBtn && userId) {
          const isMuted = mutedChatUserIds.has(userId);
          muteBtn.textContent = isMuted ? 'üîä' : 'üîá';
          muteBtn.title = isMuted ? 'Unmute user' : 'Mute user';
          muteBtn.className = muteBtn.className.replace(/text-(main-red|green-600)/g, isMuted ? 'text-green-600' : 'text-main-red');
        }
      });
    });
  }
  
  // Load muted users is now handled by setupMuteListener()
  // This function is kept for backward compatibility
  async function loadMutedUsers() {
    // Mutes are now loaded via Firebase listener
    setupMuteListener();
  }
  
  // Chat spam prevention wrapper
  function validateChatMessage(text) {
    const now = Date.now();
    
    // Rate limit check
    if (now - lastChatMessageTime < CHAT_RATE_LIMIT_MS) {
      const waitTime = Math.ceil((CHAT_RATE_LIMIT_MS - (now - lastChatMessageTime)) / 1000);
      showToast(`‚è≥ Slow down! Wait ${waitTime} second${waitTime > 1 ? 's' : ''}.`);
      return false;
    }
    
    // Duplicate message check
    if (text === lastChatMessageText && lastChatMessageText !== '') {
      showToast('‚ö†Ô∏è You already sent that message.');
      return false;
    }
    
    // Character limit (already enforced by maxlength, but double-check)
    if (text.length > 200) {
      showToast('‚ö†Ô∏è Message too long (200 chars max).');
      return false;
    }
    
    // Empty message check
    if (!text.trim()) {
      return false;
    }
    
    // Update tracking
    lastChatMessageTime = now;
    lastChatMessageText = text;
    
    return true;
  }
  
  // Check for pending rating on page load - checks localStorage FIRST, then database
  async function checkPendingRating() {
    if (!window.currentUserData?.userId || window.currentUserData.isGuest) {
      console.log('‚è≠Ô∏è Skipping pending rating check - no user or guest');
      return;
    }
    
    // FIRST: Check localStorage (faster and more reliable)
    const localStorageData = getPendingRatingFromStorage();
    if (localStorageData && localStorageData.ratedId) {
      console.log('üìä Found pending rating in localStorage - showing modal');
      checkAndShowPendingRatingFromStorage();
      return; // Don't check database if we found local data
    }
    
    // FALLBACK: Check database
    try {
      const response = await fetch(`/.netlify/functions/get-pending-rating?userId=${window.currentUserData.userId}`);
      const data = await response.json();
      
      if (data.hasPending && data.pendingRating) {
        console.log('üìä Found pending rating in database - showing modal');
        // Show rating modal for previous call
        setTimeout(() => {
          pendingRatingData = {
            raterId: window.currentUserData.userId,
            ratedId: data.pendingRating.otherUserId,
            roomId: data.pendingRating.roomId,
          };
          
          // Also save to localStorage for next time
          savePendingRatingToStorage(data.pendingRating.otherUserId, data.pendingRating.otherUserName);
          
          document.getElementById('rating-other-user-name').textContent = data.pendingRating.otherUserName || 'your previous chat partner';
          document.getElementById('rating-modal').classList.remove('hidden');
          document.getElementById('rating-feedback').value = '';
          
          const charCount = document.getElementById('feedback-char-count');
          if (charCount) charCount.textContent = '0';
        }, 1000);
      }
    } catch (error) {
      console.log('Could not check pending rating from database:', error);
    }
  }
  
  // Check if user is suspended
  async function checkUserSuspension() {
    if (!window.currentUserData?.userId) {
      return false;
    }
    
    try {
      const response = await fetch(`/.netlify/functions/check-suspension?userId=${window.currentUserData.userId}`);
      const data = await response.json();
      
      if (data.isSuspended) {
        // Show suspension message and prevent joining
        alert(`Your account has been suspended.\n\nReason: ${data.suspension.reason}\n\nIf you believe this is a mistake, please contact support.`);
        window.location.href = '/contact.html';
        return true;
      }
    } catch (error) {
      console.log('Could not check suspension:', error);
    }
    
    return false;
  }
  
  // Update other participant tracking (called when someone joins)
  function updateOtherParticipant(participantId, participantName) {
    if (participantId && participantId !== window.currentUserData?.userId) {
      otherParticipantId = participantId;
      otherParticipantName = participantName;
      
      // CRITICAL: Save to localStorage immediately so we can show rating even if user closes tab
      savePendingRatingToStorage(participantId, participantName);
    }
  }
  
  // ========================================
  // PERSISTENT RATING SYSTEM - ALWAYS SHOW RATING
  // ========================================
  
  const PENDING_RATING_STORAGE_KEY = 'chatspheres_pending_rating';
  
  // Save pending rating to localStorage
  function savePendingRatingToStorage(otherUserId, otherUserName) {
    if (!otherUserId || !window.currentUserData?.userId || window.currentUserData?.isGuest || isSpectator) {
      return;
    }
    
    const pendingData = {
      raterId: window.currentUserData.userId,
      ratedId: otherUserId,
      otherUserName: otherUserName || 'your chat partner',
      roomId: conversationRoomId || roomUrl || 'unknown',
      timestamp: Date.now(),
      rated: false
    };
    
    try {
      localStorage.setItem(PENDING_RATING_STORAGE_KEY, JSON.stringify(pendingData));
      console.log('üíæ Saved pending rating to localStorage:', pendingData.ratedId);
    } catch (e) {
      console.warn('Could not save pending rating to localStorage:', e);
    }
  }
  
  // Get pending rating from localStorage
  function getPendingRatingFromStorage() {
    try {
      const data = localStorage.getItem(PENDING_RATING_STORAGE_KEY);
      if (!data) return null;
      
      const parsed = JSON.parse(data);
      
      // Only return if it's for the current user and not expired (24 hours)
      const twentyFourHours = 24 * 60 * 60 * 1000;
      if (parsed.raterId === window.currentUserData?.userId && 
          !parsed.rated &&
          (Date.now() - parsed.timestamp) < twentyFourHours) {
        return parsed;
      }
      
      // Clean up expired data
      if ((Date.now() - parsed.timestamp) >= twentyFourHours) {
        clearPendingRatingFromStorage();
      }
      
      return null;
    } catch (e) {
      console.warn('Could not read pending rating from localStorage:', e);
      return null;
    }
  }
  
  // Clear pending rating from localStorage (only after successful submission)
  function clearPendingRatingFromStorage() {
    try {
      localStorage.removeItem(PENDING_RATING_STORAGE_KEY);
      console.log('üóëÔ∏è Cleared pending rating from localStorage');
    } catch (e) {
      console.warn('Could not clear pending rating from localStorage:', e);
    }
  }
  
  // Mark pending rating as completed but keep data for verification
  function markPendingRatingAsCompleted() {
    try {
      const data = localStorage.getItem(PENDING_RATING_STORAGE_KEY);
      if (data) {
        const parsed = JSON.parse(data);
        parsed.rated = true;
        localStorage.setItem(PENDING_RATING_STORAGE_KEY, JSON.stringify(parsed));
      }
    } catch (e) {
      console.warn('Could not mark pending rating as completed:', e);
    }
    // Clear after a small delay to allow submission
    setTimeout(clearPendingRatingFromStorage, 1000);
  }
  
  // Check and show pending rating modal (call on page load)
  function checkAndShowPendingRatingFromStorage() {
    // Don't show if we're a spectator or guest
    if (isSpectator || window.currentUserData?.isGuest || !window.currentUserData?.userId) {
      console.log('‚è≠Ô∏è Skipping localStorage rating check - spectator/guest');
      return;
    }
    
    const pendingData = getPendingRatingFromStorage();
    if (pendingData && pendingData.ratedId) {
      console.log('üìä Found pending rating in localStorage:', pendingData.ratedId);
      
      // Show rating modal after a short delay
      setTimeout(() => {
        pendingRatingData = {
          raterId: pendingData.raterId,
          ratedId: pendingData.ratedId,
          roomId: pendingData.roomId,
        };
        
        const displayName = pendingData.otherUserName || 'your previous chat partner';
        document.getElementById('rating-other-user-name').textContent = displayName;
        document.getElementById('rating-modal').classList.remove('hidden');
        document.getElementById('rating-feedback').value = '';
        
        const charCount = document.getElementById('feedback-char-count');
        if (charCount) charCount.textContent = '0';
        
        console.log('üìä Showing rating modal from localStorage for:', displayName);
      }, 500);
    }
  }
  
  // ========================================
  // SPECTATOR MANAGEMENT (Host Only)
  // ========================================
  
  let currentSpectators = [];
  
  // Show spectator management modal
  function showSpectatorManagementModal() {
    if (!roomHostData.isHost) {
      showToast('‚ùå Only the host can manage spectators');
      return;
    }
    
    document.getElementById('spectator-management-modal').classList.remove('hidden');
    loadSpectatorList();
  }
  
  // Close spectator management modal
  function closeSpectatorManagementModal() {
    document.getElementById('spectator-management-modal').classList.add('hidden');
  }
  
  // Load spectators from Firebase presence
  async function loadSpectatorList() {
    const spectatorListEl = document.getElementById('spectator-list');
    
    if (!spectatorListEl) return;
    
    try {
      // Get spectators from Firebase presence
      const presenceRef = db.ref(`presence/${firebaseRoomId}`);
      const snapshot = await presenceRef.once('value');
      const users = snapshot.val() || {};
      
      const now = Date.now();
      
      // Filter to only spectators (not stale)
      currentSpectators = Object.entries(users)
        .filter(([key, user]) => {
          const updatedAt = user.updatedAt || user.joinedAt || 0;
          const isStale = (now - updatedAt) > PRESENCE_STALE_THRESHOLD_MS;
          return !isStale && user.type === 'spectator';
        })
        .map(([key, user]) => ({
          presenceKey: key,
          sessionId: user.sessionId,
          userId: user.userId,
          userName: user.name || user.displayName || 'Guest',
          joinedAt: user.joinedAt
        }));
      
      console.log(`üë• Found ${currentSpectators.length} spectators`);
      
      // Update count
      const countEl = document.getElementById('spectator-count');
      if (countEl) {
        countEl.textContent = `${currentSpectators.length} viewer${currentSpectators.length !== 1 ? 's' : ''} watching`;
      }
      
      // Clear search
      const searchEl = document.getElementById('spectator-search');
      if (searchEl) searchEl.value = '';
      
      if (currentSpectators.length === 0) {
        spectatorListEl.innerHTML = `
          <div class="text-center text-charcoal opacity-60 py-8">
            <p class="text-4xl mb-2">üëÄ</p>
            <p>No spectators watching right now</p>
          </div>
        `;
        return;
      }
      
      // Render spectator list
      renderSpectatorList(currentSpectators);
      
    } catch (error) {
      console.error('‚ùå Error loading spectators:', error);
      spectatorListEl.innerHTML = `
        <div class="text-center text-main-red py-8">
          <p>Failed to load spectators</p>
        </div>
      `;
    }
  }
  
  // Render filtered spectator list
  function renderSpectatorList(spectators, searchTerm = '') {
    const spectatorListEl = document.getElementById('spectator-list');
    if (!spectatorListEl) return;
    
    // Filter by search term if provided
    const filtered = searchTerm 
      ? spectators.filter(s => s.userName.toLowerCase().includes(searchTerm.toLowerCase()))
      : spectators;
    
    if (filtered.length === 0) {
      spectatorListEl.innerHTML = `
        <div class="text-center text-charcoal opacity-60 py-8">
          <p>${searchTerm ? 'No matching spectators found' : 'No spectators watching right now'}</p>
        </div>
      `;
      return;
    }
    
    spectatorListEl.innerHTML = filtered.map(spectator => {
      const isMuted = mutedChatUserIds.has(spectator.userId);
      const joinedTime = spectator.joinedAt ? new Date(spectator.joinedAt).toLocaleTimeString() : 'Unknown';
      
      return `
        <div class="flex items-center justify-between p-3 bg-white rounded-xl shadow-sm" data-spectator-id="${spectator.sessionId}" data-user-id="${spectator.userId}">
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 rounded-full bg-charcoal flex items-center justify-center text-white font-bold">
              ${spectator.userName.charAt(0).toUpperCase()}
            </div>
            <div>
              <p class="font-bold text-charcoal">${escapeHtml(spectator.userName)}</p>
              <p class="text-xs text-charcoal opacity-60">Joined ${joinedTime}</p>
            </div>
          </div>
          <button 
            onclick="toggleMuteSpectator('${spectator.userId}', '${escapeHtml(spectator.userName)}')"
            class="px-4 py-2 ${isMuted ? 'bg-main-red text-white' : 'bg-rose text-charcoal'} rounded-full text-sm font-bold hover:opacity-80 transition-all"
            title="${isMuted ? 'Unmute in chat' : 'Mute in chat'}">
            ${isMuted ? 'üîá Unmute' : 'üîä Mute'}
          </button>
        </div>
      `;
    }).join('');
  }
  
  // Search spectators
  function searchSpectators(searchTerm) {
    renderSpectatorList(currentSpectators, searchTerm);
  }
  
  // Mute/unmute spectator in chat (uses existing mute system)
  async function toggleMuteSpectator(userId, userName) {
    await toggleMuteUser(userId, userName);
    // Refresh the list to update button states
    loadSpectatorList();
  }
  
  // Show/hide the manage spectators button based on host status
  function updateSpectatorManagementButton() {
    const btn = document.getElementById('floating-spectator-btn');
    if (!btn) return;
    
    if (roomHostData.isHost && !isSpectator) {
      btn.classList.remove('hidden');
    } else {
      btn.classList.add('hidden');
    }
  }
  
  // ========================================
  // END MODERATION SYSTEM
  // ========================================

  // Make functions global
  window.toggleSpectatorExpansion = toggleSpectatorExpansion;
  window.showAuthModal = showAuthModal;
  window.hideAuthModal = hideAuthModal;
  window.switchAuthTab = switchAuthTab;
  window.handleSignIn = handleSignIn;
  window.handleSignUp = handleSignUp;
  window.handleGoogleSignIn = handleGoogleSignIn;
  window.continueAsGuest = continueAsGuest;
  window.signOut = signOut;
  
  // Moderation functions
  window.showRatingModal = showRatingModal;
  window.submitRating = submitRating;
  window.skipRating = skipRating;
  window.closeRatingModal = closeRatingModal;
  window.showReportModal = showReportModal;
  window.selectReportCategory = selectReportCategory;
  window.submitReport = submitReport;
  window.closeReportModal = closeReportModal;
  window.blockUser = blockUser;
  window.toggleMuteUser = toggleMuteUser;
  
  // Bug report functions
  window.showBugReportModal = showBugReportModal;
  window.closeBugReportModal = closeBugReportModal;
  window.submitBugReport = submitBugReport;
  
  // Spectator management functions
  window.showSpectatorManagementModal = showSpectatorManagementModal;
  window.closeSpectatorManagementModal = closeSpectatorManagementModal;
  window.toggleMuteSpectator = toggleMuteSpectator;
  window.searchSpectators = searchSpectators;

  // Initialize
  console.log("ChatSpheres Video Chat Room Loading... üåü");
  console.log(`Mode: ${isSpectator ? 'Spectator üëÄ' : 'Participant üé§'}`);
  
  // Start the app initialization (checks auth first)
  initializeApp().catch(error => {
    console.error('‚ùå App initialization failed:', error);
  });
</script>

<!-- Ad Management Script -->
<script src="/assets/js/ads.js"></script>

<!-- Cross-Domain Referral Tracking -->
<script src="/assets/js/referral.js"></script>

</body>
</html>
